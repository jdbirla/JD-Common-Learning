# LinkedIn Learning

# Table of contents

- [LinkedIn Learning](#linkedin-learning)
  - [𝗠𝗮𝘀𝘁𝗲𝗿𝗶𝗻𝗴 𝗗𝗲𝘃𝗢𝗽𝘀: 𝗔 𝗩𝗶𝘀𝘂𝗮𝗹 𝗚𝘂𝗶𝗱𝗲](#----)
  - [Hospital Managment SpringBoot APP](#hospital-managment-springboot-app)
  - [List of common annotations/methods used with Spring boot testing 🔥](#list-of-common-annotationsmethods-used-with-spring-boot-testing-)
  - [Companies List that are HIRING for 100% REMOTE.](#companies-list-that-are-hiring-for-100-remote)
  - [Scrum](#scrum)
  - [24 repos you can't miss out as a software engineer:](#24-repos-you-cant-miss-out-as-a-software-engineer)
    - [Interview preparation:](#interview-preparation)
    - [System design:](#system-design)
    - [LLM/AI:](#llmai)
    - [Complete roadmaps:](#complete-roadmaps)
    - [Frontend:](#frontend)
  - [Choosing the right database for your needs? Consider these points:](#choosing-the-right-database-for-your-needs-consider-these-points)
  - [6 Must Know Software Architectural Patterns](#6-must-know-software-architectural-patterns)
  - [Core Components of System Architecture](#core-components-of-system-architecture)
  - [𝐇𝐨𝐰 𝐑𝐄𝐒𝐓 𝐀𝐏𝐈 𝐰𝐨𝐫𝐤?](#---)
  - [Single Sign-On (SSO) explained in simple terms.](#single-sign-on-sso-explained-in-simple-terms)
    - [𝗞𝗲𝘆 𝗣𝗹𝗮𝘆𝗲𝗿𝘀 𝗶𝗻 𝗦𝗦𝗢](#---)
    - [𝗕𝗲𝗻𝗲𝗳𝗶𝘁𝘀 𝗼𝗳 𝗦𝗦𝗢](#--)
    - [𝗛𝗼𝘄 𝗦𝗦𝗢 𝗪𝗼𝗿𝗸𝘀](#--)
  - [ChatGPT Mastery Cheat Sheet](#chatgpt-mastery-cheat-sheet)
  - [Hands-On Guide: Implementing CI/CD for your web application with AWS Codepipeline](#hands-on-guide-implementing-cicd-for-your-web-application-with-aws-codepipeline)
  - [IBM and Meta offering Web Development Courses for everyone.🚀🚀](#ibm-and-meta-offering-web-development-courses-for-everyone)
  - [How DNS Works - A Simplified Overview](#how-dns-works---a-simplified-overview)
  - [Insights into SSL Certificate Workflow:](#insights-into-ssl-certificate-workflow)
  - [Sorting algorithms](#sorting-algorithms)
  - [Log Parsing Cheat Sheet](#log-parsing-cheat-sheet)
  - [𝐇𝐨𝐰 𝐝𝐨 𝐩𝐫𝐨𝐭𝐨𝐜𝐨𝐥𝐬 𝐰𝐨𝐫𝐤 𝐢𝐧 𝐭𝐡𝐞 𝐓𝐂𝐏/𝐈𝐏 𝐨𝐫 𝐎𝐒𝐈 𝐌𝐨𝐝𝐞𝐥❓](#---------)
  - [Java Exceptions](#java-exceptions)
  - [𝗢𝗽𝘁𝗶𝗺𝗶𝘀𝗲 𝗬𝗼𝘂𝗿 𝗗𝗼𝗰𝗸𝗲𝗿 𝗪𝗼𝗿𝗸𝗳𝗹𝗼𝘄 🚀💻](#----)
  - [Forget web developers/Web Designer](#forget-web-developersweb-designer)
  - [Session, Cookie, JWT, Token, SSO, and OAuth 2.0 Explained in One Diagram](#session-cookie-jwt-token-sso-and-oauth-20-explained-in-one-diagram)
  - [Top 12 Tips for API Security](#top-12-tips-for-api-security)
  - [](#)
  - 
## 𝗠𝗮𝘀𝘁𝗲𝗿𝗶𝗻𝗴 𝗗𝗲𝘃𝗢𝗽𝘀: 𝗔 𝗩𝗶𝘀𝘂𝗮𝗹 𝗚𝘂𝗶𝗱𝗲
![1706844743207](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/0f083413-adab-46d8-a0c4-0f0a4c469694)

## Hospital Managment SpringBoot APP
- Hospital Management API built in Spring Boot
- https://github.com/MirnaGama/hospital-management-api

## List of common annotations/methods used with Spring boot testing 🔥
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/a174cbf6-fe9d-49ca-bb92-d18d2e19724d)

## Companies List that are HIRING for 100% REMOTE.

1. Quest Software - https://lnkd.in/gqaB5RTN
2. Upstart - https://lnkd.in/g3sXD8DZ
3. Celigo - https://lnkd.in/gKhSMxNY (US & India)
4. Cengage Group - https://lnkd.in/gGkT6jRZ
5. Docker, Inc - https://lnkd.in/gfX5-pQG
6. hims & hers - https://lnkd.in/gr_SdVdE
7. UserGems 💎 Interviews - https://lnkd.in/gXi3mNf6
8. Abnormal Security - https://lnkd.in/gn5M4VDF
9. Cash App - https://lnkd.in/gdp8yUm8
10. LogicGate - https://lnkd.in/gjgX27Bc
11. Faire - https://lnkd.in/gYRNr9VM
12. Renaissance Learning - https://lnkd.in/gesiM_Dw
13. Rec Room - https://lnkd.in/gErDuTNa
14. VGS (Very Good Security) - https://lnkd.in/g7Ajb77F
15. VAST Data - https://lnkd.in/gMUFt4y9
16. Sorcero - https://lnkd.in/gpmDTnH7
17. McGraw Hill - https://lnkd.in/g59pzFf4
18. Patreon - https://lnkd.in/gzQptMcQ (NY/San Francisco)
19. Beekeeper - https://lnkd.in/gxd7rs7Q (Senior PMM)
20. Upwork - https://lnkd.in/gt4HYmd6
21. DocuSign - https://lnkd.in/ggfUncZf
22. DealHub.io - https://lnkd.in/gyNED4yp
23. Census - https://lnkd.in/gAq7PGzc
24. Intrado - https://lnkd.in/gH3wuNWZ
25. Cloudflare - https://lnkd.in/g9JPXp2F
26. Funded.club - https://lnkd.in/gpH4FazA
27. Workiva - https://lnkd.in/g-FUYYdR
28. MissionWired - https://lnkd.in/gMA6AVdG
29. Workera - https://lnkd.in/g2YzZu-H
30. Jenius Bank - https://lnkd.in/gxGqHGkH

## Scrum

![1706495418935](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/9b3c8b1f-8318-4eca-86c4-17645650dc25)

## 24 repos you can't miss out as a software engineer:

### Interview preparation:

1. Tech Interview Handbook: https://lnkd.in/d2F5z4Af (by Yangshun Tay)

2. Guide to software engineering interviews: https://lnkd.in/dm2MbsgD (by Kevin Naughton)

3. Devops exercises: https://lnkd.in/dPCDT55k

### System design:

4. Big Tech engineering tech blogs: https://lnkd.in/dJaGjeES

5. System Design 101: https://lnkd.in/d5itZHgQ (by Alex Xu)

6. System design primer: https://lnkd.in/dkPScaCW (by Donne Martin)

7. Essential JS design patterns: https://lnkd.in/dWmBwK-i (by Addy Osmani)

8. Awesome scalability: https://lnkd.in/de4UZbiA

9. Awesome System Design Resources: https://lnkd.in/dU6wFXkn (by Ashish Pratap Singh)

10. Coding Challenges solutions: https://lnkd.in/dJV_8pgH (by John Crickett)

### LLM/AI:

11. Hands on LLM: https://lnkd.in/dww8GPdt (by Paul Iusztin)

12. Papers we love: https://lnkd.in/dkjsCq8z

13. Notes on AI for software engineers: https://lnkd.in/dANSnC4f

14. LLM 101 course: https://lnkd.in/dVKwvVUR (by Maxime Labonne)

15. ML paper of the week: https://lnkd.in/d66HxP52 (by Elvis S.)

### Complete roadmaps:

16. Path to senior engineer handbook: https://lnkd.in/dC3dQvy6 (by Jordan Cutler)

17. 100+ Resources to become a great Engineering leader: https://lnkd.in/dFwV2GMv (by Gregor Ojstersek)

18. DevOps roadmap in 2024: https://lnkd.in/ddE5DkDJ (by Dr Milan Milanović)

19. The Book of Secret Knowledge: https://lnkd.in/d69jrK4T

20. Free programming books: https://lnkd.in/d5JCRakw

21. The ultimate developer roadmap: https://lnkd.in/dsCJgDnS (by Kamran Ahmed)

### Frontend:

22. CSS for JS dev notes: https://lnkd.in/dCNavrNv (by Tiger Abrodi)

23. Javascript Questions: https://lnkd.in/dt_96xJZ (by Lydia Hallie)

24. Typescript advanced patterns workshop: https://lnkd.in/deTBDhCb (by Matt Pocock)

If you liked this, you'll love Hungry Minds, my free weekly newsletter curating the best deep dives, trends and tools to grow as a software engineer: https://hungryminds.dev

## Choosing the right database for your needs? Consider these points:
1 ACID Transactions (OLTP): RDS, Aurora, Azure SQL Database

2 Relational (Cloud Agnostic): SQL Server, Oracle, Cockroach, MySQL, PostgreSQL

3 Analytics (OLAP) Columnar: RedShift, Azure Synapse, Snowflake, BigQuery, Databricks, HIVE

4 Memory-store In-memory: Redis, Memcached, Hazelcast, Ignite

5 Key-Value: Redis, DynamoDB, CosmosDB, BigTable, RocksDB, Ignite

6 Wide Column Data Type: HBase, Cassandra, ScyllaDB

7 Semi-Structured: CosmosDB, BigTable, BigQuery, HBase, Cassandra

8 Time Series: CosmosDB, BigTable, BigQuery, TimescaleDB, OpenTSDB, InfluxDB

9 Graph: Neptune, CosmosDB, JanusGraph, Table Graph, Solr, PostGIS, MongoDB (GeoJSON), OrientDB, Neo4J, Tiger Graph
10 Document: CosmosDB, Firestore, MongoDB, Couchbase

11 Full Text Search: Cloud-Search, Cognitive Search, Elastic-Search, Solr, Elassandra

12 Unstructured (Rich) Text: S3, Blob Storage, Cloud Storage, HDFS, Blob

![1706096041699](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/86629c73-2387-4d2c-95c7-b3de74c11843)

## 6 Must Know Software Architectural Patterns
1 - Event-Driven Architecture
Decoupled Components and Asynchronous Communication.
Application: Ideal for systems where events trigger actions, fostering scalability and responsiveness.

2 - Layered Architecture
Hierarchical Structure with Distinct Layers (Presentation, Business Logic, Data).
Application: Common in enterprise applications, enhancing maintainability through compartmentalization and modular development.

3 - Monolithic Architecture
Unified Codebase and Deployment Unit.
Application: Suited for smaller applications or simplicity-focused instances. Streamlines development and deployment with potential scaling challenges.

4 - Microservices Architecture
Distributed System with Independent, Interoperable Services.
Application: Ideal for large and intricate systems, improving scalability, fault isolation, and enabling independent service development.

5 - Model-View-Controller (MVC)
Segregation of Concerns into Model, View, and Controller Components.
Application: Common in web applications, enhancing code organization and maintenance by separating complex UI logic.

6 - Master-Slave Architecture
Centralized Control (Master) with Multiple Worker Nodes (Slaves).
Application: Ubiquitous in distributed computing, optimizing parallel processing and load balancing.

![1706103060616](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/be177349-23dc-4156-88f4-65c1bbd158ad)


## Core Components of System Architecture
[Distributed Messaging Queues]
Enables seamless communication between different components of a system, ensuring efficient message exchange.

[DNS (Domain Name System)]
Facilitates the translation of user-friendly domain names into IP addresses, enabling browsers to locate web servers on the internet.

[Load Balancer]
Distributes incoming web traffic across multiple servers, ensuring optimal resource utilization and preventing overload on individual servers.

[Distributed Caching]
Stores frequently used data efficiently, reducing the need for repeated retrieval from slower databases.

[Database]
Organizes, stores, and retrieves data, serving as a central hub for various applications and services.

[Distributed Task Scheduler]
Efficiently organizes and assigns tasks across different system components, ensuring coordinated operations.

[Observability]
Provides insights into system performance, aiding issue identification and maintaining optimal functioning.

[Unstructured Data Storage]
Accommodates various data types without requiring predefined structures, offering flexibility.

[Scaling Services]
Enables the system to handle increased traffic and demand by expanding its capacity.

[Publish-Subscribe Model]
Facilitates communication between different system parts without direct connections.

[Unique ID Generator]
Creates distinct identifiers for each piece of data, ensuring data integrity and uniqueness.

[Rate-Limiting]
Controls the flow of requests to maintain a steady and manageable pace, preventing strain on the system.

![1706103060616](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/b0885934-5c90-42bd-8124-284f347456fb)

## 𝐇𝐨𝐰 𝐑𝐄𝐒𝐓 𝐀𝐏𝐈 𝐰𝐨𝐫𝐤?
At its core, 𝐑𝐄𝐒𝐓 (𝐑𝐞𝐩𝐫𝐞𝐬𝐞𝐧𝐭𝐚𝐭𝐢𝐨𝐧𝐚𝐥 𝐒𝐭𝐚𝐭𝐞 𝐓𝐫𝐚𝐧𝐬𝐟𝐞𝐫) is an architectural style that provides a set of constraints for designing networked applications. REST APIs serve as the building blocks for communication between different software components, enabling them to request and exchange data seamlessly.

Here's a simplified breakdown of REST API for you!

𝐑𝐞𝐬𝐨𝐮𝐫𝐜𝐞𝐬: REST revolves around resources, which can be anything from a user profile to a product catalog. Each resource is uniquely identified by a URL, forming the basis for interactions.

𝐇𝐓𝐓𝐏 𝐕𝐞𝐫𝐛𝐬: REST APIs make use of the HTTP methods (GET, POST, PUT, DELETE, etc.) to perform actions on resources. For instance, a GET request retrieves data, while a POST request creates new data.

𝐒𝐭𝐚𝐭𝐞𝐥𝐞𝐬𝐬 𝐂𝐨𝐦𝐦𝐮𝐧𝐢𝐜𝐚𝐭𝐢𝐨𝐧: One of REST's key principles is statelessness. Each request to a REST API should contain all the information needed to understand and process it, making the interactions independent of one another.

𝐔𝐧𝐢𝐟𝐨𝐫𝐦 𝐈𝐧𝐭𝐞𝐫𝐟𝐚𝐜𝐞: REST APIs have a consistent and uniform interface that follows conventions. This predictability simplifies development and integration.

𝐑𝐞𝐩𝐫𝐞𝐬𝐞𝐧𝐭𝐚𝐭𝐢𝐨𝐧: Resources are represented in a format, often JSON or XML. This representation is sent between the client and server to carry information.

𝐂𝐥𝐢𝐞𝐧𝐭-𝐒𝐞𝐫𝐯𝐞𝐫 𝐀𝐫𝐜𝐡𝐢𝐭𝐞𝐜𝐭𝐮𝐫𝐞: REST emphasizes the separation between clients (the user interface) and servers (the data storage and processing), allowing for greater scalability and flexibility.

So, the next time you interact with an app on your smartphone, think about how REST APIs enable it to fetch your latest messages, update your profile, or show you the news. REST is the behind-the-scenes magician that ensures everything works seamlessly.

Let's keep the conversation going and demystify the tech that powers our digital world!

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/05d80a5f-5e68-494b-a5ed-28ddbfbc7f0f)

## Single Sign-On (SSO) explained in simple terms.

### 𝗞𝗲𝘆 𝗣𝗹𝗮𝘆𝗲𝗿𝘀 𝗶𝗻 𝗦𝗦𝗢

1. User - The individual seeking access to applications
2. Identity Provider (IDP) - Authenticates users (e.g. Google, Facebook)
3. Application - The software or service the user wants to access

### 𝗕𝗲𝗻𝗲𝗳𝗶𝘁𝘀 𝗼𝗳 𝗦𝗦𝗢

- Simplifies access with one set of credentials
- Enhances user experience
- Reduces password fatigue
- Centralizes security and access management
- Improves security
- Streamlines access control
- Simplifies compliance reporting
- Allows seamless integration

### 𝗛𝗼𝘄 𝗦𝗦𝗢 𝗪𝗼𝗿𝗸𝘀

- User tries to log into an application
- Application redirects user to SSO/IDP
- IDP authenticates user
- IDP issues authenticated token
- Token sent back to browser
- Browser presents token to application
- Application grants access without re-entering credentials

This streamlined process enables single login access to multiple applications, improving convenience and security.

Over to you: With SSO facilitating access across various platforms, what measures do you consider essential to maintain the integrity and security of user identities?

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/9d4a2610-84ee-4061-a416-e797ec3783c7)

## ChatGPT Mastery Cheat Sheet
Unlock the full potential of ChatGPT:

𝗔𝗰𝘁 𝗮𝘀 𝗮 [𝗥𝗢𝗟𝗘]:
• Support Representative
• Code Debugger
• Language Translator

𝗠𝗼𝗱𝗲𝘀 𝗮𝗻𝗱 𝗥𝗼𝗹𝗲𝘀:
• Generate Ideas for [Project]
• Plan Schedule for [Event]
• Edit Content for [Publication]

𝗦𝗲𝘁 𝗧𝗼𝗻𝗲𝘀:
• Formal
• Casual
• Enthusiastic

𝗖𝗿𝗲𝗮𝘁𝗲 𝗮 𝗧𝗮𝘀𝗸:
• Generate Code
• Plan Outline
• Write Story

𝗗𝗲𝗳𝗶𝗻𝗲 [𝗙𝗼𝗿𝗺𝗮𝘁]:
• Bullet Points
• List
• Code Snippet

𝗔𝘂𝘁𝗼𝗺𝗮𝘁𝗶𝗼𝗻:
• Streamlining Processes
• Repetitive Tasks
• Operational Streamlining

𝗥𝗲𝘀𝗲𝗮𝗿𝗰𝗵 𝗣𝗿𝗼𝗺𝗽𝘁𝘀:
• Summarize Scientific Article
• Compile Recent Studies on [Topic]
• Explore Recent Research Studies

𝗗𝗲𝘀𝗶𝗴𝗻𝗲𝗿 𝗣𝗿𝗼𝗺𝗽𝘁𝘀:
• Design Distinctive Logo
• Develop Website Mockup
• Generate Color Palette

𝗠𝗮𝗿𝗸𝗲𝘁𝗲𝗿 𝗣𝗿𝗼𝗺𝗽𝘁𝘀:
• Craft Persuasive Marketing Copy
• Develop Tagline Ideas
• Create Social Media Posts

𝗗𝗲𝘃𝗲𝗹𝗼𝗽𝗲𝗿 𝗣𝗿𝗼𝗺𝗽𝘁𝘀:
• Resolve Code Issues
• Generate Python Script
• Explain Algorithmic Concepts

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/ac24ee39-3ebc-4f9d-812e-a02abeaa7d6d)

## Hands-On Guide: Implementing CI/CD for your web application with AWS Codepipeline
https://www.linkedin.com/posts/mtayyabsattar_implementing-cicd-for-your-web-application-activity-7152670931243446274-fIw0?utm_source=share&utm_medium=member_desktop

## IBM and Meta offering Web Development Courses for everyone.🚀🚀

Repost so that all can take benifits

𝐈𝐁𝐌 𝐖𝐞𝐛 𝐃𝐞𝐯𝐞𝐥𝐨𝐩𝐦𝐞𝐧𝐭 𝐂𝐨𝐮𝐫𝐬𝐞𝐬

👉 https://lnkd.in/dKYZ_F9i

1. IBM Full Stack Software Developer Professional Certificate
👉 https://lnkd.in/dADYt4Wz

2. Introduction to Web Development with HTML, CSS, JavaScript
👉 https://lnkd.in/dgs9bQ-6

3. IBM Front-End Developer Professional Certificate
👉 https://lnkd.in/dmP3PDaU

4. IBM Back-End Development Professional Certificate
👉 https://lnkd.in/dfkdxEEr

5. IBM Python for Data Science, AI & Development
👉 https://lnkd.in/dwVbZt7b

6. IBM Developing Cloud Apps with Node.js and React
👉 https://lnkd.in/dSqJck7A

𝐌𝐞𝐭𝐚 𝐖𝐞𝐛 𝐃𝐞𝐯𝐞𝐥𝐨𝐩𝐦𝐞𝐧𝐭 𝐂𝐨𝐮𝐫𝐬𝐞𝐬

1. Meta Front-End Developer Professional Certificate
👉https://lnkd.in/dE7FKwMp

2. Meta React Native Specialization
👉 https://lnkd.in/dXCs5ewA

3. Introduction to Front-End Development
👉 https://lnkd.in/dxmyJ2iw

4. Meta HTML and CSS in depth
👉 https://lnkd.in/dwyWkpqK

5. Advanced React
👉 https://lnkd.in/dBaF8Krj

6. HTML, CSS, and Javascript for Web Developers
👉 https://lnkd.in/d3Zm2h3P

7. Web Design for Everybody: Basics of Web Development & Coding Specialization
👉 https://lnkd.in/dudsqPYK

8. Introduction to Web Development
👉 https://lnkd.in/drdy75ig

9. Responsive Website Development and Design Specialization
👉 https://lnkd.in/dn425Hps

10. Full Stack Web Development en Español Specialization
👉 https://lnkd.in/dPQ92M4u

11. Web Applications for Everybody Specialization
👉 https://lnkd.in/dt_HS7Pm

## How DNS Works - A Simplified Overview
[1] User Types a URL:
A user enters a website's URL (Uniform Resource Locator) into their browser.
[2] Browser Contacts DNS Resolver:
The browser checks its local DNS resolver (usually provided by the internet service provider) to find the IP address associated with the entered domain.
[3] DNS Resolver Searches Cache:
The DNS resolver checks its cache for a previously resolved IP address for the requested domain. If found, the process skips to the next step.
[4] Recursive DNS Query:
If the resolver doesn't have the IP address, it starts a recursive query. It contacts the root DNS server, asking for information about the top-level domain (TLD) of the requested site.
[5] Root DNS Server Response:
The root DNS server responds with the TLD DNS server's address.
[6] TLD DNS Server Inquiry:
The resolver contacts the TLD DNS server, asking for information about the authoritative DNS server for the specific domain.
[7] Authoritative DNS Server Contact:
The TLD DNS server responds with the IP address of the authoritative DNS server for the domain.
[8] Domain's Authoritative DNS Server Response:
The resolver contacts the authoritative DNS server, requesting the IP address associated with the domain.
[9] Authoritative DNS Server Provides IP:
The authoritative DNS server responds with the IP address of the requested domain.
[10] DNS Resolver Caches IP:
The DNS resolver caches the obtained IP address for future use and sends it to the user's browser.
[11] Browser Connects to IP Address:
The browser uses the obtained IP address to connect to the web server hosting the requested website.

![1705680493626](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/3b64d226-cf65-481b-bcea-3cfb65a0bba3)


## Insights into SSL Certificate Workflow:
ClientHello:
The client initiates the SSL/TLS handshake by sending a "ClientHello" message to the server, indicating its intent to establish a secure connection.

ServerHello and Certificate Exchange:
The server responds with a "ServerHello" message, selecting a cipher suite for secure communication. It then presents its SSL certificate to the client, initiating the certificate exchange.

Trust Verification and Key Exchange:
The client verifies the certificate's authenticity by checking its digital signature against trusted CAs. Simultaneously, both parties engage in a key exchange, using public-key cryptography to establish a shared secret key.

Pre-master Secret and Session Keys:
The client generates a pre-master secret, encrypts it with the server's public key, and sends it back. Both client and server independently derive session keys from the pre-master secret, ensuring secure communication.

Finished:
Both parties exchange "Finished" messages, confirming that the handshake is complete. From this point onward, the established session keys encrypt and decrypt data, securing the communication channel.

![1705331828985](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/f56f48e4-6104-4899-80a7-d2e6c30ca12c)

## Sorting algorithms 
Sorting algorithms are fundamental techniques in computer science and are used to rearrange elements in a specified order. The efficiency of sorting algorithms is often evaluated based on factors like time complexity, space complexity, and stability.
✅Bubble Sort:
🔶 Description: Bubble sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.
🔶 Time Complexity: O(n^2) in the worst and average case, O(n) in the best case (when the list is already sorted).
🔶 Space Complexity: O(1) (in-place algorithm).
✅ Selection Sort:
🔶 Description: Selection sort divides the input into a sorted and an unsorted region. It repeatedly selects the smallest (or largest, depending on the order) element from the unsorted region and moves it to the sorted region.
🔶 Time Complexity: O(n^2) regardless of input.
🔶 Space Complexity: O(1) (in-place algorithm).
✅ Insertion Sort:
🔶 Description: Insertion sort builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.
🔶 Time Complexity: O(n^2) in the worst and average case, O(n) in the best case.
🔶 Space Complexity: O(1) (in-place algorithm).
✅ Merge Sort:
🔶 Description: Merge sort is a divide-and-conquer algorithm that divides the input array into two halves, recursively sorts them, and then merges the sorted halves.
🔶 Time Complexity: O(n log n) in all cases.
🔶 Space Complexity: O(n) additional space is required for the merging process.
✅ Quick Sort:
🔶 Description: Quick sort is another divide-and-conquer algorithm that partitions the array into two parts, with elements less than a chosen pivot on one side and elements greater on the other. The process is applied recursively to the two sub-arrays.
🔶 Time Complexity: O(n^2) in the worst case, O(n log n) on average.
🔶 Space Complexity: O(log n) on average for the recursive call stack.
✅ Heap Sort:
🔶 Description: Heap sort is based on the binary heap data structure. It first builds a max heap from the input array and repeatedly extracts the maximum element, ensuring that the remaining elements form a valid heap.
🔶 Time Complexity: O(n log n) in all cases.
🔶 Space Complexity: O(1) (in-place algorithm).
Sorting algorithms are chosen based on the specific requirements of the application and the characteristics of the data to be sorted. Different algorithms may be more suitable for different scenarios, depending on factors such as data size, stability, and memory constraints.

![1705509378264](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/a280c10d-a4b6-48eb-a070-19616b9527a3)

## Log Parsing Cheat Sheet

The diagram below lists the 𝘁𝗼𝗽 𝟲 𝗹𝗼𝗴 𝗽𝗮𝗿𝘀𝗶𝗻𝗴 𝗰𝗼𝗺𝗺𝗮𝗻𝗱𝘀.

1. GREP

GREP searches any given input files, selecting lines that match one or more patterns.

2. CUT

CUT cuts out selected portions of each line from each file and writes them to the standard output.

3. SED

SED reads the specified files, modifying the input as specified by a list of commands.

4. AWK

AWK scans each input file for lines that match any of a set of patterns.

5. SORT

SORT sorts text and binary files by lines.

6. UNIQ

UNIQ reads the specified input file comparing adjacent lines and writes a copy of each unique input line to the output file.

𝗟𝗲𝘁’𝘀 𝘄𝗮𝗹𝗸 𝘁𝗵𝗿𝗼𝘂𝗴𝗵 𝗮𝗻 𝗲𝘅𝗮𝗺𝗽𝗹𝗲.

To count the number of hits from the top 10 IP addresses requesting the path "/api/payments" from the access log in this common log format:

216.67.1.91 - leon [01/Jul/2002:12:11:52 +0000] "GET /index.html HTTP/1.1" 200 431

We can use a combination of grep, cut, sort, and uniq commands. 𝗛𝗲𝗿𝗲 𝗶𝘀 𝗮 𝘀𝗮𝗺𝗽𝗹𝗲 𝗰𝗼𝗺𝗺𝗮𝗻𝗱:

grep '/api/payments' access.log | cut -d ' ' -f 1 | sort | uniq -c | sort -rn | head -10

Here's what each part of the command does:

- grep '/api/payments' access.log: This filters the lines containing "/api/payments" from the access.log file.

- cut -d ' ' -f 1: This extracts the first field (the IP address) from each line. The -d ' ' option specifies space as the field delimiter.

- sort: This sorts the IP addresses.

- uniq -c: This removes duplicate lines and prefixes lines by the number of occurrences.

- sort -rn: This sorts the lines in reverse order (highest first) numerically.

- head -10: This shows only the first 10 lines of the output, which correspond to the top 10 IP addresses.

Over to you: Please share your top log parsing tips and tricks.

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/2a93fe91-df1d-4f08-8beb-39ad5c9f36f8)

## 𝐇𝐨𝐰 𝐝𝐨 𝐩𝐫𝐨𝐭𝐨𝐜𝐨𝐥𝐬 𝐰𝐨𝐫𝐤 𝐢𝐧 𝐭𝐡𝐞 𝐓𝐂𝐏/𝐈𝐏 𝐨𝐫 𝐎𝐒𝐈 𝐌𝐨𝐝𝐞𝐥❓
The TCP/IP and OSI models are frameworks that describe how data is transmitted over a network.

𝐓𝐂𝐏/𝐈𝐏 𝐌𝐨𝐝𝐞𝐥:
The TCP/IP model is simpler, with four layers:

Link Layer (Network Interface Layer):

Manages the physical transmission of data over a network. Converts binary data from the Transport Layer into network frames, preparing them for physical transmission over the network.

Components: Network interface cards (NICs), Ethernet, and protocols like ARP (Address 
Resolution Protocol).

Internet Layer (Network Layer):

Handles the logical transmission of data across the network. Determines the best path for data packets to travel across networks using IP addresses.

Components: Routers and protocols like IP (Internet Protocol), ICMP (Internet Control Message Protocol).

Transport Layer:

Manages end-to-end communication between hosts. Ensures data is sent and received in order, without errors. TCP provides reliable communication, while UDP offers faster, but less reliable, transfer.

Components: Protocols like TCP (Transmission Control Protocol) and UDP (User Datagram Protocol).

Application Layer:

Provides protocols for specific user applications. This layer is where user applications interact with the network stack, using protocols suited to different types of data and services.

Components: Protocols like HTTP (Hypertext Transfer Protocol), SMTP (Simple Mail Transfer Protocol).

𝐎𝐒𝐈 𝐌𝐨𝐝𝐞𝐥:
The OSI model is more detailed, with seven layers:

Physical Layer:

Transmits raw bit stream over the physical medium.Manages the physical connection between devices.

Components: Cables, switches, and the physical aspects of the network.

Data Link Layer:

Ensures error-free transmission over the physical layer. Frames data packets, handles error detection and correction.

Components: Bridges, switches, and protocols like Ethernet.

Network Layer:

Manages device addressing and path determination. Routes data across multiple networks.

Components: Routers, and protocols like IP.

Transport Layer:

Similar to the TCP/IP model, it manages end-to-end communication and data integrity.

Session Layer:

Manages sessions between applications.Establishes, manages, and terminates sessions.

Components: APIs and services that enable communication between machines.

Presentation Layer:

Translates data between the application layer and the network. Ensures that data is in the correct format for the application layer.

Components: Encryption, compression, and translation services.

Application Layer:

Similar to the TCP/IP model, interfaces directly with user applications.

The TCP/IP model is more practical and aligned with real-world networking.
In practice, TCP/IP’s Application Layer encompasses OSI's Application, Presentation, and Session layers.

![1704805635565](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/8b68fccf-46ed-4894-9273-5eff8c342ac2)


## Java Exceptions
You would agree that Exception handling is a critical aspect of a Java Application.

Let's refresh some basic tips on handling exceptions -

[*] Catch with Precision
- Catch specific exceptions rather than generic ones like Exception.
- This allows you to handle each exception type differently and provide tailored solutions.

try {
 // Code that may throw specific exceptions
} catch (FileNotFoundException e) {
 // Handle file not found exception
} catch (IOException e) {
 // Handle IO exception
}


[*] Graceful Error Handling
- When an exception strikes, don't leave your users in the dark!
- Provide meaningful error messages or logs to facilitate troubleshooting and enhance the user experience.

try {
 // Code that may throw an exception
} catch (Exception e) {
 logger.error("An error occurred: " + e.getMessage());
 // Provide meaningful error message to aid in troubleshooting
}


[*] Resource Cleanup with Finesse
- Use the 'finally' block only to release system resources like file handles, database connections, or network connections.

try (FileInputStream fileInputStream = new FileInputStream("file.txt")) {
 // Code
} catch (IOException e) {
 // Handle exception 
} finally {
 // Cleanup: The file input stream will be closed automatically
}


[*] Rethrow Strategically
- Consider whether to re-throw an exception or wrap it in a new one. 
- Rethrowing can be useful for propagating errors, but remember to provide valuable context for smooth debugging.

try {
 // Code that may throw an exception
} catch (IOException e) {
 logger.error("An error occurred: " + e.getMessage());
 throw new CustomException("An error occurred while processing the data.", e);
 // Rethrow the exception while providing additional context
}


[*] Mindful Checked Exceptions
- Choose checked exceptions wisely. Excessive use can clutter code and make it harder to maintain.
- Opt for unchecked exceptions or custom types when they fit the bill.

public void readFile() throws IOException {
 // Code that may throw IOException
}


[*] Embrace the Power of 'try-with-resources':
- For automatic resource management, leverage the elegance of the try-with-resources statement.
- It ensures proper resource closure and minimizes leaks.

try (Connection connection = DriverManager.getConnection(url, username, password);
 Statement statement = connection.createStatement()) {
 // Code that uses the connection and statement
} catch (SQLException e) {
 // Handle any exceptions that occur
}


[*] Ignoring is Not an Option
- Avoid turning a blind eye to exceptions!
  
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/17d4f67f-9115-4b3a-8af0-193d321eaaf2)

## 𝗢𝗽𝘁𝗶𝗺𝗶𝘀𝗲 𝗬𝗼𝘂𝗿 𝗗𝗼𝗰𝗸𝗲𝗿 𝗪𝗼𝗿𝗸𝗳𝗹𝗼𝘄 🚀💻

Supercharge your Docker skills with these key commands:

𝟭. 𝗿𝘂𝗻: Launch containers from images.
𝟮. 𝘀𝘁𝗼𝗽: Gracefully halt running containers.
𝟯. 𝘀𝘁𝗮𝗿𝘁: Revitalize stopped containers.
𝟰. 𝗲𝘅𝗲𝗰: Execute commands within containers.
𝟱. 𝗽𝗼𝗿𝘁: Identify a container's public-facing port.
𝟲. 𝗿𝗲𝗻𝗮𝗺𝗲: Give containers new identities.
𝟳. 𝗽𝗮𝘂𝘀𝗲/𝘂𝗻𝗽𝗮𝘂𝘀𝗲: Suspend/resume container processes.
𝟴. 𝗸𝗶𝗹𝗹: Halt running containers.
𝟵. 𝗯𝘂𝗶𝗹𝗱: Create custom Docker images.
𝟭𝟬. 𝘁𝗼𝗽: Display running processes of a container.
𝟭𝟭. 𝗰𝗽: Copy files between containers and local system.
𝟭𝟮. 𝗿𝗺: Remove stopped containers.
𝟭𝟯. 𝘀𝘁𝗮𝘁𝘀: Monitor real-time container resource usage.
𝟭𝟰. 𝗽𝘀: View container processes.
𝟭𝟱. 𝗵𝗶𝘀𝘁𝗼𝗿𝘆: View image evolution history.
𝟭𝟲. 𝗶𝗺𝗮𝗴𝗲 𝗹𝘀: List available Docker images.
𝟭𝟳. 𝗹𝗼𝗴𝘀: Retrieve and analyze container logs.
𝟭𝟴. 𝘃𝗲𝗿𝘀𝗶𝗼𝗻: Check Docker version.
𝟭𝟵. 𝗶𝗻𝗳𝗼: Fetch crucial Docker system information.
𝟮𝟬. 𝗶𝗻𝘀𝗽𝗲𝗰𝘁: Explore details of containers, images, networks.


![1704294993746](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/3bc5086b-9037-4dee-866d-00c8b6550199)


## Forget web developers/Web Designer
Here is the list of 8 AI tool that creates your website in 5 min:

1 10Web.io

It helps users to build or recreate any website with AI in minutes.

2 Dora

Design and publish stunning 3D & animated websites effortlessly, without the need for coding.

3 Durable

Build a website in 30 secs using AI .

4 Bookmark

Get your business online in a minute

5 Framer

It is an amazing tool that makes it possible to create a website in less than two minutes.

6 sitekickai

It allows you to create beautiful landing pages. Without the need for coding, design or copywriting skills.

7 Makelanding AI

Make a beautiful landing page in seconds .

8 Createwebsite

It is not just about creating websites, it's about creating powerful, lightning-fast digital experiences.

## Session, Cookie, JWT, Token, SSO, and OAuth 2.0 Explained in One Diagram
When you login to a website, your identity needs to be managed. Here is how different solutions work:

- Session - The server stores your identity and gives the browser a session ID cookie. This allows the server to track login state. But cookies don't work well across devices.

- Token - Your identity is encoded into a token sent to the browser. The browser sends this token on future requests for authentication. No server session storage is required. But tokens need encryption/decryption.

- JWT - JSON Web Tokens standardize identity tokens using digital signatures for trust. The signature is contained in the token so no server session is needed.

- SSO - Single Sign On uses a central authentication service. This allows a single login to work across multiple sites.

- OAuth2 - Allows limited access to your data on one site by another site, without giving away passwords.

Over to you: QR code logins are gaining popularity. Do you know how it works?


![1703745073045](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/9dadf720-9f36-4b29-9994-6ff234da87d9)


## Top 12 Tips for API Security
- Use HTTPS
- Use OAuth2
- Use WebAuthn
- Use Leveled API Keys
- Authorization
- Rate Limiting
- API Versioning
- Whitelisting
- Check OWASP API Security Risks
- Use API Gateway
- Error Handling
- Input Validation

![1703833728966](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/1766c0c9-f242-4668-8754-227cba85cc0a)

## 𝗦𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝘃𝘀. 𝗔𝘀𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝗘𝗻𝗰𝗿𝘆𝗽𝘁𝗶𝗼𝗻 𝗘𝘅𝗽𝗹𝗮𝗶𝗻𝗲𝗱 🔒
Whether you're a cybersecurity enthusiast, a developer, or someone curious about securing digital communication, understanding these encryption methods is necessary.

Let's delve into the key distinctions:

𝗦𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝗘𝗻𝗰𝗿𝘆𝗽𝘁𝗶𝗼𝗻:
- Description: Symmetric encryption employs a single, shared key for both encryption and decryption.
- Use Case: Ideal for scenarios where a secure channel already exists for key exchange.

𝗔𝘀𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝗘𝗻𝗰𝗿𝘆𝗽𝘁𝗶𝗼𝗻:
- Description: Asymmetric encryption uses a pair of keys, public and private, for encryption and decryption.
- Use Case: Suitable for secure communication over untrusted networks, eliminating the need for a shared secret.

𝗞𝗲𝘆 𝗗𝗶𝗳𝗳𝗲𝗿𝗲𝗻𝗰𝗲𝘀: 𝗦𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝘃𝘀. 𝗔𝘀𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰

𝟭. 𝗞𝗲𝘆 𝗠𝗮𝗻𝗮𝗴𝗲𝗺𝗲𝗻𝘁:
- Symmetric: Requires secure key distribution mechanisms.
- Asymmetric: Public keys can be openly shared, while private keys are closely guarded.

𝟮. 𝗖𝗼𝗺𝗽𝘂𝘁𝗮𝘁𝗶𝗼𝗻𝗮𝗹 𝗖𝗼𝗺𝗽𝗹𝗲𝘅𝗶𝘁𝘆:
- Symmetric: Generally faster and less computationally intensive.
- Asymmetric: Slower due to complex mathematical operations.

𝟯. 𝗦𝗰𝗮𝗹𝗮𝗯𝗶𝗹𝗶𝘁𝘆:
- Symmetric: Efficient for large-scale data encryption.
- Asymmetric: More resource-intensive, especially for bulk data.

𝟰. 𝗨𝘀𝗲 𝗖𝗮𝘀𝗲𝘀:
- Symmetric: Secure, established channels, and resource-constrained environments.
- Asymmetric: Secure communication over untrusted networks, digital signatures, and key exchange.

𝗥𝗲𝗮𝗹-𝗪𝗼𝗿𝗹𝗱 𝗔𝗽𝗽𝗹𝗶𝗰𝗮𝘁𝗶𝗼𝗻𝘀:

𝟭. 𝗦𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝗘𝗻𝗰𝗿𝘆𝗽𝘁𝗶𝗼𝗻 𝗶𝗻 𝗣𝗿𝗮𝗰𝘁𝗶𝗰𝗲:
- Utilized in HTTPS/TLS for securing web traffic.
- Commonly applied in VPNs for secure communication between network devices.

𝟮. 𝗔𝘀𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝗘𝗻𝗰𝗿𝘆𝗽𝘁𝗶𝗼𝗻 𝗶𝗻 𝗣𝗿𝗮𝗰𝘁𝗶𝗰𝗲:
- Facilitates secure email communication through digital signatures.
- Forms the basis for secure communication in blockchain technology.

𝗖𝗵𝗼𝗼𝘀𝗶𝗻𝗴 𝘁𝗵𝗲 𝗥𝗶𝗴𝗵𝘁 𝗘𝗻𝗰𝗿𝘆𝗽𝘁𝗶𝗼𝗻 𝗦𝘁𝗿𝗮𝘁𝗲𝗴𝘆:

- Data Sensitivity: Assess the level of sensitivity of your data and communication.
- Resource Constraints: Consider the computational resources available for encryption and decryption.
- Key Distribution: Evaluate the feasibility of securely distributing and managing encryption keys.


![1703426416669](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/0c21005f-ee3e-4f07-abcd-2c52fe63e926)


## Key Concepts to Understand Database Sharding
Database sharding refers to splitting data across multiple database servers and is commonly used for scaling. However, sharding introduces major operational and infrastructure complexity that should be 𝗮𝘃𝗼𝗶𝗱𝗲𝗱 𝘂𝗻𝗹𝗲𝘀𝘀 𝗮𝗯𝘀𝗼𝗹𝘂𝘁𝗲𝗹𝘆 𝗻𝗲𝗰𝗲𝘀𝘀𝗮𝗿𝘆.

𝗔𝗽𝗽𝗿𝗼𝗮𝗰𝗵𝗲𝘀 𝘁𝗼 𝗽𝗼𝘀𝘁𝗽𝗼𝗻𝗲 𝘀𝗵𝗮𝗿𝗱𝗶𝗻𝗴

Vertical Scaling: Use more powerful single database servers - more CPUs, memory, storage and I/O bandwidth. Much simpler to manage than sharding while allowing sizable expansion.

SQL Optimization: Tune SQL queries and database schema to maximize performance on a single server. Requires proper indexes, efficient SQL, etc.

Caching: Use in-memory caches like Redis to reduce database load by avoiding hitting it for every common query.

Read Replicas + Load Balancer: Adds horizontal read scaleability without full complexity of sharding. Directs reads across replicas.

These optimization approaches should be 𝗲𝘅𝗵𝗮𝘂𝘀𝘁𝗲𝗱 𝗯𝗲𝗳𝗼𝗿𝗲 𝘀𝗵𝗮𝗿𝗱𝗶𝗻𝗴 𝗴𝗶𝘃𝗲𝗻 𝘁𝗵𝗲 𝗰𝗼𝗺𝗽𝗹𝗲𝘅𝗶𝘁𝘆.

𝗛𝗼𝗿𝗶𝘇𝗼𝗻𝘁𝗮𝗹 𝘃𝘀 𝗩𝗲𝗿𝘁𝗶𝗰𝗮𝗹 𝗦𝗵𝗮𝗿𝗱𝗶𝗻𝗴

There are two high-level approaches:

Vertical Sharding: Split database into columnar tables or sections vs rows. For example, having one table for names and another table for emails.

Horizontal Sharding: Split database into row partitions distributed evenly across multiple servers.

Some horizontal sharding methods:

1. 𝗥𝗮𝗻𝗴𝗲 𝗕𝗮𝘀𝗲𝗱: Segment rows based on range values like age groups. Can cause uneven data distribution and hot spots.

2. 𝗗𝗶𝗿𝗲𝗰𝘁𝗼𝗿𝘆 𝗕𝗮𝘀𝗲𝗱: Use a lookup directory to locate rows. Allows flexibility but single point of failure risk.

3. 𝗛𝗮𝘀𝗵 𝗕𝗮𝘀𝗲𝗱: Apply hash functions to spread rows uniformly across shards. Harder to rebalance.

When sharding, use the simplest approach that meets requirements to minimize complexity. Seek to avoid until necessary.

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/08d0d9f4-ca4f-4d82-8946-c85ce05ebafc)

## Logging, tracing and metrics are 3 pillars of system observability. 
The diagram below shows their definitions and typical architectures.

🔹 Logging
Logging records discrete events in the system. For example, we can record an incoming request or a visit to databases as events. It has the highest volume. ELK (Elastic-Logstash-Kibana) stack is often used to build a log analysis platform. We often define a standardized logging format for different teams to implement, so that we can leverage keywords when searching among massive amounts of logs.

🔹 Tracing
Tracing is usually request-scoped. For example, a user request goes through the API gateway, load balancer, service A, service B, and database, which can be visualized in the tracing systems. This is useful when we are trying to identify the bottlenecks in the system. We use OpenTelemetry to showcase the typical architecture, which unifies the 3 pillars in a single framework.

🔹 Metrics
Metrics are usually aggregatable information from the system. For example, service QPS, API responsiveness, service latency, etc. The raw data is recorded in time-series databases like InfluxDB. Prometheus pulls the data and transforms the data based on pre-defined alerting rules. Then the data is sent to Grafana for display or to the alert manager which then sends out email, SMS, or Slack notifications or alerts.

![1703782033069](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/b5f3d648-cbe6-491d-88c2-8d9df3c4acc7)


## How SSO/SAML works!

AssumeRole: Easily switch roles within your AWS account or between accounts for straightforward permission management.

AssumeRoleWithSAML: Use SAML (a secure standard) to get credentials for users, making sure only the right people have access.

AssumeRoleWithWebIdentity: For users signing in via Amazon Cognito, Google, or Facebook, AWS suggests using Cognito for a hassle-free login.

GetSessionToken: Boost security by adding Multi-Factor Authentication (MFA) for users or the main AWS account holder.

GetFederationToken: Great for apps acting on behalf of users, this gives temporary access to those who need it, keeping things flexible yet secure.

Identity Federation in AWS: This lets you extend AWS access to users outside of AWS, without having to individually manage each user. It's great for organizations that already have their own identity systems (like Active Directory) or for apps that need to use AWS resources.

Key features include:

SAML 2.0 Integration: Works smoothly with well-known identity providers, granting temporary access to AWS services.

Custom Identity Broker: A solution for when your identity provider isn't SAML-compatible, managing authentication and AWS access.

Learn more about how SAML and AWS federation can simplify your access management, keeping your AWS resources secure and easily manageable. Dive into the world of AWS Identity Federation and unlock the full potential of your AWS resources!

![1703302178016](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/2c27d8c9-811b-4100-8b11-a2c68ce2e0b1)

## 
