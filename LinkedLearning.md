# LinkedIn Learning

# Table of contents

- [LinkedIn Learning](#linkedin-learning)
  - [𝗠𝗮𝘀𝘁𝗲𝗿𝗶𝗻𝗴 𝗗𝗲𝘃𝗢𝗽𝘀: 𝗔 𝗩𝗶𝘀𝘂𝗮𝗹 𝗚𝘂𝗶𝗱𝗲](#----)
  - [Hospital Managment SpringBoot APP](#hospital-managment-springboot-app)
  - [List of common annotations/methods used with Spring boot testing 🔥](#list-of-common-annotationsmethods-used-with-spring-boot-testing-)
  - [Companies List that are HIRING for 100% REMOTE.](#companies-list-that-are-hiring-for-100-remote)
  - [Scrum](#scrum)
  - [24 repos you can't miss out as a software engineer:](#24-repos-you-cant-miss-out-as-a-software-engineer)
    - [Interview preparation:](#interview-preparation)
    - [System design:](#system-design)
    - [LLM/AI:](#llmai)
    - [Complete roadmaps:](#complete-roadmaps)
    - [Frontend:](#frontend)
  - [Choosing the right database for your needs? Consider these points:](#choosing-the-right-database-for-your-needs-consider-these-points)
  - [6 Must Know Software Architectural Patterns](#6-must-know-software-architectural-patterns)
  - [Core Components of System Architecture](#core-components-of-system-architecture)
  - [𝐇𝐨𝐰 𝐑𝐄𝐒𝐓 𝐀𝐏𝐈 𝐰𝐨𝐫𝐤?](#---)
  - [Single Sign-On (SSO) explained in simple terms.](#single-sign-on-sso-explained-in-simple-terms)
    - [𝗞𝗲𝘆 𝗣𝗹𝗮𝘆𝗲𝗿𝘀 𝗶𝗻 𝗦𝗦𝗢](#---)
    - [𝗕𝗲𝗻𝗲𝗳𝗶𝘁𝘀 𝗼𝗳 𝗦𝗦𝗢](#--)
    - [𝗛𝗼𝘄 𝗦𝗦𝗢 𝗪𝗼𝗿𝗸𝘀](#--)
  - [ChatGPT Mastery Cheat Sheet](#chatgpt-mastery-cheat-sheet)
  - [Hands-On Guide: Implementing CI/CD for your web application with AWS Codepipeline](#hands-on-guide-implementing-cicd-for-your-web-application-with-aws-codepipeline)
  - [IBM and Meta offering Web Development Courses for everyone.🚀🚀](#ibm-and-meta-offering-web-development-courses-for-everyone)
  - [How DNS Works - A Simplified Overview](#how-dns-works---a-simplified-overview)
  - [Insights into SSL Certificate Workflow:](#insights-into-ssl-certificate-workflow)
  - [Sorting algorithms](#sorting-algorithms)
  - [Log Parsing Cheat Sheet](#log-parsing-cheat-sheet)
  - [𝐇𝐨𝐰 𝐝𝐨 𝐩𝐫𝐨𝐭𝐨𝐜𝐨𝐥𝐬 𝐰𝐨𝐫𝐤 𝐢𝐧 𝐭𝐡𝐞 𝐓𝐂𝐏/𝐈𝐏 𝐨𝐫 𝐎𝐒𝐈 𝐌𝐨𝐝𝐞𝐥❓](#---------)
  - [Java Exceptions](#java-exceptions)
  - [𝗢𝗽𝘁𝗶𝗺𝗶𝘀𝗲 𝗬𝗼𝘂𝗿 𝗗𝗼𝗰𝗸𝗲𝗿 𝗪𝗼𝗿𝗸𝗳𝗹𝗼𝘄 🚀💻](#----)
  - [Forget web developers/Web Designer](#forget-web-developersweb-designer)
  - [Session, Cookie, JWT, Token, SSO, and OAuth 2.0 Explained in One Diagram](#session-cookie-jwt-token-sso-and-oauth-20-explained-in-one-diagram)
  - [Top 12 Tips for API Security](#top-12-tips-for-api-security)
  - [](#)
  - 
## 𝗠𝗮𝘀𝘁𝗲𝗿𝗶𝗻𝗴 𝗗𝗲𝘃𝗢𝗽𝘀: 𝗔 𝗩𝗶𝘀𝘂𝗮𝗹 𝗚𝘂𝗶𝗱𝗲
![1706844743207](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/0f083413-adab-46d8-a0c4-0f0a4c469694)

## Hospital Managment SpringBoot APP
- Hospital Management API built in Spring Boot
- https://github.com/MirnaGama/hospital-management-api

## List of common annotations/methods used with Spring boot testing 🔥
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/a174cbf6-fe9d-49ca-bb92-d18d2e19724d)

## Companies List that are HIRING for 100% REMOTE.

1. Quest Software - https://lnkd.in/gqaB5RTN
2. Upstart - https://lnkd.in/g3sXD8DZ
3. Celigo - https://lnkd.in/gKhSMxNY (US & India)
4. Cengage Group - https://lnkd.in/gGkT6jRZ
5. Docker, Inc - https://lnkd.in/gfX5-pQG
6. hims & hers - https://lnkd.in/gr_SdVdE
7. UserGems 💎 Interviews - https://lnkd.in/gXi3mNf6
8. Abnormal Security - https://lnkd.in/gn5M4VDF
9. Cash App - https://lnkd.in/gdp8yUm8
10. LogicGate - https://lnkd.in/gjgX27Bc
11. Faire - https://lnkd.in/gYRNr9VM
12. Renaissance Learning - https://lnkd.in/gesiM_Dw
13. Rec Room - https://lnkd.in/gErDuTNa
14. VGS (Very Good Security) - https://lnkd.in/g7Ajb77F
15. VAST Data - https://lnkd.in/gMUFt4y9
16. Sorcero - https://lnkd.in/gpmDTnH7
17. McGraw Hill - https://lnkd.in/g59pzFf4
18. Patreon - https://lnkd.in/gzQptMcQ (NY/San Francisco)
19. Beekeeper - https://lnkd.in/gxd7rs7Q (Senior PMM)
20. Upwork - https://lnkd.in/gt4HYmd6
21. DocuSign - https://lnkd.in/ggfUncZf
22. DealHub.io - https://lnkd.in/gyNED4yp
23. Census - https://lnkd.in/gAq7PGzc
24. Intrado - https://lnkd.in/gH3wuNWZ
25. Cloudflare - https://lnkd.in/g9JPXp2F
26. Funded.club - https://lnkd.in/gpH4FazA
27. Workiva - https://lnkd.in/g-FUYYdR
28. MissionWired - https://lnkd.in/gMA6AVdG
29. Workera - https://lnkd.in/g2YzZu-H
30. Jenius Bank - https://lnkd.in/gxGqHGkH

## Scrum

![1706495418935](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/9b3c8b1f-8318-4eca-86c4-17645650dc25)

## 24 repos you can't miss out as a software engineer:

### Interview preparation:

1. Tech Interview Handbook: https://lnkd.in/d2F5z4Af (by Yangshun Tay)

2. Guide to software engineering interviews: https://lnkd.in/dm2MbsgD (by Kevin Naughton)

3. Devops exercises: https://lnkd.in/dPCDT55k

### System design:

4. Big Tech engineering tech blogs: https://lnkd.in/dJaGjeES

5. System Design 101: https://lnkd.in/d5itZHgQ (by Alex Xu)

6. System design primer: https://lnkd.in/dkPScaCW (by Donne Martin)

7. Essential JS design patterns: https://lnkd.in/dWmBwK-i (by Addy Osmani)

8. Awesome scalability: https://lnkd.in/de4UZbiA

9. Awesome System Design Resources: https://lnkd.in/dU6wFXkn (by Ashish Pratap Singh)

10. Coding Challenges solutions: https://lnkd.in/dJV_8pgH (by John Crickett)

### LLM/AI:

11. Hands on LLM: https://lnkd.in/dww8GPdt (by Paul Iusztin)

12. Papers we love: https://lnkd.in/dkjsCq8z

13. Notes on AI for software engineers: https://lnkd.in/dANSnC4f

14. LLM 101 course: https://lnkd.in/dVKwvVUR (by Maxime Labonne)

15. ML paper of the week: https://lnkd.in/d66HxP52 (by Elvis S.)

### Complete roadmaps:

16. Path to senior engineer handbook: https://lnkd.in/dC3dQvy6 (by Jordan Cutler)

17. 100+ Resources to become a great Engineering leader: https://lnkd.in/dFwV2GMv (by Gregor Ojstersek)

18. DevOps roadmap in 2024: https://lnkd.in/ddE5DkDJ (by Dr Milan Milanović)

19. The Book of Secret Knowledge: https://lnkd.in/d69jrK4T

20. Free programming books: https://lnkd.in/d5JCRakw

21. The ultimate developer roadmap: https://lnkd.in/dsCJgDnS (by Kamran Ahmed)

### Frontend:

22. CSS for JS dev notes: https://lnkd.in/dCNavrNv (by Tiger Abrodi)

23. Javascript Questions: https://lnkd.in/dt_96xJZ (by Lydia Hallie)

24. Typescript advanced patterns workshop: https://lnkd.in/deTBDhCb (by Matt Pocock)

If you liked this, you'll love Hungry Minds, my free weekly newsletter curating the best deep dives, trends and tools to grow as a software engineer: https://hungryminds.dev

## Choosing the right database for your needs? Consider these points:
1 ACID Transactions (OLTP): RDS, Aurora, Azure SQL Database

2 Relational (Cloud Agnostic): SQL Server, Oracle, Cockroach, MySQL, PostgreSQL

3 Analytics (OLAP) Columnar: RedShift, Azure Synapse, Snowflake, BigQuery, Databricks, HIVE

4 Memory-store In-memory: Redis, Memcached, Hazelcast, Ignite

5 Key-Value: Redis, DynamoDB, CosmosDB, BigTable, RocksDB, Ignite

6 Wide Column Data Type: HBase, Cassandra, ScyllaDB

7 Semi-Structured: CosmosDB, BigTable, BigQuery, HBase, Cassandra

8 Time Series: CosmosDB, BigTable, BigQuery, TimescaleDB, OpenTSDB, InfluxDB

9 Graph: Neptune, CosmosDB, JanusGraph, Table Graph, Solr, PostGIS, MongoDB (GeoJSON), OrientDB, Neo4J, Tiger Graph
10 Document: CosmosDB, Firestore, MongoDB, Couchbase

11 Full Text Search: Cloud-Search, Cognitive Search, Elastic-Search, Solr, Elassandra

12 Unstructured (Rich) Text: S3, Blob Storage, Cloud Storage, HDFS, Blob

![1706096041699](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/86629c73-2387-4d2c-95c7-b3de74c11843)

## 6 Must Know Software Architectural Patterns
1 - Event-Driven Architecture
Decoupled Components and Asynchronous Communication.
Application: Ideal for systems where events trigger actions, fostering scalability and responsiveness.

2 - Layered Architecture
Hierarchical Structure with Distinct Layers (Presentation, Business Logic, Data).
Application: Common in enterprise applications, enhancing maintainability through compartmentalization and modular development.

3 - Monolithic Architecture
Unified Codebase and Deployment Unit.
Application: Suited for smaller applications or simplicity-focused instances. Streamlines development and deployment with potential scaling challenges.

4 - Microservices Architecture
Distributed System with Independent, Interoperable Services.
Application: Ideal for large and intricate systems, improving scalability, fault isolation, and enabling independent service development.

5 - Model-View-Controller (MVC)
Segregation of Concerns into Model, View, and Controller Components.
Application: Common in web applications, enhancing code organization and maintenance by separating complex UI logic.

6 - Master-Slave Architecture
Centralized Control (Master) with Multiple Worker Nodes (Slaves).
Application: Ubiquitous in distributed computing, optimizing parallel processing and load balancing.

![1706103060616](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/be177349-23dc-4156-88f4-65c1bbd158ad)


## Core Components of System Architecture
[Distributed Messaging Queues]
Enables seamless communication between different components of a system, ensuring efficient message exchange.

[DNS (Domain Name System)]
Facilitates the translation of user-friendly domain names into IP addresses, enabling browsers to locate web servers on the internet.

[Load Balancer]
Distributes incoming web traffic across multiple servers, ensuring optimal resource utilization and preventing overload on individual servers.

[Distributed Caching]
Stores frequently used data efficiently, reducing the need for repeated retrieval from slower databases.

[Database]
Organizes, stores, and retrieves data, serving as a central hub for various applications and services.

[Distributed Task Scheduler]
Efficiently organizes and assigns tasks across different system components, ensuring coordinated operations.

[Observability]
Provides insights into system performance, aiding issue identification and maintaining optimal functioning.

[Unstructured Data Storage]
Accommodates various data types without requiring predefined structures, offering flexibility.

[Scaling Services]
Enables the system to handle increased traffic and demand by expanding its capacity.

[Publish-Subscribe Model]
Facilitates communication between different system parts without direct connections.

[Unique ID Generator]
Creates distinct identifiers for each piece of data, ensuring data integrity and uniqueness.

[Rate-Limiting]
Controls the flow of requests to maintain a steady and manageable pace, preventing strain on the system.

![1706103060616](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/b0885934-5c90-42bd-8124-284f347456fb)

## 𝐇𝐨𝐰 𝐑𝐄𝐒𝐓 𝐀𝐏𝐈 𝐰𝐨𝐫𝐤?
At its core, 𝐑𝐄𝐒𝐓 (𝐑𝐞𝐩𝐫𝐞𝐬𝐞𝐧𝐭𝐚𝐭𝐢𝐨𝐧𝐚𝐥 𝐒𝐭𝐚𝐭𝐞 𝐓𝐫𝐚𝐧𝐬𝐟𝐞𝐫) is an architectural style that provides a set of constraints for designing networked applications. REST APIs serve as the building blocks for communication between different software components, enabling them to request and exchange data seamlessly.

Here's a simplified breakdown of REST API for you!

𝐑𝐞𝐬𝐨𝐮𝐫𝐜𝐞𝐬: REST revolves around resources, which can be anything from a user profile to a product catalog. Each resource is uniquely identified by a URL, forming the basis for interactions.

𝐇𝐓𝐓𝐏 𝐕𝐞𝐫𝐛𝐬: REST APIs make use of the HTTP methods (GET, POST, PUT, DELETE, etc.) to perform actions on resources. For instance, a GET request retrieves data, while a POST request creates new data.

𝐒𝐭𝐚𝐭𝐞𝐥𝐞𝐬𝐬 𝐂𝐨𝐦𝐦𝐮𝐧𝐢𝐜𝐚𝐭𝐢𝐨𝐧: One of REST's key principles is statelessness. Each request to a REST API should contain all the information needed to understand and process it, making the interactions independent of one another.

𝐔𝐧𝐢𝐟𝐨𝐫𝐦 𝐈𝐧𝐭𝐞𝐫𝐟𝐚𝐜𝐞: REST APIs have a consistent and uniform interface that follows conventions. This predictability simplifies development and integration.

𝐑𝐞𝐩𝐫𝐞𝐬𝐞𝐧𝐭𝐚𝐭𝐢𝐨𝐧: Resources are represented in a format, often JSON or XML. This representation is sent between the client and server to carry information.

𝐂𝐥𝐢𝐞𝐧𝐭-𝐒𝐞𝐫𝐯𝐞𝐫 𝐀𝐫𝐜𝐡𝐢𝐭𝐞𝐜𝐭𝐮𝐫𝐞: REST emphasizes the separation between clients (the user interface) and servers (the data storage and processing), allowing for greater scalability and flexibility.

So, the next time you interact with an app on your smartphone, think about how REST APIs enable it to fetch your latest messages, update your profile, or show you the news. REST is the behind-the-scenes magician that ensures everything works seamlessly.

Let's keep the conversation going and demystify the tech that powers our digital world!

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/05d80a5f-5e68-494b-a5ed-28ddbfbc7f0f)

## Single Sign-On (SSO) explained in simple terms.

### 𝗞𝗲𝘆 𝗣𝗹𝗮𝘆𝗲𝗿𝘀 𝗶𝗻 𝗦𝗦𝗢

1. User - The individual seeking access to applications
2. Identity Provider (IDP) - Authenticates users (e.g. Google, Facebook)
3. Application - The software or service the user wants to access

### 𝗕𝗲𝗻𝗲𝗳𝗶𝘁𝘀 𝗼𝗳 𝗦𝗦𝗢

- Simplifies access with one set of credentials
- Enhances user experience
- Reduces password fatigue
- Centralizes security and access management
- Improves security
- Streamlines access control
- Simplifies compliance reporting
- Allows seamless integration

### 𝗛𝗼𝘄 𝗦𝗦𝗢 𝗪𝗼𝗿𝗸𝘀

- User tries to log into an application
- Application redirects user to SSO/IDP
- IDP authenticates user
- IDP issues authenticated token
- Token sent back to browser
- Browser presents token to application
- Application grants access without re-entering credentials

This streamlined process enables single login access to multiple applications, improving convenience and security.

Over to you: With SSO facilitating access across various platforms, what measures do you consider essential to maintain the integrity and security of user identities?

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/9d4a2610-84ee-4061-a416-e797ec3783c7)

## ChatGPT Mastery Cheat Sheet
Unlock the full potential of ChatGPT:

𝗔𝗰𝘁 𝗮𝘀 𝗮 [𝗥𝗢𝗟𝗘]:
• Support Representative
• Code Debugger
• Language Translator

𝗠𝗼𝗱𝗲𝘀 𝗮𝗻𝗱 𝗥𝗼𝗹𝗲𝘀:
• Generate Ideas for [Project]
• Plan Schedule for [Event]
• Edit Content for [Publication]

𝗦𝗲𝘁 𝗧𝗼𝗻𝗲𝘀:
• Formal
• Casual
• Enthusiastic

𝗖𝗿𝗲𝗮𝘁𝗲 𝗮 𝗧𝗮𝘀𝗸:
• Generate Code
• Plan Outline
• Write Story

𝗗𝗲𝗳𝗶𝗻𝗲 [𝗙𝗼𝗿𝗺𝗮𝘁]:
• Bullet Points
• List
• Code Snippet

𝗔𝘂𝘁𝗼𝗺𝗮𝘁𝗶𝗼𝗻:
• Streamlining Processes
• Repetitive Tasks
• Operational Streamlining

𝗥𝗲𝘀𝗲𝗮𝗿𝗰𝗵 𝗣𝗿𝗼𝗺𝗽𝘁𝘀:
• Summarize Scientific Article
• Compile Recent Studies on [Topic]
• Explore Recent Research Studies

𝗗𝗲𝘀𝗶𝗴𝗻𝗲𝗿 𝗣𝗿𝗼𝗺𝗽𝘁𝘀:
• Design Distinctive Logo
• Develop Website Mockup
• Generate Color Palette

𝗠𝗮𝗿𝗸𝗲𝘁𝗲𝗿 𝗣𝗿𝗼𝗺𝗽𝘁𝘀:
• Craft Persuasive Marketing Copy
• Develop Tagline Ideas
• Create Social Media Posts

𝗗𝗲𝘃𝗲𝗹𝗼𝗽𝗲𝗿 𝗣𝗿𝗼𝗺𝗽𝘁𝘀:
• Resolve Code Issues
• Generate Python Script
• Explain Algorithmic Concepts

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/ac24ee39-3ebc-4f9d-812e-a02abeaa7d6d)

## Hands-On Guide: Implementing CI/CD for your web application with AWS Codepipeline
https://www.linkedin.com/posts/mtayyabsattar_implementing-cicd-for-your-web-application-activity-7152670931243446274-fIw0?utm_source=share&utm_medium=member_desktop

## IBM and Meta offering Web Development Courses for everyone.🚀🚀

Repost so that all can take benifits

𝐈𝐁𝐌 𝐖𝐞𝐛 𝐃𝐞𝐯𝐞𝐥𝐨𝐩𝐦𝐞𝐧𝐭 𝐂𝐨𝐮𝐫𝐬𝐞𝐬

👉 https://lnkd.in/dKYZ_F9i

1. IBM Full Stack Software Developer Professional Certificate
👉 https://lnkd.in/dADYt4Wz

2. Introduction to Web Development with HTML, CSS, JavaScript
👉 https://lnkd.in/dgs9bQ-6

3. IBM Front-End Developer Professional Certificate
👉 https://lnkd.in/dmP3PDaU

4. IBM Back-End Development Professional Certificate
👉 https://lnkd.in/dfkdxEEr

5. IBM Python for Data Science, AI & Development
👉 https://lnkd.in/dwVbZt7b

6. IBM Developing Cloud Apps with Node.js and React
👉 https://lnkd.in/dSqJck7A

𝐌𝐞𝐭𝐚 𝐖𝐞𝐛 𝐃𝐞𝐯𝐞𝐥𝐨𝐩𝐦𝐞𝐧𝐭 𝐂𝐨𝐮𝐫𝐬𝐞𝐬

1. Meta Front-End Developer Professional Certificate
👉https://lnkd.in/dE7FKwMp

2. Meta React Native Specialization
👉 https://lnkd.in/dXCs5ewA

3. Introduction to Front-End Development
👉 https://lnkd.in/dxmyJ2iw

4. Meta HTML and CSS in depth
👉 https://lnkd.in/dwyWkpqK

5. Advanced React
👉 https://lnkd.in/dBaF8Krj

6. HTML, CSS, and Javascript for Web Developers
👉 https://lnkd.in/d3Zm2h3P

7. Web Design for Everybody: Basics of Web Development & Coding Specialization
👉 https://lnkd.in/dudsqPYK

8. Introduction to Web Development
👉 https://lnkd.in/drdy75ig

9. Responsive Website Development and Design Specialization
👉 https://lnkd.in/dn425Hps

10. Full Stack Web Development en Español Specialization
👉 https://lnkd.in/dPQ92M4u

11. Web Applications for Everybody Specialization
👉 https://lnkd.in/dt_HS7Pm

## How DNS Works - A Simplified Overview
[1] User Types a URL:
A user enters a website's URL (Uniform Resource Locator) into their browser.
[2] Browser Contacts DNS Resolver:
The browser checks its local DNS resolver (usually provided by the internet service provider) to find the IP address associated with the entered domain.
[3] DNS Resolver Searches Cache:
The DNS resolver checks its cache for a previously resolved IP address for the requested domain. If found, the process skips to the next step.
[4] Recursive DNS Query:
If the resolver doesn't have the IP address, it starts a recursive query. It contacts the root DNS server, asking for information about the top-level domain (TLD) of the requested site.
[5] Root DNS Server Response:
The root DNS server responds with the TLD DNS server's address.
[6] TLD DNS Server Inquiry:
The resolver contacts the TLD DNS server, asking for information about the authoritative DNS server for the specific domain.
[7] Authoritative DNS Server Contact:
The TLD DNS server responds with the IP address of the authoritative DNS server for the domain.
[8] Domain's Authoritative DNS Server Response:
The resolver contacts the authoritative DNS server, requesting the IP address associated with the domain.
[9] Authoritative DNS Server Provides IP:
The authoritative DNS server responds with the IP address of the requested domain.
[10] DNS Resolver Caches IP:
The DNS resolver caches the obtained IP address for future use and sends it to the user's browser.
[11] Browser Connects to IP Address:
The browser uses the obtained IP address to connect to the web server hosting the requested website.

![1705680493626](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/3b64d226-cf65-481b-bcea-3cfb65a0bba3)


## Insights into SSL Certificate Workflow:
ClientHello:
The client initiates the SSL/TLS handshake by sending a "ClientHello" message to the server, indicating its intent to establish a secure connection.

ServerHello and Certificate Exchange:
The server responds with a "ServerHello" message, selecting a cipher suite for secure communication. It then presents its SSL certificate to the client, initiating the certificate exchange.

Trust Verification and Key Exchange:
The client verifies the certificate's authenticity by checking its digital signature against trusted CAs. Simultaneously, both parties engage in a key exchange, using public-key cryptography to establish a shared secret key.

Pre-master Secret and Session Keys:
The client generates a pre-master secret, encrypts it with the server's public key, and sends it back. Both client and server independently derive session keys from the pre-master secret, ensuring secure communication.

Finished:
Both parties exchange "Finished" messages, confirming that the handshake is complete. From this point onward, the established session keys encrypt and decrypt data, securing the communication channel.

![1705331828985](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/f56f48e4-6104-4899-80a7-d2e6c30ca12c)

## Sorting algorithms 
Sorting algorithms are fundamental techniques in computer science and are used to rearrange elements in a specified order. The efficiency of sorting algorithms is often evaluated based on factors like time complexity, space complexity, and stability.
✅Bubble Sort:
🔶 Description: Bubble sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.
🔶 Time Complexity: O(n^2) in the worst and average case, O(n) in the best case (when the list is already sorted).
🔶 Space Complexity: O(1) (in-place algorithm).
✅ Selection Sort:
🔶 Description: Selection sort divides the input into a sorted and an unsorted region. It repeatedly selects the smallest (or largest, depending on the order) element from the unsorted region and moves it to the sorted region.
🔶 Time Complexity: O(n^2) regardless of input.
🔶 Space Complexity: O(1) (in-place algorithm).
✅ Insertion Sort:
🔶 Description: Insertion sort builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.
🔶 Time Complexity: O(n^2) in the worst and average case, O(n) in the best case.
🔶 Space Complexity: O(1) (in-place algorithm).
✅ Merge Sort:
🔶 Description: Merge sort is a divide-and-conquer algorithm that divides the input array into two halves, recursively sorts them, and then merges the sorted halves.
🔶 Time Complexity: O(n log n) in all cases.
🔶 Space Complexity: O(n) additional space is required for the merging process.
✅ Quick Sort:
🔶 Description: Quick sort is another divide-and-conquer algorithm that partitions the array into two parts, with elements less than a chosen pivot on one side and elements greater on the other. The process is applied recursively to the two sub-arrays.
🔶 Time Complexity: O(n^2) in the worst case, O(n log n) on average.
🔶 Space Complexity: O(log n) on average for the recursive call stack.
✅ Heap Sort:
🔶 Description: Heap sort is based on the binary heap data structure. It first builds a max heap from the input array and repeatedly extracts the maximum element, ensuring that the remaining elements form a valid heap.
🔶 Time Complexity: O(n log n) in all cases.
🔶 Space Complexity: O(1) (in-place algorithm).
Sorting algorithms are chosen based on the specific requirements of the application and the characteristics of the data to be sorted. Different algorithms may be more suitable for different scenarios, depending on factors such as data size, stability, and memory constraints.

![1705509378264](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/a280c10d-a4b6-48eb-a070-19616b9527a3)

## Log Parsing Cheat Sheet

The diagram below lists the 𝘁𝗼𝗽 𝟲 𝗹𝗼𝗴 𝗽𝗮𝗿𝘀𝗶𝗻𝗴 𝗰𝗼𝗺𝗺𝗮𝗻𝗱𝘀.

1. GREP

GREP searches any given input files, selecting lines that match one or more patterns.

2. CUT

CUT cuts out selected portions of each line from each file and writes them to the standard output.

3. SED

SED reads the specified files, modifying the input as specified by a list of commands.

4. AWK

AWK scans each input file for lines that match any of a set of patterns.

5. SORT

SORT sorts text and binary files by lines.

6. UNIQ

UNIQ reads the specified input file comparing adjacent lines and writes a copy of each unique input line to the output file.

𝗟𝗲𝘁’𝘀 𝘄𝗮𝗹𝗸 𝘁𝗵𝗿𝗼𝘂𝗴𝗵 𝗮𝗻 𝗲𝘅𝗮𝗺𝗽𝗹𝗲.

To count the number of hits from the top 10 IP addresses requesting the path "/api/payments" from the access log in this common log format:

216.67.1.91 - leon [01/Jul/2002:12:11:52 +0000] "GET /index.html HTTP/1.1" 200 431

We can use a combination of grep, cut, sort, and uniq commands. 𝗛𝗲𝗿𝗲 𝗶𝘀 𝗮 𝘀𝗮𝗺𝗽𝗹𝗲 𝗰𝗼𝗺𝗺𝗮𝗻𝗱:

grep '/api/payments' access.log | cut -d ' ' -f 1 | sort | uniq -c | sort -rn | head -10

Here's what each part of the command does:

- grep '/api/payments' access.log: This filters the lines containing "/api/payments" from the access.log file.

- cut -d ' ' -f 1: This extracts the first field (the IP address) from each line. The -d ' ' option specifies space as the field delimiter.

- sort: This sorts the IP addresses.

- uniq -c: This removes duplicate lines and prefixes lines by the number of occurrences.

- sort -rn: This sorts the lines in reverse order (highest first) numerically.

- head -10: This shows only the first 10 lines of the output, which correspond to the top 10 IP addresses.

Over to you: Please share your top log parsing tips and tricks.

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/2a93fe91-df1d-4f08-8beb-39ad5c9f36f8)

## 𝐇𝐨𝐰 𝐝𝐨 𝐩𝐫𝐨𝐭𝐨𝐜𝐨𝐥𝐬 𝐰𝐨𝐫𝐤 𝐢𝐧 𝐭𝐡𝐞 𝐓𝐂𝐏/𝐈𝐏 𝐨𝐫 𝐎𝐒𝐈 𝐌𝐨𝐝𝐞𝐥❓
The TCP/IP and OSI models are frameworks that describe how data is transmitted over a network.

𝐓𝐂𝐏/𝐈𝐏 𝐌𝐨𝐝𝐞𝐥:
The TCP/IP model is simpler, with four layers:

Link Layer (Network Interface Layer):

Manages the physical transmission of data over a network. Converts binary data from the Transport Layer into network frames, preparing them for physical transmission over the network.

Components: Network interface cards (NICs), Ethernet, and protocols like ARP (Address 
Resolution Protocol).

Internet Layer (Network Layer):

Handles the logical transmission of data across the network. Determines the best path for data packets to travel across networks using IP addresses.

Components: Routers and protocols like IP (Internet Protocol), ICMP (Internet Control Message Protocol).

Transport Layer:

Manages end-to-end communication between hosts. Ensures data is sent and received in order, without errors. TCP provides reliable communication, while UDP offers faster, but less reliable, transfer.

Components: Protocols like TCP (Transmission Control Protocol) and UDP (User Datagram Protocol).

Application Layer:

Provides protocols for specific user applications. This layer is where user applications interact with the network stack, using protocols suited to different types of data and services.

Components: Protocols like HTTP (Hypertext Transfer Protocol), SMTP (Simple Mail Transfer Protocol).

𝐎𝐒𝐈 𝐌𝐨𝐝𝐞𝐥:
The OSI model is more detailed, with seven layers:

Physical Layer:

Transmits raw bit stream over the physical medium.Manages the physical connection between devices.

Components: Cables, switches, and the physical aspects of the network.

Data Link Layer:

Ensures error-free transmission over the physical layer. Frames data packets, handles error detection and correction.

Components: Bridges, switches, and protocols like Ethernet.

Network Layer:

Manages device addressing and path determination. Routes data across multiple networks.

Components: Routers, and protocols like IP.

Transport Layer:

Similar to the TCP/IP model, it manages end-to-end communication and data integrity.

Session Layer:

Manages sessions between applications.Establishes, manages, and terminates sessions.

Components: APIs and services that enable communication between machines.

Presentation Layer:

Translates data between the application layer and the network. Ensures that data is in the correct format for the application layer.

Components: Encryption, compression, and translation services.

Application Layer:

Similar to the TCP/IP model, interfaces directly with user applications.

The TCP/IP model is more practical and aligned with real-world networking.
In practice, TCP/IP’s Application Layer encompasses OSI's Application, Presentation, and Session layers.

![1704805635565](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/8b68fccf-46ed-4894-9273-5eff8c342ac2)


## Java Exceptions
You would agree that Exception handling is a critical aspect of a Java Application.

Let's refresh some basic tips on handling exceptions -

[*] Catch with Precision
- Catch specific exceptions rather than generic ones like Exception.
- This allows you to handle each exception type differently and provide tailored solutions.

try {
 // Code that may throw specific exceptions
} catch (FileNotFoundException e) {
 // Handle file not found exception
} catch (IOException e) {
 // Handle IO exception
}


[*] Graceful Error Handling
- When an exception strikes, don't leave your users in the dark!
- Provide meaningful error messages or logs to facilitate troubleshooting and enhance the user experience.

try {
 // Code that may throw an exception
} catch (Exception e) {
 logger.error("An error occurred: " + e.getMessage());
 // Provide meaningful error message to aid in troubleshooting
}


[*] Resource Cleanup with Finesse
- Use the 'finally' block only to release system resources like file handles, database connections, or network connections.

try (FileInputStream fileInputStream = new FileInputStream("file.txt")) {
 // Code
} catch (IOException e) {
 // Handle exception 
} finally {
 // Cleanup: The file input stream will be closed automatically
}


[*] Rethrow Strategically
- Consider whether to re-throw an exception or wrap it in a new one. 
- Rethrowing can be useful for propagating errors, but remember to provide valuable context for smooth debugging.

try {
 // Code that may throw an exception
} catch (IOException e) {
 logger.error("An error occurred: " + e.getMessage());
 throw new CustomException("An error occurred while processing the data.", e);
 // Rethrow the exception while providing additional context
}


[*] Mindful Checked Exceptions
- Choose checked exceptions wisely. Excessive use can clutter code and make it harder to maintain.
- Opt for unchecked exceptions or custom types when they fit the bill.

public void readFile() throws IOException {
 // Code that may throw IOException
}


[*] Embrace the Power of 'try-with-resources':
- For automatic resource management, leverage the elegance of the try-with-resources statement.
- It ensures proper resource closure and minimizes leaks.

try (Connection connection = DriverManager.getConnection(url, username, password);
 Statement statement = connection.createStatement()) {
 // Code that uses the connection and statement
} catch (SQLException e) {
 // Handle any exceptions that occur
}


[*] Ignoring is Not an Option
- Avoid turning a blind eye to exceptions!
  
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/17d4f67f-9115-4b3a-8af0-193d321eaaf2)

## 𝗢𝗽𝘁𝗶𝗺𝗶𝘀𝗲 𝗬𝗼𝘂𝗿 𝗗𝗼𝗰𝗸𝗲𝗿 𝗪𝗼𝗿𝗸𝗳𝗹𝗼𝘄 🚀💻

Supercharge your Docker skills with these key commands:

𝟭. 𝗿𝘂𝗻: Launch containers from images.
𝟮. 𝘀𝘁𝗼𝗽: Gracefully halt running containers.
𝟯. 𝘀𝘁𝗮𝗿𝘁: Revitalize stopped containers.
𝟰. 𝗲𝘅𝗲𝗰: Execute commands within containers.
𝟱. 𝗽𝗼𝗿𝘁: Identify a container's public-facing port.
𝟲. 𝗿𝗲𝗻𝗮𝗺𝗲: Give containers new identities.
𝟳. 𝗽𝗮𝘂𝘀𝗲/𝘂𝗻𝗽𝗮𝘂𝘀𝗲: Suspend/resume container processes.
𝟴. 𝗸𝗶𝗹𝗹: Halt running containers.
𝟵. 𝗯𝘂𝗶𝗹𝗱: Create custom Docker images.
𝟭𝟬. 𝘁𝗼𝗽: Display running processes of a container.
𝟭𝟭. 𝗰𝗽: Copy files between containers and local system.
𝟭𝟮. 𝗿𝗺: Remove stopped containers.
𝟭𝟯. 𝘀𝘁𝗮𝘁𝘀: Monitor real-time container resource usage.
𝟭𝟰. 𝗽𝘀: View container processes.
𝟭𝟱. 𝗵𝗶𝘀𝘁𝗼𝗿𝘆: View image evolution history.
𝟭𝟲. 𝗶𝗺𝗮𝗴𝗲 𝗹𝘀: List available Docker images.
𝟭𝟳. 𝗹𝗼𝗴𝘀: Retrieve and analyze container logs.
𝟭𝟴. 𝘃𝗲𝗿𝘀𝗶𝗼𝗻: Check Docker version.
𝟭𝟵. 𝗶𝗻𝗳𝗼: Fetch crucial Docker system information.
𝟮𝟬. 𝗶𝗻𝘀𝗽𝗲𝗰𝘁: Explore details of containers, images, networks.


![1704294993746](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/3bc5086b-9037-4dee-866d-00c8b6550199)


## Forget web developers/Web Designer
Here is the list of 8 AI tool that creates your website in 5 min:

1 10Web.io

It helps users to build or recreate any website with AI in minutes.

2 Dora

Design and publish stunning 3D & animated websites effortlessly, without the need for coding.

3 Durable

Build a website in 30 secs using AI .

4 Bookmark

Get your business online in a minute

5 Framer

It is an amazing tool that makes it possible to create a website in less than two minutes.

6 sitekickai

It allows you to create beautiful landing pages. Without the need for coding, design or copywriting skills.

7 Makelanding AI

Make a beautiful landing page in seconds .

8 Createwebsite

It is not just about creating websites, it's about creating powerful, lightning-fast digital experiences.

## Session, Cookie, JWT, Token, SSO, and OAuth 2.0 Explained in One Diagram
When you login to a website, your identity needs to be managed. Here is how different solutions work:

- Session - The server stores your identity and gives the browser a session ID cookie. This allows the server to track login state. But cookies don't work well across devices.

- Token - Your identity is encoded into a token sent to the browser. The browser sends this token on future requests for authentication. No server session storage is required. But tokens need encryption/decryption.

- JWT - JSON Web Tokens standardize identity tokens using digital signatures for trust. The signature is contained in the token so no server session is needed.

- SSO - Single Sign On uses a central authentication service. This allows a single login to work across multiple sites.

- OAuth2 - Allows limited access to your data on one site by another site, without giving away passwords.

Over to you: QR code logins are gaining popularity. Do you know how it works?


![1703745073045](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/9dadf720-9f36-4b29-9994-6ff234da87d9)


## Top 12 Tips for API Security
- Use HTTPS
- Use OAuth2
- Use WebAuthn
- Use Leveled API Keys
- Authorization
- Rate Limiting
- API Versioning
- Whitelisting
- Check OWASP API Security Risks
- Use API Gateway
- Error Handling
- Input Validation

![1703833728966](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/1766c0c9-f242-4668-8754-227cba85cc0a)

## 𝗦𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝘃𝘀. 𝗔𝘀𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝗘𝗻𝗰𝗿𝘆𝗽𝘁𝗶𝗼𝗻 𝗘𝘅𝗽𝗹𝗮𝗶𝗻𝗲𝗱 🔒
Whether you're a cybersecurity enthusiast, a developer, or someone curious about securing digital communication, understanding these encryption methods is necessary.

Let's delve into the key distinctions:

𝗦𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝗘𝗻𝗰𝗿𝘆𝗽𝘁𝗶𝗼𝗻:
- Description: Symmetric encryption employs a single, shared key for both encryption and decryption.
- Use Case: Ideal for scenarios where a secure channel already exists for key exchange.

𝗔𝘀𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝗘𝗻𝗰𝗿𝘆𝗽𝘁𝗶𝗼𝗻:
- Description: Asymmetric encryption uses a pair of keys, public and private, for encryption and decryption.
- Use Case: Suitable for secure communication over untrusted networks, eliminating the need for a shared secret.

𝗞𝗲𝘆 𝗗𝗶𝗳𝗳𝗲𝗿𝗲𝗻𝗰𝗲𝘀: 𝗦𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝘃𝘀. 𝗔𝘀𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰

𝟭. 𝗞𝗲𝘆 𝗠𝗮𝗻𝗮𝗴𝗲𝗺𝗲𝗻𝘁:
- Symmetric: Requires secure key distribution mechanisms.
- Asymmetric: Public keys can be openly shared, while private keys are closely guarded.

𝟮. 𝗖𝗼𝗺𝗽𝘂𝘁𝗮𝘁𝗶𝗼𝗻𝗮𝗹 𝗖𝗼𝗺𝗽𝗹𝗲𝘅𝗶𝘁𝘆:
- Symmetric: Generally faster and less computationally intensive.
- Asymmetric: Slower due to complex mathematical operations.

𝟯. 𝗦𝗰𝗮𝗹𝗮𝗯𝗶𝗹𝗶𝘁𝘆:
- Symmetric: Efficient for large-scale data encryption.
- Asymmetric: More resource-intensive, especially for bulk data.

𝟰. 𝗨𝘀𝗲 𝗖𝗮𝘀𝗲𝘀:
- Symmetric: Secure, established channels, and resource-constrained environments.
- Asymmetric: Secure communication over untrusted networks, digital signatures, and key exchange.

𝗥𝗲𝗮𝗹-𝗪𝗼𝗿𝗹𝗱 𝗔𝗽𝗽𝗹𝗶𝗰𝗮𝘁𝗶𝗼𝗻𝘀:

𝟭. 𝗦𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝗘𝗻𝗰𝗿𝘆𝗽𝘁𝗶𝗼𝗻 𝗶𝗻 𝗣𝗿𝗮𝗰𝘁𝗶𝗰𝗲:
- Utilized in HTTPS/TLS for securing web traffic.
- Commonly applied in VPNs for secure communication between network devices.

𝟮. 𝗔𝘀𝘆𝗺𝗺𝗲𝘁𝗿𝗶𝗰 𝗘𝗻𝗰𝗿𝘆𝗽𝘁𝗶𝗼𝗻 𝗶𝗻 𝗣𝗿𝗮𝗰𝘁𝗶𝗰𝗲:
- Facilitates secure email communication through digital signatures.
- Forms the basis for secure communication in blockchain technology.

𝗖𝗵𝗼𝗼𝘀𝗶𝗻𝗴 𝘁𝗵𝗲 𝗥𝗶𝗴𝗵𝘁 𝗘𝗻𝗰𝗿𝘆𝗽𝘁𝗶𝗼𝗻 𝗦𝘁𝗿𝗮𝘁𝗲𝗴𝘆:

- Data Sensitivity: Assess the level of sensitivity of your data and communication.
- Resource Constraints: Consider the computational resources available for encryption and decryption.
- Key Distribution: Evaluate the feasibility of securely distributing and managing encryption keys.


![1703426416669](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/0c21005f-ee3e-4f07-abcd-2c52fe63e926)


## Key Concepts to Understand Database Sharding
Database sharding refers to splitting data across multiple database servers and is commonly used for scaling. However, sharding introduces major operational and infrastructure complexity that should be 𝗮𝘃𝗼𝗶𝗱𝗲𝗱 𝘂𝗻𝗹𝗲𝘀𝘀 𝗮𝗯𝘀𝗼𝗹𝘂𝘁𝗲𝗹𝘆 𝗻𝗲𝗰𝗲𝘀𝘀𝗮𝗿𝘆.

𝗔𝗽𝗽𝗿𝗼𝗮𝗰𝗵𝗲𝘀 𝘁𝗼 𝗽𝗼𝘀𝘁𝗽𝗼𝗻𝗲 𝘀𝗵𝗮𝗿𝗱𝗶𝗻𝗴

Vertical Scaling: Use more powerful single database servers - more CPUs, memory, storage and I/O bandwidth. Much simpler to manage than sharding while allowing sizable expansion.

SQL Optimization: Tune SQL queries and database schema to maximize performance on a single server. Requires proper indexes, efficient SQL, etc.

Caching: Use in-memory caches like Redis to reduce database load by avoiding hitting it for every common query.

Read Replicas + Load Balancer: Adds horizontal read scaleability without full complexity of sharding. Directs reads across replicas.

These optimization approaches should be 𝗲𝘅𝗵𝗮𝘂𝘀𝘁𝗲𝗱 𝗯𝗲𝗳𝗼𝗿𝗲 𝘀𝗵𝗮𝗿𝗱𝗶𝗻𝗴 𝗴𝗶𝘃𝗲𝗻 𝘁𝗵𝗲 𝗰𝗼𝗺𝗽𝗹𝗲𝘅𝗶𝘁𝘆.

𝗛𝗼𝗿𝗶𝘇𝗼𝗻𝘁𝗮𝗹 𝘃𝘀 𝗩𝗲𝗿𝘁𝗶𝗰𝗮𝗹 𝗦𝗵𝗮𝗿𝗱𝗶𝗻𝗴

There are two high-level approaches:

Vertical Sharding: Split database into columnar tables or sections vs rows. For example, having one table for names and another table for emails.

Horizontal Sharding: Split database into row partitions distributed evenly across multiple servers.

Some horizontal sharding methods:

1. 𝗥𝗮𝗻𝗴𝗲 𝗕𝗮𝘀𝗲𝗱: Segment rows based on range values like age groups. Can cause uneven data distribution and hot spots.

2. 𝗗𝗶𝗿𝗲𝗰𝘁𝗼𝗿𝘆 𝗕𝗮𝘀𝗲𝗱: Use a lookup directory to locate rows. Allows flexibility but single point of failure risk.

3. 𝗛𝗮𝘀𝗵 𝗕𝗮𝘀𝗲𝗱: Apply hash functions to spread rows uniformly across shards. Harder to rebalance.

When sharding, use the simplest approach that meets requirements to minimize complexity. Seek to avoid until necessary.

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/08d0d9f4-ca4f-4d82-8946-c85ce05ebafc)

## Logging, tracing and metrics are 3 pillars of system observability. 
The diagram below shows their definitions and typical architectures.

🔹 Logging
Logging records discrete events in the system. For example, we can record an incoming request or a visit to databases as events. It has the highest volume. ELK (Elastic-Logstash-Kibana) stack is often used to build a log analysis platform. We often define a standardized logging format for different teams to implement, so that we can leverage keywords when searching among massive amounts of logs.

🔹 Tracing
Tracing is usually request-scoped. For example, a user request goes through the API gateway, load balancer, service A, service B, and database, which can be visualized in the tracing systems. This is useful when we are trying to identify the bottlenecks in the system. We use OpenTelemetry to showcase the typical architecture, which unifies the 3 pillars in a single framework.

🔹 Metrics
Metrics are usually aggregatable information from the system. For example, service QPS, API responsiveness, service latency, etc. The raw data is recorded in time-series databases like InfluxDB. Prometheus pulls the data and transforms the data based on pre-defined alerting rules. Then the data is sent to Grafana for display or to the alert manager which then sends out email, SMS, or Slack notifications or alerts.

![1703782033069](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/b5f3d648-cbe6-491d-88c2-8d9df3c4acc7)


## How SSO/SAML works!

AssumeRole: Easily switch roles within your AWS account or between accounts for straightforward permission management.

AssumeRoleWithSAML: Use SAML (a secure standard) to get credentials for users, making sure only the right people have access.

AssumeRoleWithWebIdentity: For users signing in via Amazon Cognito, Google, or Facebook, AWS suggests using Cognito for a hassle-free login.

GetSessionToken: Boost security by adding Multi-Factor Authentication (MFA) for users or the main AWS account holder.

GetFederationToken: Great for apps acting on behalf of users, this gives temporary access to those who need it, keeping things flexible yet secure.

Identity Federation in AWS: This lets you extend AWS access to users outside of AWS, without having to individually manage each user. It's great for organizations that already have their own identity systems (like Active Directory) or for apps that need to use AWS resources.

Key features include:

SAML 2.0 Integration: Works smoothly with well-known identity providers, granting temporary access to AWS services.

Custom Identity Broker: A solution for when your identity provider isn't SAML-compatible, managing authentication and AWS access.

Learn more about how SAML and AWS federation can simplify your access management, keeping your AWS resources secure and easily manageable. Dive into the world of AWS Identity Federation and unlock the full potential of your AWS resources!

![1703302178016](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/2c27d8c9-811b-4100-8b11-a2c68ce2e0b1)

## Java Development - Cache Types
Effective caching is fundamental to designing scalable and responsive data-intensive applications.

How it helps?

By caching intermediate results, frequently accessed data, or query results, these applications can minimize the need for repeated and resource-intensive computations.

This enhances application responsiveness and minimizes the impact of I/O operations on performance.

Caching can be implemented at various levels, such as application-level caching, database query result caching, or distributed caching, to ensure timely access to data and improve overall system performance.

Let's talk about different type of Caches -

[1.] L1 Cache
On-CPU cache, includes L1 Instruction Cache (L1i) for machine code instructions and L1 Data Cache (L1d) for frequently used data.

[2.] In-Memory Caching
Uses Java Collections Framework (e.g., HashMap, ConcurrentHashMap) to cache data in memory.

[3.] Distributed Caching
Utilizes frameworks like Ehcache, Hazelcast, or Redis to distribute cached data across multiple nodes.

[4.] Second-Level Caching
In Hibernate, caches database query results to reduce redundant database calls.

[5.] Spring Caching
Leverages Spring's caching abstraction to integrate caching mechanisms (e.g., Ehcache, Redis) into applications.

[6.] Web Caching
Uses HTTP caching headers (e.g., Cache-Control, ETag) for client-side or intermediary proxy caching.

[7.] Query Result Caching
In Hibernate, caches results of database queries to optimize performance.

[8.] Aspect-Oriented Caching
Utilizes AspectJ or Spring AOP to separate caching logic from business logic.

[9.] JCache (JSR-107)
Implements javax.cache, a standard caching API for Java applications.

[10.] Guava Cache
Incorporates Google Guava Cache, an in-memory caching library with features like expiration and eviction.

[11.] OS-Level Caching
Leverages the file system cache for reading frequently accessed files to improve performance.

## Some common #SQL interview questions along with their queries:
1. Write a SQL query to find the second highest salary from the 'emp' table. (Columns: id, salary)
```sql
SELECT MAX(salary) AS second_highest_salary
FROM emp
WHERE salary < (SELECT MAX(salary) FROM emp);
```

2. Write a SQL query to find numbers that consecutively occur 3 times in the 'id' column of a table. (Columns: id, numbers)
```sql
SELECT DISTINCT a.numbers
FROM table_name a, table_name b, table_name c
WHERE a.numbers = b.numbers AND b.numbers = c.numbers
AND a.id = b.id - 1 AND b.id = c.id - 1;
```

3. Write a SQL query to find the days when the temperature was higher than its previous dates. (Columns: Days, Temp)
```sql
SELECT Days, Temp
FROM table_name t1
WHERE Temp > (SELECT Temp FROM table_name t2 WHERE t2.Days = t1.Days - 1);
```
4. Write a SQL query to delete duplicate rows in a table.
```sql
DELETE FROM table_name
WHERE ROWID NOT IN (SELECT MIN(ROWID) FROM table_name GROUP BY column1, column2, ...);
```

5. Write a SQL query for the cumulative sum of salary for each employee from January to July. (Columns: Emp_id, Month, Salary)
```sql
SELECT Emp_id, Month, SUM(Salary) OVER (PARTITION BY Emp_id ORDER BY Month) AS Cumulative_Salary
FROM salary_table
WHERE Month BETWEEN 'January' AND 'July';
```

6. Write a SQL query to display year-on-year growth for each product. (Columns: transaction_id, Product_id, transaction_date, spend, Output: year, product_id, yoy_growth)
```sql
SELECT EXTRACT(YEAR FROM transaction_date) AS year,
    Product_id,
    (spend - LAG(spend, 1, 0) OVER (PARTITION BY Product_id ORDER BY transaction_date)) / LAG(spend, 1, 0) OVER (PARTITION BY Product_id ORDER BY transaction_date) * 100 AS yoy_growth
FROM transactions;
```

7. Write a SQL query to find the rolling average of posts on a daily basis for each user_id. (Columns: user_id, date, post_count)
```sql
SELECT user_id,
    date,
    ROUND(AVG(post_count) OVER (PARTITION BY user_id ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW), 2) AS rolling_average
FROM posts_table;
```
8. Write a SQL query to get emp id and department for each department, considering employees who recently joined the organization and are currently working. (Columns: emp id, first name, last name, date of join, date of exit, department)
```sql
SELECT e.emp_id, e.first_name, e.last_name, e.date_of_join, e.date_of_exit, d.department
FROM employees e
JOIN departments d ON e.department_id = d.department_id
WHERE e.date_of_join > DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)
AND e.date_of_exit IS NULL;
```
9. Write a query to get mean, median, and mode for earning? (Columns: Emp_id, salary)
```sql
SELECT 
 AVG(salary) AS mean_earning, 
 PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) AS median_earning,
 MODE() WITHIN GROUP (ORDER BY salary) AS mode_earning
FROM earnings_table;
```

## 𝗠𝗶𝗰𝗿𝗼𝘀𝗲𝗿𝘃𝗶𝗰𝗲𝘀 𝗥𝗼𝗮𝗱𝗺𝗮𝗽: 𝐀 𝐂𝐨𝐦𝐩𝐫𝐞𝐡𝐞𝐧𝐬𝐢𝐯𝐞 𝐆𝐮𝐢𝐝𝐞 𝐭𝐨 𝐁𝐮𝐢𝐥𝐝𝐢𝐧𝐠 𝐌𝐨𝐝𝐞𝐫𝐧 𝐀𝐫𝐜𝐡𝐢𝐭𝐞𝐜𝐭𝐮𝐫𝐞𝐬 🚀
𝗗𝗮𝘁𝗮𝗯𝗮𝘀𝗲𝘀:
- SQL: Traditional relational databases for structured data.
- NoSQL: Flexible, scalable databases for unstructured data.
- MySQL, PostgreSQL: Popular SQL databases.
- MongoDB, Cassandra, DynamoDB, HBase: Leading NoSQL databases.

𝗠𝗲𝘀𝘀𝗮𝗴𝗲 𝗕𝗿𝗼𝗸𝗲𝗿:
- Kafka, RabbitMQ, Amazon SQS: Efficient and reliable message brokers for seamless communication between microservices.

𝗠𝗼𝗻𝗶𝘁𝗼𝗿𝗶𝗻𝗴:
- Grafana, Kibana, Prometheus: Monitoring tools providing visibility into microservices' performance and health.

𝗟𝗮𝗻𝗴𝘂𝗮𝗴𝗲𝘀:
- Java, .Net, Go, NodeJS, Python: A diverse set of languages catering to different development preferences and requirements.

𝗖𝗜/𝗖𝗗:
- GitHub Actions, Jenkins, TeamCity, Gitlab, CircleCI: CI/CD tools automating the development, testing, and deployment process.

𝗦𝗲𝗰𝘂𝗿𝗶𝘁𝘆:
- JWT, OAuth 2.0, API Authz., TLS: Essential security protocols and encryption methods ensuring data integrity and access control.

𝗖𝗹𝗼𝘂𝗱 𝗣𝗿𝗼𝘃𝗶𝗱𝗲𝗿:
- AWS, Azure, GCP, Linode, Digital Ocean: Cloud providers offering infrastructure and services for hosting microservices.

𝗖𝗼𝗻𝘁𝗮𝗶𝗻𝗲𝗿 𝗢𝗿𝗰𝗵𝗲𝘀𝘁𝗿𝗮𝘁𝗶𝗼𝗻:
- ECS, Open Shift, Hashicorp, Kubernetes: Orchestrators facilitating the deployment, scaling, and management of containerized applications.

𝗖𝗼𝗻𝘁𝗮𝗶𝗻𝗲𝗿𝘀:
- Docker, Podman: Containerization technologies ensuring consistency and portability across different environments.

![1703426210710](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/71a1eb62-2c49-4b7b-9c02-5fc6225ebd1b)


## 𝗟𝗲𝗮𝗿𝗻 𝗔𝗯𝗼𝘂𝘁 𝘁𝗵𝗲 𝗗𝗶𝘃𝗲𝗿𝘀𝗲 𝗪𝗼𝗿𝗹𝗱 𝗼𝗳 𝗔𝗣𝗜 𝗣𝗿𝗼𝘁𝗼𝗰𝗼𝗹𝘀:

Let's dive into the world of API protocols, the hidden heroes behind the seamless flow of data and communication in our digital lives.

𝟭. 𝗚𝗿𝗮𝗽𝗵𝗤𝗟: Imagine a flexible way to request specific data from an API. That's GraphQL! It allows developers to tailor responses and optimize performance.

𝟮. 𝗪𝗲𝗯𝗵𝗼𝗼𝗸𝘀: Think of instant updates and notifications between systems. Webhooks use HTTP callbacks to make this happen, keeping everything in sync.

𝟯. 𝗥𝗘𝗦𝗧: This is the classic API design, built on simplicity and statelessness. It's the foundation for countless web applications and services.

𝟰. 𝗦𝗲𝗿𝘃𝗲𝗿-𝗦𝗲𝗻𝘁 𝗘𝘃𝗲𝗻𝘁𝘀 (𝗦𝗦𝗘): Experience real-time data updates with SSE. This lightweight protocol is ideal for dynamic content and instant information.

𝟱. 𝗘𝗹𝗲𝗰𝘁𝗿𝗼𝗻𝗶𝗰 𝗗𝗮𝘁𝗮 𝗜𝗻𝘁𝗲𝗿𝗰𝗵𝗮𝗻𝗴𝗲 (𝗘𝗗𝗜): Standardizes the exchange of business documents, making transactions smoother and faster.

𝟲. 𝗘𝘃𝗲𝗻𝘁-𝗗𝗿𝗶𝘃𝗲𝗻 𝗔𝗿𝗰𝗵𝗶𝘁𝗲𝗰𝘁𝘂𝗿𝗲 (𝗘𝗗𝗔): Systems communicate through events in this model, making them loosely coupled and scalable.

𝟳. 𝗪𝗲𝗯𝘀𝗼𝗰𝗸𝗲𝘁𝘀: Imagine real-time chat applications or collaborative editing. Websockets enable this by allowing two-way communication between clients and servers.

𝟴. 𝗦𝗶𝗺𝗽𝗹𝗲 𝗢𝗯𝗷𝗲𝗰𝘁 𝗔𝗰𝗰𝗲𝘀𝘀 𝗣𝗿𝗼𝘁𝗼𝗰𝗼𝗹 (𝗦𝗢𝗔𝗣): This protocol defines a set of structured rules for communication, making it reliable and secure for specific scenarios.

𝟵. 𝗴𝗥𝗣𝗖 (𝗥𝗲𝗺𝗼𝘁𝗲 𝗣𝗿𝗼𝗰𝗲𝗱𝘂𝗿𝗲 𝗖𝗮𝗹𝗹𝘀): High-performance and efficient, gRPC uses protocol buffers to facilitate faster communication between services.

𝟭𝟬. 𝗠𝗲𝘀𝘀𝗮𝗴𝗲 𝗤𝘂𝗲𝘂𝗶𝗻𝗴 𝗧𝗲𝗹𝗲𝗺𝗲𝘁𝗿𝘆 𝗧𝗿𝗮𝗻𝘀𝗽𝗼𝗿𝘁 (𝗠𝗤𝗧𝗧): This lightweight protocol excels in scenarios like IoT devices and low-latency communication.

𝟭𝟭. 𝗔𝗱𝘃𝗮𝗻𝗰𝗲𝗱 𝗠𝗲𝘀𝘀𝗮𝗴𝗲 𝗤𝘂𝗲𝘂𝗶𝗻𝗴 𝗣𝗿𝗼𝘁𝗼𝗰𝗼𝗹 (𝗔𝗠𝗤𝗣): Versatile and feature-rich, AMQP is ideal for building scalable and robust messaging systems.

![1702293451390](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/a4b42c15-27a6-404d-aba4-7f7dc06e4304)

## The Evolving Landscape of API Protocols in 2023
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/08a3bbc9-e8d2-4e7e-bd26-87261ecd415a)


## Docker's growing adoption 

Docker's growing adoption makes it a crucial skill across various tech roles - from developers to QA engineers.

Here's a neat guide to fundamental Docker concepts and commands, vital for anyone in tech today.

🔹 Setup & Image Management:
  - Build an image: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚋𝚞𝚒𝚕𝚍 -𝚝 𝚖𝚢𝚊𝚙𝚙 .
  - Fetch an image: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚙𝚞𝚕𝚕 𝚞𝚋𝚞𝚗𝚝𝚞
  - Store image remotely: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚙𝚞𝚜𝚑 𝚖𝚢𝚞𝚜𝚎𝚛/𝚖𝚢𝚊𝚙𝚙
  - List local images: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚒𝚖𝚊𝚐𝚎𝚜
  - Remove an image: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚛𝚖𝚒 𝚒𝚖𝚊𝚐𝚎_𝚗𝚊𝚖𝚎
  - Image layers history: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚑𝚒𝚜𝚝𝚘𝚛𝚢 𝚒𝚖𝚊𝚐𝚎_𝚗𝚊𝚖𝚎
  - Tag an image: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚝𝚊𝚐 𝚜𝚘𝚞𝚛𝚌𝚎_𝚒𝚖𝚊𝚐𝚎 𝚝𝚊𝚛𝚐𝚎𝚝_𝚒𝚖𝚊𝚐𝚎
  - Save image to file: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚜𝚊𝚟𝚎 -𝚘 𝚘𝚞𝚝𝚙𝚞𝚝𝚏𝚒𝚕𝚎.𝚒𝚖𝚐 𝚖𝚢𝚒𝚖𝚊𝚐𝚎
  - Load image from file: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚕𝚘𝚊𝚍 -𝚒 𝚒𝚗𝚙𝚞𝚝𝚏𝚒𝚕𝚎.𝚒𝚖𝚐

🔹 Running & Managing Containers:
  - Start a container: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚛𝚞𝚗 𝚒𝚖𝚊𝚐𝚎_𝚗𝚊𝚖𝚎
  - Stop a container: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚜𝚝𝚘𝚙 𝚌𝚘𝚗𝚝𝚊𝚒𝚗𝚎𝚛_𝚒𝚍
  - Force stop a container: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚔𝚒𝚕𝚕 𝚌𝚘𝚗𝚝𝚊𝚒𝚗𝚎𝚛_𝚒𝚍
  - Restart a container: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚛𝚎𝚜𝚝𝚊𝚛𝚝 𝚌𝚘𝚗𝚝𝚊𝚒𝚗𝚎𝚛_𝚒𝚍
  - Rename a container: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚛𝚎𝚗𝚊𝚖𝚎 𝚘𝚕𝚍_𝚗𝚊𝚖𝚎 𝚗𝚎𝚠_𝚗𝚊𝚖𝚎
  - View container logs: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚕𝚘𝚐𝚜 𝚌𝚘𝚗𝚝𝚊𝚒𝚗𝚎𝚛_𝚒𝚍
  - Interact with container: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚎𝚡𝚎𝚌 -𝚒𝚝 𝚌𝚘𝚗𝚝𝚊𝚒𝚗𝚎𝚛_𝚒𝚍 𝚋𝚊𝚜𝚑
  - Pause container: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚙𝚊𝚞𝚜𝚎 𝚌𝚘𝚗𝚝𝚊𝚒𝚗𝚎𝚛_𝚒𝚍
  - Resume container: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚞𝚗𝚙𝚊𝚞𝚜𝚎 𝚌𝚘𝚗𝚝𝚊𝚒𝚗𝚎𝚛_𝚒𝚍

🔹 Network & Storage:
  - List networks: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚗𝚎𝚝𝚠𝚘𝚛𝚔 𝚕𝚜
  - Create a volume: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚟𝚘𝚕𝚞𝚖𝚎 𝚌𝚛𝚎𝚊𝚝𝚎 𝚖𝚢𝚟𝚘𝚕𝚞𝚖𝚎
  - List volumes: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚟𝚘𝚕𝚞𝚖𝚎 𝚕𝚜

🔹 Clean-up & Maintenance:
  - Clean up resources: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚜𝚢𝚜𝚝𝚎𝚖 𝚙𝚛𝚞𝚗𝚎
  - Delete a container: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚛𝚖 𝚌𝚘𝚗𝚝𝚊𝚒𝚗𝚎𝚛_𝚒𝚍
  - Container details: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚒𝚗𝚜𝚙𝚎𝚌𝚝 𝚌𝚘𝚗𝚝𝚊𝚒𝚗𝚎𝚛_𝚒𝚍
  - Real-time stats: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚜𝚝𝚊𝚝𝚜
  - List running containers: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚙𝚜
  - List all containers: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚙𝚜 -𝚊

🔹 Docker Compose (Multiple Containers):
  - Start multi-container app: 𝚍𝚘𝚌𝚔𝚎𝚛-𝚌𝚘𝚖𝚙𝚘𝚜𝚎 𝚞𝚙
  - Stop services: 𝚍𝚘𝚌𝚔𝚎𝚛-𝚌𝚘𝚖𝚙𝚘𝚜𝚎 𝚜𝚝𝚘𝚙
  - Remove resources: 𝚍𝚘𝚌𝚔𝚎𝚛-𝚌𝚘𝚖𝚙𝚘𝚜𝚎 𝚍𝚘𝚠𝚗
  - View logs: 𝚍𝚘𝚌𝚔𝚎𝚛-𝚌𝚘𝚖𝚙𝚘𝚜𝚎 𝚕𝚘𝚐𝚜
  - Restart services: 𝚍𝚘𝚌𝚔𝚎𝚛-𝚌𝚘𝚖𝚙𝚘𝚜𝚎 𝚛𝚎𝚜𝚝𝚊𝚛𝚝

🔹 Advanced Utilities & Miscellaneous:
  - Copy files from container: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚌𝚙 𝚌𝚘𝚗𝚝𝚊𝚒𝚗𝚎𝚛_𝚒𝚍:/𝚙𝚊𝚝𝚑
  - Changes in FS: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚍𝚒𝚏𝚏 𝚌𝚘𝚗𝚝𝚊𝚒𝚗𝚎𝚛_𝚒𝚍
  - Running processes: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚝𝚘𝚙 𝚌𝚘𝚗𝚝𝚊𝚒𝚗𝚎𝚛_𝚒𝚍
  - Search Docker Hub: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚜𝚎𝚊𝚛𝚌𝚑 𝚝𝚎𝚛𝚖
  - Public ports: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚙𝚘𝚛𝚝 𝚌𝚘𝚗𝚝𝚊𝚒𝚗𝚎𝚛_𝚒𝚍
  - Docker Hub login: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚕𝚘𝚐𝚒𝚗
  - Docker Hub logout: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚕𝚘𝚐𝚘𝚞𝚝

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/878eaffb-79c2-4d14-b833-a25c10bc15b7)

## Docker Architecture and Components
1. Docker Daemon (`dockerd`):
- 𝗥𝗼𝗹𝗲: Manages Docker containers on a system.
- 𝗥𝗲𝘀𝗽𝗼𝗻𝘀𝗶𝗯𝗶𝗹𝗶𝘁𝗶𝗲𝘀: Building, running, and managing containers.
  
2. Docker Client (`docker`):
- 𝗥𝗼𝗹𝗲: Interface through which users interact with Docker.
- 𝗖𝗼𝗺𝗺𝗮𝗻𝗱𝘀: build, pull, run, etc.
  
3. Docker Images:
- 𝗗𝗲𝗳𝗶𝗻𝗶𝘁𝗶𝗼𝗻: Read-only templates used to create containers.
- 𝗥𝗼𝗹𝗲: Serve as the basis for creating containers.
- 𝗥𝗲𝗴𝗶𝘀𝘁𝗿𝘆/𝗛𝘂𝗯: A storage and distribution system for Docker images.

4. Docker Containers:
- 𝗗𝗲𝗳𝗶𝗻𝗶𝘁𝗶𝗼𝗻: Runnable instances of Docker images.
- 𝗥𝗼𝗹𝗲: Encapsulate the application and its environment.

5. Docker Registry:
- 𝗥𝗼𝗹𝗲: Store Docker images.
- 𝗣𝘂𝗯𝗹𝗶𝗰 𝗥𝗲𝗴𝗶𝘀𝘁𝗿𝘆: Docker Hub.
- 𝗣𝗿𝗶𝘃𝗮𝘁𝗲 𝗥𝗲𝗴𝗶𝘀𝘁𝗿𝘆: Can be hosted by users.


Docker Workflow

A. Development Phase

1. 𝗪𝗿𝗶𝘁𝗲 𝗖𝗼𝗱𝗲:
   - Developers write code locally.
   
2. 𝗕𝘂𝗶𝗹𝗱 𝗗𝗼𝗰𝗸𝗲𝗿 𝗜𝗺𝗮𝗴𝗲:
   - 𝗗𝗼𝗰𝗸𝗲𝗿𝗳𝗶𝗹𝗲: A script with instructions to create a Docker image.
   - 𝗖𝗼𝗺𝗺𝗮𝗻𝗱: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚋𝚞𝚒𝚕𝚍 -𝚝 𝚖𝚢-𝚒𝚖𝚊𝚐𝚎 .
   
3. 𝗧𝗲𝘀𝘁 𝗟𝗼𝗰𝗮𝗹𝗹𝘆:
   - Run the application inside a Docker container locally.
   - 𝗖𝗼𝗺𝗺𝗮𝗻𝗱: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚛𝚞𝚗 𝚖𝚢-𝚒𝚖𝚊𝚐𝚎
   
B. Share/Deploy Phase

4. 𝗣𝘂𝘀𝗵 𝗜𝗺𝗮𝗴𝗲 𝘁𝗼 𝗥𝗲𝗴𝗶𝘀𝘁𝗿𝘆:
   - Push the Docker image to a registry (Docker Hub, AWS ECR, etc.).
   - 𝗖𝗼𝗺𝗺𝗮𝗻𝗱: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚙𝚞𝚜𝚑 𝚖𝚢-𝚒𝚖𝚊𝚐𝚎
   
5. 𝗗𝗲𝗽𝗹𝗼𝘆 𝗼𝗻 𝗮 𝗦𝗲𝗿𝘃𝗲𝗿/𝗖𝗹𝘂𝘀𝘁𝗲𝗿:
   - Pull the Docker image from the registry.
   - 𝗖𝗼𝗺𝗺𝗮𝗻𝗱: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚙𝚞𝚕𝚕 𝚖𝚢-𝚒𝚖𝚊𝚐𝚎
   - Run the container on a server or a cluster (like Kubernetes).
   - 𝗖𝗼𝗺𝗺𝗮𝗻𝗱: 𝚍𝚘𝚌𝚔𝚎𝚛 𝚛𝚞𝚗 𝚖𝚢-𝚒𝚖𝚊𝚐𝚎

C. CI/CD Integration

6. 𝗖𝗼𝗻𝘁𝗶𝗻𝘂𝗼𝘂𝘀 𝗜𝗻𝘁𝗲𝗴𝗿𝗮𝘁𝗶𝗼𝗻 (𝗖𝗜):
   - Integrate code changes and build the Docker image.
   - Push the built image to a registry.
   
7. 𝗖𝗼𝗻𝘁𝗶𝗻𝘂𝗼𝘂𝘀 𝗗𝗲𝗽𝗹𝗼𝘆𝗺𝗲𝗻𝘁 (𝗖𝗗):
   - Deploy the Docker image from the registry to production environments.
   
D. Scaling & Management

8. 𝗦𝗰𝗮𝗹𝗶𝗻𝗴:
   - Increase or decrease the number of running containers based on demand.
   
9. 𝗠𝗼𝗻𝗶𝘁𝗼𝗿𝗶𝗻𝗴 & 𝗟𝗼𝗴𝗴𝗶𝗻𝗴:
   - Track the performance and logs of running containers.

10. 𝗨𝗽𝗱𝗮𝘁𝗲 & 𝗥𝗼𝗹𝗹𝗯𝗮𝗰𝗸:
   - Deploy updates by pushing new Docker images to the registry and updating running containers.
   - Rollback to a previous version if needed by running containers from an older Docker image.

E. Networking & Storage

11. 𝗡𝗲𝘁𝘄𝗼𝗿𝗸𝗶𝗻𝗴:
   - Manage communication between containers and the outside world.

12. 𝗦𝘁𝗼𝗿𝗮𝗴𝗲:
   - Manage data and persist state using volumes.
![1699974906033](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/d1e6633d-cb12-49b0-90d0-a9b0e1b65887)

## Log Parsing Cheatsheet
In the IT industry, the fundamental skill of log parsing remains as vital as ever.

It's the backbone of troubleshooting, security analysis, and system monitoring.

To aid in this crucial task, I've compiled a comprehensive Log Parsing Cheatsheet that is perfect for IT professionals of all stripes.

Here’s a breakdown of each command and how you can use it:

🔎 𝗛𝗘𝗔𝗗: 𝚑𝚎𝚊𝚍 𝚏𝚒𝚕𝚎.𝚕𝚘𝚐 gives you the top ten lines of a file, which is often where critical recent error logs can be found. For instance, 𝚑𝚎𝚊𝚍 -𝚗 𝟸𝟶 𝚏𝚒𝚕𝚎.𝚕𝚘𝚐 displays the first 20 lines.

🔍 𝗧𝗔𝗜𝗟: 𝚝𝚊𝚒𝚕 𝚏𝚒𝚕𝚎.𝚕𝚘𝚐 does the opposite, showing you the last ten lines of a file — where the most recent events are logged. Try 𝚝𝚊𝚒𝚕 -𝚏 𝚏𝚒𝚕𝚎.𝚕𝚘𝚐 to get a real-time stream of log updates.

🔄 𝗖𝗢𝗠𝗠: 𝚌𝚘𝚖𝚖 𝚏𝚒𝚕𝚎𝟷.𝚕𝚘𝚐 𝚏𝚒𝚕𝚎𝟸.𝚕𝚘𝚐 helps you compare two sorted files. It's perfect for finding discrepancies between log versions, like 𝚌𝚘𝚖𝚖 -𝟹 𝚜𝚎𝚛𝚟𝚎𝚛𝟷.𝚕𝚘𝚐 𝚜𝚎𝚛𝚟𝚎𝚛𝟸.𝚕𝚘𝚐 to see lines unique to each.

🔣 𝗟𝗘𝗦𝗦: 𝚕𝚎𝚜𝚜 𝚏𝚒𝚕𝚎.𝚕𝚘𝚐 allows for on-the-fly viewing of large log files. Navigate with 𝙶, 𝚐𝚐, and /𝚜𝚎𝚊𝚛𝚌𝚑_𝚝𝚎𝚛𝚖.

📊 𝗖𝗦𝗩𝗞𝗜𝗧: 𝚌𝚜𝚟𝚌𝚞𝚝 -𝚌 𝟹 𝚍𝚊𝚝𝚊.𝚌𝚜𝚟 can extract columns from CSVs. For example, 𝚌𝚜𝚟𝚌𝚞𝚝 -𝚗 𝚍𝚊𝚝𝚊.𝚌𝚜𝚟 lists column names.

📑 𝗝𝗤: 𝚓𝚚 .𝚏𝚘𝚘 𝚍𝚊𝚝𝚊.𝚓𝚜𝚘𝚗 is for JSON parsing — invaluable for modern web app logs. Use 𝚓𝚚 '.[] | .𝚗𝚊𝚖𝚎' 𝚞𝚜𝚎𝚛𝚜.𝚓𝚜𝚘𝚗 to extract user names from a list.

🔍 𝗚𝗥𝗘𝗣: 𝚐𝚛𝚎𝚙 '𝚎𝚛𝚛𝚘𝚛' 𝚏𝚒𝚕𝚎.𝚕𝚘𝚐 finds all occurrences of 'error' in a file. Advanced usage like 𝚐𝚛𝚎𝚙 -𝙴 "𝟺[𝟶-𝟿]{𝟸}" 𝚏𝚒𝚕𝚎.𝚕𝚘𝚐 finds all 400-level errors in HTTP logs.

📡 𝗡𝗚𝗥𝗘𝗣: 𝚗𝚐𝚛𝚎𝚙 -𝚍 𝚎𝚝𝚑𝟶 '𝟺𝟶𝟺' 𝚙𝚘𝚛𝚝 𝟾𝟶 listens on the network for specific data, useful for real-time traffic analysis.

🔧 𝗧𝗥: 𝚝𝚛 '[:𝚕𝚘𝚠𝚎𝚛:]' '[:𝚞𝚙𝚙𝚎𝚛:]' < 𝚏𝚒𝚕𝚎.𝚝𝚡𝚝 transforms lowercase to uppercase. Remove duplicates with 𝚝𝚛 -𝚜 '\𝚗'.

🔪 𝗖𝗨𝗧: 𝚌𝚞𝚝 -𝚍 ',' -𝚏 𝟸 𝚏𝚒𝚕𝚎.𝚕𝚘𝚐 can parse fields from delimited logs, making it simple to see specific data columns.

🔨 𝗦𝗘𝗗: 𝚜𝚎𝚍 '𝚜/𝚘𝚕𝚍/𝚗𝚎𝚠/𝚐' 𝚏𝚒𝚕𝚎.𝚕𝚘𝚐 finds and replaces text — 𝚜𝚎𝚍 '/^$/𝚍' 𝚏𝚒𝚕𝚎.𝚕𝚘𝚐 removes empty lines.

🔢 𝗦𝗢𝗥𝗧: 𝚜𝚘𝚛𝚝 𝚏𝚒𝚕𝚎.𝚝𝚡𝚝 sorts text files line by line. For numeric sort, use 𝚜𝚘𝚛𝚝 -𝚗 𝚏𝚒𝚕𝚎.𝚝𝚡𝚝.

🌟 𝗨𝗡𝗜𝗤: 𝚞𝚗𝚒𝚚 -𝚌 𝚏𝚒𝚕𝚎.𝚝𝚡𝚝 counts and removes duplicates. Case-insensitive search can be done using 𝚞𝚗𝚒𝚚 -𝚒 𝚏𝚒𝚕𝚎.𝚝𝚡𝚝.

📃 𝗗𝗜𝗙𝗙: 𝚍𝚒𝚏𝚏 𝚏𝚒𝚕𝚎𝟷.𝚕𝚘𝚐 𝚏𝚒𝚕𝚎𝟸.𝚕𝚘𝚐 compares files line by line, crucial for version differences.

🖋️ 𝗔𝗪𝗞: 𝚊𝚠𝚔 '{𝚙𝚛𝚒𝚗𝚝 $𝟸}' 𝚏𝚒𝚕𝚎.𝚕𝚘𝚐 prints the second word in each line. It’s perfect for text processing scripts, like summarizing logs.

## HTTPS encryption

![1699473793533](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/3def4dca-d6be-4739-b46c-5d6366bb76d5)

## API Courses
As we approach the year's end, I'm sharing one last time the free courses that have already empowered numerous individuals.

I've invested a considerable amount of time crafting a series of  API courses designed to not only elevate your skill set but also ensure you're primed for success in interviews and beyond.

These courses are tailored to provide you with the key skills that will distinguish you in the competitive tech landscape.

If you're looking to demystify APIs and gain a clear understanding, these resources are for you.


 1. 𝗔𝗣𝗜 𝗙𝘂𝗻𝗱𝗮𝗺𝗲𝗻𝘁𝗮𝗹𝘀: https://lnkd.in/e8eMet_k
 2. 𝗔𝗣𝗜 𝗦𝗶𝗺𝗽𝗹𝗶𝗳𝗶𝗲𝗱: https://lnkd.in/er9JiGxw
 3. 𝗔𝗣𝗜 𝗠𝗲𝘁𝗵𝗼𝗱𝘀: https://lnkd.in/ey9v7-hU
 4. 𝗔𝗣𝗜 𝗧𝗲𝗿𝗺𝗶𝗻𝗼𝗹𝗼𝗴𝗶𝗲𝘀: https://lnkd.in/eRsPMzpd
 5. 𝗔𝗣𝗜 𝗔𝘂𝘁𝗵𝗲𝗻𝘁𝗶𝗰𝗮𝘁𝗶𝗼𝗻: https://lnkd.in/eNPfpAdE
 6. 𝗔𝗣𝗜 𝗦𝘁𝗮𝘁𝘂𝘀 𝗖𝗼𝗱𝗲𝘀: https://lnkd.in/egXizUrS
 7. 𝗥𝗘𝗦𝗧 𝗔𝗣𝗜 𝘃𝘀 𝗚𝗿𝗮𝗽𝗵𝗤𝗟: https://lnkd.in/eZHREdgC
 8. 𝗔𝗣𝗜 𝗜𝗻𝘁𝗲𝗴𝗿𝗮𝘁𝗶𝗼𝗻: https://lnkd.in/eDASPP5m
 9. 𝗔𝗣𝗜 𝗜𝗻𝘁𝗲𝗴𝗿𝗮𝘁𝗶𝗼𝗻 𝗶𝗻 𝗗𝗲𝘁𝗮𝗶𝗹: https://lnkd.in/eZwFVrH7
10. 𝗔𝗣𝗜 𝗧𝗲𝘀𝘁𝗶𝗻𝗴: https://lnkd.in/emgmWJqH
11. 𝗔𝗣𝗜 𝘄𝗶𝘁𝗵 𝗣𝘆𝘁𝗵𝗼𝗻: https://lnkd.in/eM23ah2y
12. 𝗔𝗣𝗜 𝗦𝗰𝗮𝗹𝗶𝗻𝗴: https://lnkd.in/e3mZSvmn
13. 𝗗𝗲𝘃𝗲𝗹𝗼𝗽𝗶𝗻𝗴 𝗥𝗼𝗯𝘂𝘀𝘁 𝗔𝗣𝗜𝘀: https://lnkd.in/eBXzbFyg
14. 𝗔𝗣𝗜𝘀 𝘄𝗶𝘁𝗵 𝗣𝗼𝘀𝘁𝗺𝗮𝗻: https://lnkd.in/ezue3d4B
15. 𝗧𝗲𝘀𝘁𝗶𝗻𝗴 𝗔𝗣𝗜𝘀 𝘄𝗶𝘁𝗵 𝗣𝗼𝘀𝘁𝗺𝗮𝗻: https://lnkd.in/eCPnGTGi
16. 𝗔𝗣𝗜 𝗦𝗲𝗰𝘂𝗿𝗶𝘁𝘆: https://lnkd.in/e79ZYfPa
17. 𝗔𝗣𝗜𝘀 𝗳𝗼𝗿 𝗘𝘃𝗲𝗿𝘆𝗼𝗻𝗲: https://lnkd.in/e4WGDffA

## Elevate Your Software Development with REST APIs
Elevate Your Software Development with REST APIs


In the dynamic world of technology, Application Programming Interfaces (APIs) are the linchpin, enabling seamless communication between applications. REST APIs, known for their simplicity and scalability, stand out as key facilitators of innovation.

Understanding APIs and REST:
APIs empower developers to integrate systems, enhance functionalities, and foster innovation. REST APIs, with their flexibility and stateless nature, have gained widespread popularity in facilitating seamless data exchange.

Key Principles for REST API Design:

REST Methods: Utilize standard HTTP methods (GET, POST, PUT, DELETE) for specific purposes.
Cacheable: Optimize performance by allowing responses to be cached.
Stateless: Each client request contains all necessary information, ensuring no server-side storage of client state.
Simple & Fine-Grained: Design should offer fine-grained control over resources for efficient manipulation.
Pagination, Filtering, Ordering: Support for handling large datasets and flexible data retrieval.
Connectedness: Resources should be interconnected, promoting discoverability.
Security: Implement secure authentication and authorization mechanisms for data protection.


Best Practices for Implementation:

Versioning: Support versioning to manage changes without breaking existing client implementations.
Self-Descriptive Messages: Responses include metadata for better understanding and utilization.
HATEOAS: Promote API discoverability by allowing clients to navigate through resource representations.
Layered System & Uniform Interface: Enhance modularity and user experience through a consistent and layered design.
CORS & Idempotence: Enable controlled cross-origin resource sharing and ensure predictability in operations.
Authentication, Logging, Input Validations: Prioritize security, reliability, and data integrity.
TLS & Rate Limiting: Encrypt communication and implement rate limiting for performance and security.

Conclusion:
Designing a robust REST API is an art that shapes the interconnected landscape of the digital world. These principles serve as a comprehensive guide for architects and developers, unlocking the true potential of REST APIs. As technology advances, well-designed APIs will continue to drive innovation and evolution in modern applications.

![1700221799574](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/77328784-8afe-410f-bf58-f0100858bd77)

## Session, Cookie, JWT, Token, SSO, and OAuth 2.0 Explained in One Diagram

![1700239541390](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/0889ccd1-21be-445a-977d-d852d101c2a9)

## 🌐 Spring Security Architecture Overview 🛡️
🏰 Key Components:

1. Authentication Manager 🤝:
- Responsible for validating user credentials.
- Utilizes various authentication providers (e.g., LDAP, JDBC).

2. Security Context 🧑‍💼:
- Stores details of the currently authenticated user.
- Ensures security information is accessible throughout the application.

3. Authentication Provider 🔒:
- Implements the actual authentication process.
- Supports multiple authentication mechanisms (e.g., username/password, OAuth).

4. UserDetailsService 👩‍💼:
- Retrieves user-related information (like roles and permissions) from the data store.

5. Authorization 🚦:
- Controls access to specific resources based on user roles and permissions.
- Uses access control expressions (ACL) for fine-grained authorization.

🔄 Authentication Flow:

1. Filter Chain 🔄:
- Requests pass through a series of filters.
- Each filter handles a specific aspect of the authentication process.

2. Username and Password Authentication 🔑:
- Typical login involves the `UsernamePasswordAuthenticationFilter`.
- Validates user credentials against the `AuthenticationManager`.

3. Token-Based Authentication 🎫:
- Enables stateless authentication using tokens (e.g., JWT).
- Great for microservices architecture.

🚀 Customization and Extensibility:

1. Configurer Interface ⚙️:
- Allows easy customization of security settings.
- Implement `WebSecurityConfigurerAdapter` for more advanced configurations.

2. Custom Authentication Providers 🛠️:
- Implement your custom logic by extending `AuthenticationProvider`.

🌐 Conclusion:

Spring Security provides a robust and flexible security framework for Java applications. Understanding its architecture empowers developers to build secure and scalable systems. 💪✨

![1699964498730](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/21ae7e59-03c8-4149-8fca-abcac7d9cb9f)

## Single Sign-On (SSO) explained in simple terms.
The concepts of SSO revolve around the three key players: the User, the Identity Provider (IDP), and the Application.

1. The end-user or individual who seeks access to various applications.

2. Identity Provider (IDP): An entity responsible for user authentication and verification. Common IDPs include Google, Facebook, and company-specific systems.

3. Application: The software or service that the user wants to access. Applications rely on the IDP for user authentication. With SSO, users can seamlessly log in to various applications with a single set of credentials, enhancing convenience and security.

Single Sign-On (SSO) simplifies user access by enabling them to log in to multiple applications with a single set of credentials, enhancing the user experience and reducing password fatigue. It also centralizes security and access management, improving security, streamlining access control, and saving time and costs.

Over to you: What's your perspective on the future of secure authentication in the digital realm?

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/2d03a4b8-053d-4c20-8606-41e342ff12d5)

## Imperative Vs Functional Vs Object-oriented Programming

In software development, different programming paradigms offer unique ways to structure code. Three main paradigms are Imperative, Functional, and Object-oriented programming, each with distinct approaches to problem-solving.

1. Imperative Programming:
- Works by changing program state through a sequence of commands.
- Uses control structures like loops and conditional statements for execution flow.
- Emphasizes on mutable data and explicit steps for task completion.
- Examples: C, Python, and most procedural languages.

2. Functional Programming:
- Relies on pure functions, emphasizing computation without side effects.
- Promotes immutability and the avoidance of mutable state.
- Supports higher-order functions, recursion, and declarative programming.
- Examples: Haskell, Lisp, Scala, and functional features in languages like JavaScript.

3. Object-oriented Programming:
- Focuses on modeling real-world entities as objects, containing data and methods.
- Encourages concepts such as inheritance, encapsulation, and polymorphism.
- Utilizes classes, objects, and interfaces to structure code.
- Examples: Java, C++, Python, and Ruby.

Over to you: Which one resonates with your coding style? Ever had an 'aha' moment while using a particular paradigm? Share your perspective.
![1699893935849](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/0615fd24-2448-49e5-bed7-be3f16fb6737)

## Docker Key Commands Map 👇
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/13b9329c-fa00-4d75-ad77-7dc1fb8239c3)

## How do we design effective and safe APIs?
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/38c38c67-2af1-4e8b-a4d9-3fb33ddeb582)

## Github Repos to Become Master in React
1 Under the Hood React JS

https://lnkd.in/d2PVfbFS

2 Roadmap to becoming a React developer : https://lnkd.in/d5tGtcvj

3 Curated List of React Components & Libraries : https://lnkd.in/dMUWujd5

4 Higher-Order Components for React

https://lnkd.in/dwecQ_ZC

5 Beautiful React Hooks: https://lnkd.in/dVJdQG3m

6 Cheatsheets for experienced React developers getting started with TypeScript

https://lnkd.in/dFfuPqiA

7 30 Seconds of React : https://lnkd.in/dy-MWrgW

8 React Redux Links : https://lnkd.in/dZWje8S4

9 Bullet Proof React : https://lnkd.in/dqKvEFaa

## 🐧 Understanding Linux File Permissions 🚀
🐧 Understanding Linux File Permissions 🚀

In the Linux world, file permissions are like the gatekeepers of your data fortress! They control who can enter, read, write, or execute files and directories. Let's break it down:

1. Command Structure:
- 🕹️ `chmod`: Stands for "change mode," the command to tweak permissions.
- 📚 `r` (read), 📝 `w` (write), and 🏃 `x` (execute) are the three permission types.

2. Permission Levels:
- 🤴 Owner: The file's creator.
- 🌍 Group: Users in the file's group.
- 🌐 Others: The rest of the world.

3. Numeric Notation:
- 📊 Each permission has a numeric value: 📖 `r` (read) = 4, 📝 `w` (write) = 2, 🏃 `x` (execute) = 1.
- 🤯 Combine them to set permissions. For example, read and execute (rx) = 5, read and write (rw) = 6, all permissions (rwx) = 7.

4. Setting Permissions:
- 🛠️ `chmod` is used like this: `chmod [permissions] [file/directory]`.
- 🚧 Example: `chmod 755 myfile` grants read, write, and execute to the owner, and read/execute to the group and others.

5. Symbolic Notation:
- 🧩 `u` (user/owner), 🤝 `g` (group), and 🌍 `o` (others) are used in symbolic notation.
- 🌈 `+` adds, `-` removes, and `=` sets permissions.
- 📝 Example: `chmod u+x myfile` adds execute permission for the owner.

![1699571091120](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/cca5e335-e7ed-4c14-a8cf-5fa29b05e545)

## Most used design patterns

Ever wondered how top-notch software architects build robust and scalable systems? Look no further! Here are the 10 most used design patterns that can elevate your coding game:

1 Singleton Pattern: Ensure a class has only one instance and provide a global point of access. Perfect for managing a unique resource, like a configuration manager.

2 Factory Pattern: Create objects without specifying their exact class. Ideal for creating families of related or dependent objects.

3 Adapter Pattern: Bridge the gap between two incompatible interfaces. Think of it as a language translator for objects!

4 Facade Pattern: Provide a simplified interface to a set of interfaces, making complex systems more manageable. Like a one-stop-shop for subsystems.

5 Decorator Pattern: Attach additional responsibilities to an object dynamically. Great for adding features to objects without altering their structure.

6 Proxy Pattern: Control access to an object by acting as a placeholder. Handy for scenarios like lazy loading or access control.

7 Command Pattern: Encapsulate a request as an object, allowing parameterization of clients with different requests and queuing of requests. Perfect for command queues and undo functionalities.

8 Template Pattern: Define the skeleton of an algorithm in the superclass but let subclasses override specific steps. Useful for implementing algorithms with shared steps.

9 Strategy Pattern: Define a family of algorithms, encapsulate each one, and make them interchangeable. Useful when you want to switch algorithms at runtime.

10 Observer Pattern: Define a one-to-many dependency between objects, ensuring that when one object changes state, all its dependents are notified and updated. Think of it as subscribing to updates.

Each pattern comes with its own superpower in solving specific problems. Mastering these design patterns can level up your software architecture game!

What's your favorite design pattern, and how have you applied it in your projects? Share your thoughts below!
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/0873fd61-2ba9-4453-96ad-f7a27f9a918f)

## Understanding OAuth
OAuth is an open standard that allows users to grant limited access to their data on one site to other sites or applications without exposing their passwords. It has become the backbone of secure authorization across the web and mobile apps.

The OAuth ecosystem

OAuth connects three main players:

- The User who wants to grant access to their data without sharing login credentials
- The Server that hosts the user's data and provides access tokens
- The Identity Provider (IdP) that authenticates the user's identity and issues tokens

How OAuth works

When a user tries to access their data through a third-party app, they are redirected to log in through the IdP. The IdP sends an access token to the app, which presents it to the server. Recognizing the valid token, the server grants access.

The OAuth flows

OAuth 2.0 defines four flows for obtaining authorization tokens:

- Authorization Code Flow - for server-side applications
- Client Credentials Flow - when the app is the resource owner
- Implicit Code Flow - not secure and no longer recommended
- Resource Owner Flow - for trusted apps using owner credentials

Key benefits

- Enhances user experience by eliminating multiple passwords
- Allows secure data access across platforms using tokens
- Balances accessibility and security

OAuth 2.0 has become the standard for authorization. It enables secure, convenient data sharing while protecting user accounts.
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/dd38cec9-57f3-41cd-9f37-0d7da694b033)

## AWS Security Reference Architecture!
In the ever-changing world of cloud computing, security is a top priority for businesses of all sizes. The AWS Security Reference Architecture (AWS SRA) provides a comprehensive framework for designing, building, and managing secure cloud environments. This detailed architecture gives a complete picture of security controls and services across multiple organizational units (OUs) and accounts, making sure that security is built into the entire cloud infrastructure.

Key Highlights of the AWS SRA

💥Comprehensive Coverage: The AWS SRA encompasses a wide range of security services, including identity and access management, network security, data protection, and threat detection.

💥Modular Design: The architecture is divided into distinct OUs and accounts, each with specific security objectives and associated services.

💥Customization Options: The AWS SRA provides flexibility to tailor security implementations to unique organizational requirements and risk profiles.

Benefits of Adopting the AWS SRA:

✅Enhanced Security Posture: The AWS SRA helps organizations achieve a robust security posture by providing a comprehensive and well-structured approach to cloud security.

✅Simplified Security Management: The modular design and clear guidelines simplify the management of security controls across multiple cloud accounts.

✅Reduced Security Risks: By implementing the AWS SRA, organizations can effectively mitigate security risks and protect their sensitive data and applications.

✅Embracing Security in the Cloud:
The AWS SRA serves as a valuable resource for organizations seeking to establish and maintain a secure cloud environment.

![1699413574428](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/a73bc66d-3db8-412e-8ff5-5c5b64ff0836)

## Software Production Release Step by Step Guide
1. Planning:
- Identify the goals and features for the upcoming release.
- Prioritize tasks based on importance and dependencies.
- Define timelines and allocate resources accordingly.

2. Development:
- Programmers start coding based on the planned features.
- Regular code reviews and collaboration to maintain code quality.
- Version control systems track changes for better collaboration.

3. Building Artifact:
- Compile the source code into executable or deployable artifacts.
- Generate documentation and other necessary files.
- Automation tools can be used to streamline this process.

4. Testing:
- Conduct various levels of testing (unit, integration, system, etc.).
- Identify and fix bugs or issues.
- Ensure compatibility with different platforms and configurations.

5. Environments
- Set up different environments for development, testing, and production.
- Ensure consistency across environments to minimize deployment issues.
- Monitor and troubleshoot any discrepancies between environments.

6. Release:
- Once testing is successful, prepare for the release.
- Generate release notes documenting changes and updates.
- Coordinate with other teams for a smooth rollout.
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/fc09c94a-53fc-4e9f-986f-fcaebc44dabb)

## 8 Essential Internet Protocols You Must Know
8 Essential Internet Protocols You Must Know

▷ HTTP (Hypertext Transfer Protocol) is a standard for transmitting web content over the internet.

▷ HTTPS (Hypertext Transfer Protocol Secure) is a secure version of HTTP that encrypts data for safe web communication.

▷ TCP (Transmission Control Protocol) is a reliable, connection-oriented protocol for transmitting data over networks, ensuring data delivery.

▷ IP (Internet Protocol) is a set of rules governing the routing and addressing of data packets across the internet.

▷ FTP (File Transfer Protocol) is used to transfer files between computers on a network or over the internet.

▷ SSH (Secure Shell) is a secure protocol for remote access to network devices and servers.

▷ SMTP (Simple Mail Transfer Protocol) is used for sending email messages between email servers.

▷ UDP (User Datagram Protocol) is a connectionless and faster protocol for transmitting data over networks, but it doesn't guarantee delivery.

![1699312494770](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/c1c1de75-91ce-4bde-ba25-7025dfa91086)

## Improving API performance
Improving API performance is crucial for delivering a seamless and efficient user experience. Here are the top 6 approaches to achieve a 10x improvement in API performance:

Caching: Implementing caching mechanisms can significantly boost API performance. Cache frequently accessed data or responses, reducing the load on your servers. Use in-memory caches like Redis or Memcached for high-speed data retrieval.

Connection Pooling: Maintaining a connection pool helps manage and reuse database connections efficiently. This minimizes the overhead of establishing new connections for every API request, enhancing performance.

Pagination: When dealing with large datasets, implement pagination to limit the amount of data returned in a single response. This reduces the payload size and response time, making the API more responsive.

Payload Compression: Compressing API responses, such as using GZIP or Brotli, reduces the amount of data transferred over the network. Smaller payloads result in faster response times and lower bandwidth usage.

Load Balancer: Distribute incoming API requests across multiple servers or instances using a load balancer. This ensures even distribution of traffic, prevents overloading of any single server, and provides redundancy for improved reliability.

Avoid N+1 Problem: When fetching related data, avoid the N+1 query problem. Use techniques like eager loading or GraphQL to fetch all required data in a single request, reducing the number of database queries and improving response times.
If you're new to these terms or looking to dive deeper, give this a ❤️ and share!
Together, we can make tech jargon easier to grasp for everyone. 🌍

💁‍♂️Are you ready to take that pivotal step towards landing your dream job? Look no further than NextLevel (https://lnkd.in/dZCPrEez) – your ultimate gateway to career success!

![1699104673502](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/331f3f5e-7425-4eff-b284-72abcfae2ef4)

## Don't only apply for the job but also ensure to establish a network with the recruiter for the future.
Interview Mail Tips-

You can achieve this by sending thoughtful emails.

✅ 𝗔𝗽𝗽𝗹𝘆𝗶𝗻𝗴 𝗳𝗼𝗿 𝗷𝗼𝗯 𝗘𝗺𝗮𝗶𝗹:

𝗦𝘂𝗯𝗷𝗲𝗰𝘁: Application for [Job Title] - [Your Name]

Dear [Hiring Manager's Name],

I hope this message finds you well. I am writing to express my interest in the [Job Title] position at [Company Name] that I recently came across. I believe my skills and experience align well with the requirements of the role.

With a background in [Relevant Skills/Experience], I am excited about the opportunity to contribute to [Company Name]'s [specific project/department/goal], and I am confident in my ability to make a positive impact. I have attached my resume for your consideration.

I would appreciate the chance to discuss how my background and expertise could benefit your team. Please let me know if there is a convenient time for a call or a meeting.

Thank you for considering my application. I look forward to the opportunity to speak with you.

Best regards,
[Your Name]

✅ 𝗙𝗼𝗹𝗹𝗼𝘄-𝗨𝗽 𝗘𝗺𝗮𝗶𝗹:

𝗦𝘂𝗯𝗷𝗲𝗰𝘁: Follow-Up on My Interview

Hi [Hiring Manager's Name],

I hope you're doing well. I wanted to follow up on the interview we had for the [Job Title] position at [Company Name]. I'm really excited about the opportunity and would love to hear about the next steps in the process.

Looking forward to your response.

Best regards,
[Your Name]

✅ 𝗥𝗲𝗷𝗲𝗰𝘁𝗶𝗼𝗻 𝗘𝗺𝗮𝗶𝗹:

𝗦𝘂𝗯𝗷𝗲𝗰𝘁: Appreciation and Future Consideration

Hi [Hiring Manager's Name],

I hope this message finds you well. I wanted to express my gratitude for considering me for the [Job Title] position. Although I didn't make it to the next round, I'm thankful for the chance to learn about [Company Name]. I look forward to potentially crossing paths again in the future.

Thank you once again.

Best regards,
[Your Name]

✅ 𝗔𝗰𝗰𝗲𝗽𝘁𝗮𝗻𝗰𝗲 𝗘𝗺𝗮𝗶𝗹:

𝗦𝘂𝗯𝗷𝗲𝗰𝘁: Accepting the [Job Title] Position

Hello [Hiring Manager's Name],

I hope you're doing well. I wanted to formally accept the offer for the [Job Title] position at [Company Name]. I'm really excited about joining the team and contributing to [Company Name]'s success. Please let me know the next steps and any additional information you need from my end.

Thank you and looking forward to starting on [Start Date].

Best regards,
[Your Name]

✅ 𝗦𝗮𝗹𝗮𝗿𝘆 𝗡𝗲𝗴𝗼𝘁𝗶𝗮𝘁𝗶𝗼𝗻 𝗘𝗺𝗮𝗶𝗹:

𝗦𝘂𝗯𝗷𝗲𝗰𝘁: Salary Discussion for [Job Title] Position

Hello [Hiring Manager's Name],

I hope this message finds you well. I'm excited about the offer for the [Job Title] role at [Company Name]. I would like to discuss the compensation package to ensure that it aligns with my skills and experience. Could we set up a time to talk about this further?

Thank you and looking forward to your response.

##  HTTP “verbs”
GET, POST, PUT... Common HTTP “verbs” in one figure. The method to download the high-resolution PDF is available at the end.

1. HTTP GET
This retrieves a resource from the server. It is idempotent. Multiple identical requests return the same result.

2. HTTP PUT
This updates or Creates a resource. It is idempotent. Multiple identical requests will update the same resource.

3. HTTP POST
This is used to create new resources. It is not idempotent, making two identical POST will duplicate the resource creation.

4. HTTP DELETE
This is used to delete a resource. It is idempotent. Multiple identical requests will delete the same resource.

5. HTTP PATCH
The PATCH method applies partial modifications to a resource.

6. HTTP HEAD
The HEAD method asks for a response identical to a GET request but without the response body.

7. HTTP CONNECT
The CONNECT method establishes a tunnel to the server identified by the target resource.

8. HTTP OPTIONS
This describes the communication options for the target resource.

9. HTTP TRACE
This performs a message loop-back test along the path to the target resource.

Over to you: What other HTTP verbs have you used?

![1699289122056](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/83a2ffeb-9b40-4e2d-8833-e10325f2f3a5)

## Key Difference between SQL and NoSQL Databases!
Making the right database choice is a crucial decision for your projects. Let's break down SQL and NoSQL in a quick cheat sheet to help you make an informed decision!

SQL (Structured Query Language):

🔸 Structure: Tables with predefined schemas.
🔸 Data Consistency: Strong consistency and ACID transactions.
🔸 Scalability: Vertical scaling (add more resources to a server).
🔸 Use Cases: Well-suited for structured data and complex queries.
🔸 Query Language: SQL for complex queries.

NoSQL (Not Only SQL):

🔹 Structure: Flexible, schema-less data models (e.g., JSON, XML).
🔹 Data Consistency: Eventual consistency, often BASE (Basically Available, Soft state, Eventually consistent).
🔹 Scalability: Horizontal scaling (add more servers to a cluster).
🔹 Use Cases: Ideal for unstructured or semi-structured data, high-velocity data, and distributed systems.
🔹 Examples: MongoDB, Cassandra, Redis.


When to Choose:

SQL: Choose for well-defined data structures, complex queries, and strong data consistency needs.
NoSQL: Opt for flexibility, high scalability, and rapid development with evolving data requirements.

Remember, there's no one-size-fits-all solution. Your choice depends on your project's unique needs!
![1698975062735](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/94f56ded-23a4-4603-a9e9-cd1d1d6395d1)

## How does HTTPS work?
Hypertext Transfer Protocol Secure (HTTPS) is an extension of HTTP that utilizes Transport Layer Security (TLS) to encrypt communication between a client and server. Any intercepted data will be unreadable and secure from tampering and eavesdropping.

What's the process for encrypting and decrypting data?

Step 1 - The journey begins with the client (like your browser) establishing a TCP connection with the server.

Step 2 - Next comes the “client hello” where the browser sends a message containing supported cipher suites and the highest TLS version it can handle. Cipher suites are sets of algorithms that typically include: a key exchange method to share keys between devices, a bulk encryption algorithm to encrypt data, and a message authentication code algorithm to check data integrity.

The server responds with a “server hello”, confirming the chosen cipher suite and TLS version that they can both understand. The server then sends a TLS certificate to the client containing its domain name, certificate authority signature, and the server’s public key. The client checks this certificate to validate it is trusted and belongs to the server.

Step 3 - Once the TLS certificate is validated, the client creates a session key to be used for encrypting the bulk data transfer. Bulk data transfer refers to the transmission of the actual application data between client and server once the secure TLS connection is established. To securely send this session key to the server, it’s encrypted with the server’s public key. The server, with its private key, is the only one who can decrypt this encrypted session key.

Step 4 - Now that both parties have the secret session key, they shift gears to symmetric encryption. It’s like they’ve agreed on a private language that only they understand. This makes the data transfer very secure. Symmetric encryption is much faster for large amounts of data.

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/e6fd8128-ce04-4124-96ff-c76a0f157c0c)

## Which latency numbers you should know?
Please note those are not precise numbers. They are based on some online benchmarks (Jeff Dean’s latency numbers + some other sources).

🔹L1 and L2 caches: 1 ns, 10 ns
E.g.: They are usually built onto the microprocessor chip. Unless you work with hardware directly, you probably don’t need to worry about them.

🔹RAM access: 100 ns
E.g.: It takes around 100 ns to read data from memory. Redis is an in-memory data store, so it takes about 100 ns to read data from Redis.

🔹Send 1K bytes over 1 Gbps network: 10 us
E.g.: It takes around 10 us to send 1KB of data from Memcached through the network.

🔹Read from SSD: 100 us
E.g.: RocksDB is a disk-based K/V store, so the read latency is around 100 us on SSD.

🔹Database insert operation: 1 ms.
E.g.: Postgresql commit might take 1ms. The database needs to store the data, create the index, and flush logs. All these actions take time.

🔹Send packet CA->Netherlands->CA: 100 ms
E.g.: If we have a long-distance Zoom call, the latency might be around 100 ms.

🔹Retry/refresh internal: 1-10s
E.g: In a monitoring system, the refresh interval is usually set to 5~10 seconds (default value on Grafana).

Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/fb492ed1-9f8f-4d3a-90dd-1ba88062c058)

## deployment strategies
Over my years in IT, I've come across various deployment strategies, each with its unique approach and benefits.

Today, I wanted to share a quick rundown of the "Top 7 Deployment Strategies" I've encountered:

1. 𝗖𝗮𝗻𝗮𝗿𝘆 𝗥𝗲𝗹𝗲𝗮𝘀𝗲𝘀:
This strategy is all about caution. 🐥 Instead of deploying a new version to everyone, we release it to a small subset of users. It's like sending out a 'canary in a coal mine' to test if the environment is safe. If issues arise, they affect a limited audience, making it easier to manage and rectify.

2. 𝗕𝗹𝘂𝗲/𝗚𝗿𝗲𝗲𝗻 𝗗𝗲𝗽𝗹𝗼𝘆𝗺𝗲𝗻𝘁𝘀:
Think of it as having a stunt double for your application. 🎭 You maintain two identical production environments - Blue (live) and Green (idle). When you have a new release, you deploy to the idle environment. Once tested and ready, you switch traffic to the new environment, ensuring zero downtime.

3. 𝗙𝗲𝗮𝘁𝘂𝗿𝗲 𝗧𝗼𝗴𝗴𝗹𝗲𝘀:
A magician's trick for developers. 🪄 With toggles, you can dynamically turn features on or off. This means we can deploy a feature but keep it hidden until it's ready for prime time.

4. 𝗔/𝗕 𝗧𝗲𝘀𝘁𝗶𝗻𝗴:
It's like a taste test for features. 🍎🍏 By releasing two different versions to different user groups, we can gather data on which one performs better and is more preferred by users.

5. 𝗗𝗮𝗿𝗸 𝗟𝗮𝘂𝗻𝗰𝗵𝗲𝘀:
The covert ops of the deployment world. 🌘 We release new features in the background without users knowing. This helps in stress-testing and ensuring everything works seamlessly when it eventually goes live to the audience.

6. 𝗥𝗼𝗹𝗹𝗶𝗻𝗴 𝗗𝗲𝗽𝗹𝗼𝘆𝗺𝗲𝗻𝘁:
Think of it as a relay race. 🏃‍♂️🏃‍♀️ Instead of deploying a new version to all servers or instances at once, we do it one by one. This ensures there's always a version available to users, reducing downtime.

7.𝗣𝗵𝗮𝘀𝗲𝗱 𝗥𝗼𝗹𝗹𝗼𝘂𝘁𝘀: Similar to Canary deployments but with more structured phases.Instead of moving from a small subset of users to everyone, there might be several intermediate stages, like deploying to 10%, then 25%, then 50%, and so on

Understanding these strategies is vital for any software professional.

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/bd15a147-23cb-4ff9-aba5-e30576ec83e6)

## YAML and why?
Hello, tech enthusiasts! It's the weekend, and I hope no bugs are interrupting your well-deserved rest. Today, we will discuss YAML and the reasons why you should learn it as a programmer.

YAML (YAML Ain't Markup Language) is a human-readable data serialization format. It's often used for configuration files, data exchange between languages with different data structures, and as a data format in applications where human-readable text is preferred. YAML is important to learn for several reasons:

📒 Human-Readable: YAML is designed to be easily read and written by humans. Its simple and intuitive structure makes it a preferred choice for configuration files, where human readability is essential.

📒 Simple Syntax: YAML uses indentation and colons to define key-value pairs and data structures, making it straightforward to understand and write, even for those new to the format.

📒 Language-Agnostic: YAML is not tied to a specific programming language, making it a versatile choice for data exchange between different systems. It is supported by numerous programming languages through libraries and parsers.

📒 Versatile Data Structures: YAML supports a wide range of data structures, including scalars (strings, numbers, booleans, null), lists (arrays), dictionaries (objects), and nested combinations of these. This flexibility makes it suitable for various use cases.

📒 Configuration Files: YAML is commonly used for configuration files in software applications. It allows developers to specify settings, options, and parameters in a human-readable format.

📒 Data Serialization: YAML can be used to serialize and deserialize complex data structures, making it suitable for data storage and exchange between applications or systems.

📒 Data Transformation: It is also used for data transformation in ETL (Extract, Transform, Load) processes, allowing data to be represented in a structured, human-readable format before further processing.

📒 Markup Language Replacement: While not a full markup language, YAML is sometimes used as a more human-friendly alternative to markup languages like XML or JSON for simple data representation.

📒 Continuous Integration and Deployment (CI/CD): Many CI/CD pipelines use YAML for defining build and deployment configurations. This allows automation and repeatability in the deployment process.

If you found this post insightful, please engage with it and consider sharing ♻. Your participation is greatly valued.
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/511baa60-5af9-4f9f-8653-9e36f5a8d5e2)

## How To Release A Mobile App
The mobile app release process differs from conventional methods. This illustration simplifies the journey to help you understand.

Typical Stages in a Mobile App Release Process:

1. Registration & Development (iOS & Android): 
- Enroll in Apple's Developer Program and Google Play Console as iOS and Android developer
- Code using platform-specific tools: Swift/Obj-C for iOS, and Java/Kotlin for Android

2. Build & Test (iOS & Android): 
Compile the app's binary, run extensive tests on both platforms to ensure functionality and performance. Create a release candidate build.

3. QA:
- Internally test the app for issue identification (dogfooding)
- Beta test with external users to collect feedback
- Conduct regression testing to maintain feature stability

4. Internal Approvals:
- Obtain approval from stakeholders and key team members.
- Comply with app store guidelines and industry regulations
- Obtain security approvals to safeguard user data and privacy

5. App Store Optimization (ASO):
- Optimize metadata, including titles, descriptions, and keywords, for better search visibility
- Design captivating screenshots and icons to entice users
- Prepare engaging release notes to inform users about new features and updates

6. App Submission To Store:
- Submit the iOS app via App Store Connect following Apple's guidelines
- Submit the Android app via Google Play Console, adhering to Google's policies
- Both platforms may request issues resolution for approval

7. Release:
- Upon approval, set a release date to coordinate the launch on both iOS and Android platforms

Over to you:
What's the most challenging phase you've encountered in the mobile app release process?

![1698765350870](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/e4f34666-4757-4653-ae2a-d695bf05995e)

## Top 12 Tips for API Security
- Use HTTPS
- Use OAuth2
- Use WebAuthn
- Use Leveled API Keys
- Authorization
- Rate Limiting
- API Versioning
- Whitelisting
- Check OWASP API Security Risks
- Use API Gateway
- Error Handling
- Input Validation
![1698680730762](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/acc61b1a-cb98-4f74-a57d-11960007e923)


## Synchronous vs Asynchronous Explained.
🔄 Synchronous (Sync) Processing 🔄

Imagine a restaurant where the chef makes one burger at a time. 🍔🕐

1. You order a burger.
2. The chef starts making your burger and won't do anything else until it's done.
3. Only after your burger is ready, you can order another one.

This is how synchronous processing works in programming. It's like a step-by-step, one-at-a-time approach. It can make you wait, just like waiting for your burger to finish before ordering more.

⏩ Asynchronous (Async) Processing ⏩

Now, let's switch to a fast-food kitchen. 🍔🍟⏭

1. You order a burger and fries.
2. The chef starts making the burger but doesn't wait for it to finish.
3. While the burger's cooking, they also start frying your fries.
4. When each item is ready, they serve it to you, no need to wait.

This is asynchronous processing in programming. It's like multitasking, where different tasks happen simultaneously, making things faster. You don't have to wait for one task to finish before starting another.

So, synchronous is like a slow, one-at-a-time approach, while asynchronous is a faster, multitasking approach in programming. 🚀👨‍💻

![1698625303361 (1)](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/e7821355-1acc-405f-bf7f-422fddfc88f8)

## Navigating the Database Landscape ❗️❗️
Choosing the right database for your project is a critical decision. Here’s a step-by-step guide to help you make an informed choice:

1. 📝 Understand Your Project Requirements: Identify the specific needs of your project, including data volume, complexity, performance, scalability, and security requirements.
2.🗂️ Data Model: Decide on the data model your project requires: structured (🏢), semi-structured (📄), or unstructured (📦) data. This choice may lead you toward SQL or NoSQL databases.
3.🔄 SQL or NoSQL: If your data is structured and you require complex queries and transactions, consider SQL databases like PostgreSQL, MySQL, or Microsoft SQL Server (⚙️💼). For more flexibility and scalability, opt for NoSQL databases like MongoDB, Cassandra, or Redis (🔃📈).
4.📈 Scalability: Determine whether you need horizontal (🔀) or vertical (⬆️) scalability. NoSQL databases often offer better horizontal scalability for large datasets.
5.⚖️ CAP theorem: Understand the trade-offs between consistency (🧩), availability (🏃), and partition tolerance (🧱). Different databases prioritize these aspects differently.
6.💼 Open Source vs. Commercial: Decide between open-source databases (🐧) and commercial databases (💲). Licensing costs and support may influence this decision.
7.👥 Community and Ecosystem: Evaluate the community support (🤝) and available resources. An active community can be a valuable resource for problem-solving.
8.☁️ Cloud or On-Premises: Consider whether you want to manage the database infrastructure yourself (🏢) or prefer a managed database service in the cloud (🌥️).
9.💰 Budget: Assess the total cost of ownership, including licensing, hardware, and maintenance costs.
10.🔐 Security: Prioritize data security (🔒). Ensure the database provides encryption, access control, and compliance with relevant regulations.
11.🛡️ Backup and Recovery: Check the database’s backup and recovery capabilities to prevent data loss.
12.🏁 Performance and Optimization: Think about performance tuning, indexing, and query optimization (🔍📊) to meet your project’s performance requirements.
13.🧪 Testing and Prototyping: Consider testing the database with a small-scale prototype (🔍🔬) before committing to it for a large project.
14.🚀 Future Growth: Think about your project’s long-term needs (🔮). Will the chosen database support future requirements and growth?
15.🗣️ Feedback and Recommendations: Seek input from colleagues, mentors, or online communities (🌐💬) to gather insights and recommendations.

By following these steps and considering your project’s specific needs, you’ll be better equipped to choose the most suitable database for your application.

![1698645565323](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/862286cc-249c-4fc5-ad4d-326ed9547e76)

## HTTP (Hypertext Transfer Protocol) 
- is a fundamental protocol used for communication on the World Wide Web. It is the foundation for data communication on the internet and is responsible for the exchange of data between a client (usually a web browser) and a server.
Here is a list of some key features and characteristics of HTTP:

1. Stateless Protocol 📜
2. Request-Response Model 🔄
3. Text-Based Protocol 📄
4. Connectionless 🚪
5. Uniform Resource Identifier (URI) 🔗
6. Methods (HTTP Verbs) 🚀
7. Headers 📑
8. Status Codes 🚦
9. Content Negotiation 🤝
10. Caching 🏞️
11. Redirection ↩️
12. Security 🔒
13. Cookies and Sessions 🍪
14. Authentication 🔐
15. Content Types 📰
16. Proxy Support 🌐
17. Cross-Origin Resource Sharing (CORS) 🌐
18. Compression 📦
19. WebSockets 🧩
20. HTTP/2 and HTTP/3 🚀
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/af144350-1567-49f2-8b00-0065208fc405)

## Linux File Permissions Explained to a 5 year old 😁
Imagine your toy box 🧸📦 in your room – it's like a little computer!

🔒👀 Now, think of each toy as a file 📄 or a picture 🖼️ on your computer. These toys/files have three special locks:

1. Owner lock 👑🔐: Only the person who owns the toy/file can play with it or change it. 🙋‍♂️🔓
  
2. Group lock 👥🔐: This is like a club for your friends. Only the friends in this club can play with the toy/file, but others can't. 👦👧🔓
  
3. Everyone lock 🌍🔐: It's like sharing with everyone! If this lock is open, anyone can see or play with the toy/file. If it's closed, they can't. 👨‍👩‍👦🚫

So, when your computer is a detective 🕵️‍♂️, it checks these locks to see who can do what with the toys/files. If you're the owner, you can open your toy box and play. If you're in the group, you can play with your friends. And if the everyone lock is open, everyone can join the fun! 🎉🎈

That's how Linux keeps things safe and lets the right people do the right things with their stuff. Remember, it's like your toy box, but with secret locks! 🗝️🤫
![1698238907249](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/d7146363-6b1a-43f4-ab9c-e859d521485f)

## Session, cookie, JWT, token, SSO, and OAuth 2.0 - what are they?
These terms relate to managing user identity when logging into websites. You declare who you are (identification), your identity is verified (authentication), and you're granted appropriate permissions (authorization). Many solutions exist and continue to emerge.

From simple to more complex:

🔹WWW-Authenticate is very basic. The browser prompts for username and password. It lacks control over the login lifecycle, so is rarely used today.

🔹Session-cookie is prevalent in browsers. Servers maintain session storage, and browsers store session IDs in cookies. While browsers primarily use cookies, mobile apps can use them in web views but often prefer tokens for native functions.

🔹Tokens are encoded data used for validation, allowing clients to avoid sending credentials repeatedly. They ensure data integrity but aren't always encrypted.

🔹JWT provides a standardized format for tokens. They are digitally signed to ensure their authenticity. Because JWTs can hold session or user data in their claims, servers don't need to store this information separately for verification.

🔹SSO (single sign-on) lets you log in once then access multiple sites. Uses central authentication service (CAS) to maintain cross-site info.

🔹OAuth 2.0 authorizes one site to access your info on another site.

How do you see this landscape evolving? Will any particular standards dominate for web and mobile login?
![1698293519750](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/1d0f1cce-0fe2-465d-85ad-528181fe27b8)

## 𝐄𝐯𝐞𝐫𝐲 𝐄𝐧𝐠𝐢𝐧𝐞𝐞𝐫 𝐌𝐮𝐬𝐭 𝐤𝐧𝐨𝐰 𝐭𝐡𝐞 𝐓𝐨𝐩 𝟏𝟎 𝐃𝐞𝐬𝐢𝐠𝐧 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬 ❗️❗️
Several design patterns are commonly used in software development to solve recurring problems. Some of the most frequently used design patterns.

1.Singleton Pattern: 🕺 Ensures a class has only one instance and provides a global point of access to it.
2.Factory Method Pattern: 🏭 Defines an interface for creating an object but allows subclasses to alter the type of objects that will be created.
3.Abstract Factory Pattern: 🏭🏭 Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
4.Builder Pattern: 🏗️ Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.
5.Prototype Pattern: 🧬 Creates new objects by copying an existing object, known as the prototype, instead of creating objects from scratch.
6.Adapter Pattern: 🧩Allows the interface of an existing class to be used as another interface, making it compatible with client code.
7.Decorator Pattern: 🎨 Attaches additional responsibilities to an object dynamically, providing a flexible alternative to subclassing for extending functionality.
8.Observer Pattern: 👁️‍🗨️Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
9.Strategy Pattern: 🏹Defines a family of algorithms, encapsulates each one, and makes them interchangeable. It lets the algorithm vary independently from clients that use it.
10.Command Pattern: ✅Encapsulates a request as an object, thereby allowing for parameterization of clients with requests, queuing of requests, and logging of requests.
11.MVC (Model-View-Controller) Pattern: 🖥️ Separates an application into three interconnected components – the Model (data and business logic), View (presentation and user interface), and Controller (user input and control flow).
12.Composite Pattern: 🌲 Composes objects into tree structures to represent part-whole hierarchies. Clients can treat individual objects and compositions of objects uniformly.
13.State Pattern: 🏳️Allows an object to alter its behavior when its internal state changes. The object will appear to change its class.
14.Chain of Responsibility Pattern: 🔗Passes a request along a chain of handlers, allowing each handler to decide either to process the request or to pass it to the next handler in the chain.

These design patterns help in creating maintainable, flexible, and efficient software systems by promoting good coding practices and modularity. The choice of pattern depends on the specific problem you’re trying to solve and the design goals you want to achieve.
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/180a2b92-1eed-4264-9038-33a1a0a8698a)

## 6 Database Types You Must Know
1. Relational Database 💼
  - Data Model: Organizes data into tables with rows and columns.
  - Examples: MySQL, PostgreSQL, Oracle, SQL Server.
  - Key Features: ACID compliance, strong data consistency, structured data storage, support for SQL queries, well-suited for complex transactions and reporting.

2. Document Database 📄
  - Data Model: Stores data in semi-structured or JSON-like documents.
  - Examples: MongoDB, CouchDB, Firebase Firestore.
  - Key Features: Flexible schema, horizontal scalability, support for semi-structured data, well-suited for content management systems and real-time applications.

3. In-Memory Database 🚀
  - Data Model: Stores data entirely in the system's main memory (RAM).
  - Examples: Redis, Memcached, Apache Ignite.
  - Key Features: Ultra-fast data retrieval, low-latency, suitable for caching, session management, and real-time analytics.

4. Graph Database 🌐
  - Data Model: Represents data as nodes and edges to model relationships.
  - Examples: Neo4j, Amazon Neptune, ArangoDB.
  - Key Features: Efficient querying of complex relationships, graph traversal, suitable for social networks, recommendation systems, and fraud detection.

5. Time-Series Database 📈
  - Data Model: Optimized for time-ordered data points, like sensor readings or log files.
  - Examples: InfluxDB, Prometheus, TimescaleDB.
  - Key Features: Efficient storage and retrieval of time-series data, aggregations, retention policies, ideal for monitoring, IoT, and event data.

6. Spatial Database 🌍
  - Data Model: Designed for storing and querying spatial or geographic data.
  - Examples: PostGIS (extension for PostgreSQL), MongoDB Geospatial, Microsoft SQL Server Spatial.
  - Key Features: Geospatial indexing, support for spatial data types (points, polygons, lines), useful for location-based services, GIS (Geographic Information Systems), and map applications.

![1698277235447](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/8393257a-c862-4052-a8ec-57c8ddeccfe2)

## 9 types of API testing
Explaining 9 types of API testing. The method to download the high-resolution PDF is available at the end.

🔹 Smoke Testing
This is done after API development is complete. Simply validate if the APIs are working and nothing breaks.

🔹 Functional Testing
This creates a test plan based on the functional requirements and compares the results with the expected results.

🔹 Integration Testing
This test combines several API calls to perform end-to-end tests. The intra-service communications and data transmissions are tested.

🔹 Regression Testing
This test ensures that bug fixes or new features shouldn’t break the existing behaviors of APIs.

🔹 Load Testing
This tests applications’ performance by simulating different loads. Then we can calculate the capacity of the application.

🔹 Stress Testing
We deliberately create high loads to the APIs and test if the APIs are able to function normally.

🔹 Security Testing
This tests the APIs against all possible external threats.

🔹 UI Testing
This tests the UI interactions with the APIs to make sure the data can be displayed properly.

🔹 Fuzz Testing
This injects invalid or unexpected input data into the API and tries to crash the API. In this way, it identifies the API vulnerabilities

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/f99ce25d-aa29-4955-a263-be6cb3fa303b)

## API Gateway 
An API Gateway is a server that acts as a single entry point for managing, aggregating, and routing API requests.


It's the key to efficiently handling API traffic, ensuring security, and optimizing performance. 🚀

The API Gateway Architecture consists of several layers, each serving a unique purpose. Here are top 4 layers -

1️⃣ 𝗡𝗲𝘁𝘄𝗼𝗿𝗸 𝗦𝗲𝗰𝘂𝗿𝗶𝘁𝘆 𝗟𝗮𝘆𝗲𝗿 🛡️:
This layer takes care of protecting your API infrastructure from threats. It enforces security policies such as SSL/TLS, DDoS protection, and rate limiting, ensuring that your APIs are not vulnerable to unauthorized access or misuse.

2️⃣ 𝗔𝗱𝗺𝗶𝗻𝗶𝘀𝘁𝗿𝗮𝘁𝗶𝘃𝗲 𝗟𝗮𝘆𝗲𝗿 🛠️:
Managing APIs is no small task. That's where the Administrative Layer comes in. It provides features for API versioning, monitoring, logging, and analytics. With these tools, you can keep track of API usage, diagnose issues, and gain insights into how your APIs are performing.

3️⃣ 𝗔𝗰𝗰𝗲𝘀𝘀 𝗟𝗮𝘆𝗲𝗿 🗝️:
Controlling who gets access to your APIs is crucial. The Access Layer handles authentication, authorization, and access control policies. Whether it's through API keys, OAuth tokens, or other mechanisms, you have the power to decide who can access your APIs and what they can do.

4️⃣ 𝗧𝗿𝗮𝗻𝘀𝗳𝗼𝗿𝗺𝗮𝘁𝗶𝗼𝗻 𝗟𝗮𝘆𝗲𝗿 🔄:
APIs come in all shapes and sizes, and it's not always easy to make them work together. The Transformation Layer helps by providing tools for data transformation and protocol conversion. Whether you need to convert JSON to XML, handle different authentication schemes, or support legacy systems, this layer has got you covered.

𝗕𝗲𝗻𝗲𝗳𝗶𝘁𝘀 𝗼𝗳 𝗮𝗻 𝗔𝗣𝗜 𝗚𝗮𝘁𝗲𝘄𝗮𝘆

🚀 Performance Boost
🛡️ Enhanced Security
🧩 Simplified Microservices
💡 Unified API Management

𝗧𝘆𝗽𝗲𝘀 𝗼𝗳 𝗔𝗣𝗜 𝗚𝗮𝘁𝗲𝘄𝗮𝘆

✅ Edge Gateways: Placed on the outer layer of your network, they handle public APIs, focusing on load balancing, security, and caching.

✅ Internal Gateways: Catering to internal APIs, they help optimize inter-service communication and manage internal API traffic.

✅ Micro-Gateways: Lightweight and tailored for specific use cases, they're deployed in close proximity to specific services, often within containerized environments.


𝗣𝗼𝗽𝘂𝗹𝗮𝗿 𝗔𝗣𝗜 𝗚𝗮𝘁𝗲𝘄𝗮𝘆 𝗧𝗼𝗼𝗹𝘀

🔵 Amazon API Gateway
🟢 Kong
🔴 Apigee Edge
🔶 Azure API Management
🟣 Tyk

Did I miss any crucial concept?

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/dec7d8d6-bb78-4b8c-b76a-04041915a3c3)

## WORLD OF MICROSERVICES DESIGN PATTERN!!

[1698043583699.pdf](https://github.com/jdbirla/JD-Common-Learning/files/14416358/1698043583699.pdf)

## How Do C++, Java, and Python Function? We just made a video on this topic.
How Do C++, Java, and Python Function? We just made a video on this topic.

The illustration details the processes of compilation and execution.

Languages that compile transform source code into machine code using a compiler. This machine code can subsequently be run directly by the CPU. For instance: C, C++, Go.

In contrast, languages like Java first convert the source code into bytecode. The Java Virtual Machine (JVM) then runs the program. Occasionally, a Just-In-Time (JIT) compiler translates the source code into machine code to enhance execution speed. Some examples are Java and C#.

Languages that are interpreted don't undergo compilation. Instead, their code is processed by an interpreter during execution. Python, Javascript, and Ruby are some examples.

Generally, compiled languages have a speed advantage over interpreted ones.
![1698075576783](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/48f41339-57a0-45f3-815e-44910396fc88)

## How do we transform a system to be Cloud Native?
The diagram below shows the action spectrum and adoption roadmap. You can use it as a blueprint for adopting cloud-native in your organization.

For a company to adopt cloud native architecture, there are 6 aspects in the spectrum:

1. Application definition development
2. Orchestration and management
3. Runtime
4. Provisioning
5. Observability
6. Serverless

Over to you: Where does your system stand in the adoption roadmap?

Reference: Cloud & DevOps: Continuous Transformation by MIT
Redrawn by ByteByteGo
![1695656751388](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/5752afbe-2ac6-4843-8552-a58ceb540be5)


## Best ways to test system functionality. Next week's topic will be listed at the end.
Best ways to test system functionality. Next week's topic will be listed at the end.

Testing system functionality is a crucial step in software development and engineering processes.

It ensures that a system or software application performs as expected, meets user requirements, and operates reliably.

Here we delve into the best ways:

1. Unit Testing: Ensures individual code components work correctly in isolation.

2. Integration Testing: Verifies that different system parts function seamlessly together.

3. System Testing: Assesses the entire system's compliance with user requirements and performance.

4. Load Testing: Tests a system's ability to handle high workloads and identifies performance issues.

5. Error Testing: Evaluates how the software handles invalid inputs and error conditions.

6. Test Automation: Automates test case execution for efficiency, repeatability, and error reduction.

Over to you: How do you approach testing system functionality in your software development or engineering projects?

Over to you: what's your company's release process look like?

Next week, we will talk about:
- Python vs. C++ vs. Java (YouTube)
- Cloud provider cheatsheet (AWS, GCP, Azure, Oracle, Alibaba Cloud)
- Object stores
- Tech interview materials
- Mobile release

![1697988792124](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/15bc6771-8542-4d4f-baad-252c15726b9a)
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/75a9e697-f581-4765-964a-469f7db1fd29)

## Cloud Certifications - Role Based Roadmap 👇
Navigating the certification paths for 8 popular roles.

AWS:
1. Solutions Architect:
Cloud Practitioner Foundational
Solutions Architect Associate
Solutions Architect Professional

2. Cloud Data Engineer:
Cloud Practitioner Foundational
Solutions Architect Associate
Data Analytics Specialty

3. Software Development Engineer:
Cloud Practitioner Foundational
Developer Associate

4. System Administrator:
Cloud Practitioner Foundational
SyOps Administrator Associate

5. Cloud DevOps Engineer:
Cloud Practitioner Foundational
Developer Associate
DevOps Engineer Professional

6. Cloud Security Engineer:
Cloud Practitioner Foundational
SyOps Administrator Associate
Security Specialty

7. Network Engineer:
Cloud Practitioner Foundational
Solutions Architect Associate
Advanced Networking Specialty

8. Machine Learning Engineer:
Cloud Practitioner Foundational
Solutions Architect Associate
Machine Learning Specialty


Azure:
1. Solutions Architect:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Solutions Architect Expert

2. Cloud Data Engineer:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Data Engineer Associate

3. Software Development Engineer:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Developer Associate

4. System Administrator:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Administrator Associate

5. Cloud DevOps Engineer:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Developer Associate
Microsoft Certified: DevOps Engineer Expert

6. Cloud Security Engineer:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Administrator Associate
Microsoft Certified: Azure Security Engineer Associate

7. Network Engineer:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Network Engineer Associate

8. Machine Learning Engineer:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure AI Engineer Associate


Google Cloud:
1. Solutions Architect:
Associate Cloud Engineer
Professional Cloud Architect

2. Cloud Data Engineer:
Associate Cloud Engineer
Professional Data Engineer

3. Software Development Engineer:
Associate Cloud Engineer
Professional Cloud Developer

4. System Administrator:
Associate Cloud Engineer

5. Cloud DevOps Engineer:
Associate Cloud Engineer
Professional DevOps Engineer

6. Cloud Security Engineer:
Associate Cloud Engineer
Professional Security Engineer

7. Network Engineer:
Associate Cloud Engineer
Professional Network Engineer

8. Machine Learning Engineer:
Associate Cloud Engineer
Professional Machine Learning Engineer

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/c759d1ca-855e-4d78-942c-21a7b4984820)

## Explaining 5 unique ID generators in distributed systems.
The diagram below shows how they work. Each generator has its pros and cons.

1. UUID
A UUID has 128 bits. It is simple to generate and no need to call another service. However, it is not sequential and inefficient for database indexing. Additionally, UUID doesn’t guarantee global uniqueness. We need to be careful with ID conflicts (although the chances are slim.)

2. Snowflake
Snowflake’s ID generation process has multiple components: timestamp, machine ID, and serial number. The first bit is unused to ensure positive IDs. This generator doesn’t need to talk to an ID generator via the network, so is fast and scalable.

Snowflake implementations vary. For example, data center ID can be added to the “MachineID” component to guarantee global uniqueness.

3. DB auto-increment
Most database products offer auto-increment identity columns. Since this is supported in the database, we can leverage its transaction management to handle concurrent visits to the ID generator. This guarantees uniqueness in one table. However, this involves network communications and may expose sensitive business data to the outside. For example, if we use this as a user ID, our business competitors will have a rough idea of the total number of users registered on our website.

4. DB segment
An alternative approach is to retrieve IDs from the database in batches and cache them in the ID servers, each ID server handling a segment of IDs. This greatly saves the I/O pressure on the database.

5. Redis
We can also use Redis key-value pair to generate unique IDs. Redis stores data in memory, so this approach offers better performance than the database.
![1697823917063](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/3da6f09e-14bb-4a8a-929c-b9901a259c8e)


## Explaining JSON Web Token (JWT) to a 10 year old Kid.
Explaining JSON Web Token (JWT) to a 10 year old Kid.
.
.
Imagine you have a special box called a JWT. Inside this box, there are three parts: a header, a payload, and a signature.

The header is like the label on the outside of the box. It tells us what type of box it is and how it's secured. It's usually written in a format called JSON, which is just a way to organize information using curly braces { } and colons : .

The payload is like the actual message or information you want to send. It could be your name, age, or any other data you want to share. It's also written in JSON format, so it's easy to understand and work with.

Now, the signature is what makes the JWT secure. It's like a special seal that only the sender knows how to create. The signature is created using a secret code, kind of like a password. This signature ensures that nobody can tamper with the contents of the JWT without the sender knowing about it.

When you want to send the JWT to a server, you put the header, payload, and signature inside the box. Then you send it over to the server. The server can easily read the header and payload to understand who you are and what you want to do.

Over to you: When should we use JWT for authentication? What are some other authentication methods?

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/c8564cba-4f34-46cf-b072-44430a1d3059)

## IBM MQ -> RabbitMQ -> Kafka ->Pulsar
IBM MQ -> RabbitMQ -> Kafka ->Pulsar, How do message queue architectures evolve?

🔹 IBM MQ
IBM MQ was launched in 1993. It was originally called MQSeries and was renamed WebSphere MQ in 2002. It was renamed to IBM MQ in 2014. IBM MQ is a very successful product widely used in the financial sector. Its revenue still reached 1 billion dollars in 2020.

🔹 RabbitMQ
RabbitMQ architecture differs from IBM MQ and is more similar to Kafka concepts. The producer publishes a message to an exchange with a specified exchange type. It can be direct, topic, or fanout. The exchange then routes the message into the queues based on different message attributes and the exchange type. The consumers pick up the message accordingly.

🔹 Kafka
In early 2011, LinkedIn open sourced Kafka, which is a distributed event streaming platform. It was named after Franz Kafka. As the name suggested, Kafka is optimized for writing. It offers a high-throughput, low-latency platform for handling real-time data feeds. It provides a unified event log to enable event streaming and is widely used in internet companies.

Kafka defines producer, broker, topic, partition, and consumer. Its simplicity and fault tolerance allow it to replace previous products like AMQP-based message queues.

🔹 Pulsar
Pulsar, developed originally by Yahoo, is an all-in-one messaging and streaming platform. Compared with Kafka, Pulsar incorporates many useful features from other products and supports a wide range of capabilities. Also, Pulsar architecture is more cloud-native, providing better support for cluster scaling and partition migration, etc.

There are two layers in Pulsar architecture: the serving layer and the persistent layer. Pulsar natively supports tiered storage, where we can leverage cheaper object storage like AWS S3 to persist messages for a longer term.

Over to you: which message queues have you used?

![1697177276062](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/041a3d1c-27bc-4db3-87ed-df08489db5a2)
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/d5def874-bd44-4562-8f49-f4e5840583f1)

## Top 6 Load Balancing Algorithms
Top 6 Load Balancing Algorithms

🔹 Static Algorithms
1. Round robin
The client requests are sent to different service instances in sequential order. The services are usually required to be stateless.

2. Sticky round-robin
This is an improvement of the round-robin algorithm. If Alice’s first request goes to service A, the following requests go to service A as well.

3. Weighted round-robin
The admin can specify the weight for each service. The ones with a higher weight handle more requests than others.

4. Hash
This algorithm applies a hash function on the incoming requests’ IP or URL. The requests are routed to relevant instances based on the hash function result.

🔹 Dynamic Algorithms
5. Least connections
A new request is sent to the service instance with the least concurrent connections.

6. Least response time
A new request is sent to the service instance with the fastest response time.
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/39021daa-2c10-444b-bf0f-ece6e5f69849)

## 𝗖𝗹𝗲𝗮𝗿𝗶𝗻𝗴 𝘁𝗵𝗲 𝗙𝗼𝗴: 𝗗𝗮𝘁𝗮𝗢𝗽𝘀 𝗶𝘀 𝗡𝗢𝗧 𝗠𝗲𝗿𝗲𝗹𝘆 𝗗𝗲𝘃𝗢𝗽𝘀 𝗳𝗼𝗿 𝗗𝗮𝘁𝗮!

There’s a bit of a myth we need to bust today: DataOps is NOT DevOps for data. 🚫

❌ So let’s unwrap this mystery together, but in super straightforward words! 🎁

𝗗𝗲𝘃𝗢𝗽𝘀 𝗶𝗻 𝗮 𝗡𝘂𝘁𝘀𝗵𝗲𝗹𝗹 🥜👥

- 𝗗𝗲𝘃𝗢𝗽𝘀: Picture this as a perfect tag team! One teammate, the developer, builds software, while the other, the operations team, ensures it runs seamlessly. Together, they aim to deliver quick and flawless software to users. It’s all about a speedy and efficient creation
and delivery process. 🚀💻

𝙳𝚎𝚟𝙾𝚙𝚜 = [𝙿𝚕𝚊𝚗 + 𝙲𝚘𝚍𝚎 + 𝙲𝙸(𝙱𝚞𝚒𝚕𝚍 + 𝚃𝚎𝚜𝚝) + 𝙲𝙳(𝙳𝚎𝚙𝚕𝚘𝚢) + 𝙾𝚙𝚎𝚛𝚊𝚝𝚎(𝚁𝚞𝚗 + 𝙼𝚘𝚗𝚒𝚝𝚘𝚛) + 𝙵𝚎𝚎𝚍𝚋𝚊𝚌𝚔(𝙻𝚎𝚊𝚛𝚗 + 𝙿𝚕𝚊𝚗)]

𝗗𝗶𝗴𝗴𝗶𝗻𝗴 𝗶𝗻𝘁𝗼 𝗗𝗮𝘁𝗮𝗢𝗽𝘀 🕵️‍♂️📊

- 𝗗𝗮𝘁𝗮𝗢𝗽𝘀: While it’s got some vibe from DevOps, it’s got its unique flavor! It’s less about building software and more about ensuring data flows like a peaceful river through your organization, always clear, trustworthy, and ready to make informed business decisions! It involves ensuring everyone from data scientists to business analysts is on the same page. 🏞️📘
𝙳𝚊𝚝𝚊𝙾𝚙𝚜 = [𝙴𝚡𝚙𝚕𝚘𝚛𝚎(𝚂𝚊𝚗𝚍𝚋𝚘𝚡 𝙼𝚊𝚗𝚊𝚐𝚎𝚖𝚎𝚗𝚝) + 𝙳𝚎𝚟𝚎𝚕𝚘𝚙 + 𝙲𝙸(𝙾𝚛𝚌𝚑𝚎𝚜𝚝𝚛𝚊𝚝𝚎 + 𝚃𝚎𝚜𝚝) + 𝙲𝙳(𝙳𝚎𝚙𝚕𝚘𝚢) + 𝙾𝚙𝚎𝚛𝚊𝚝𝚎(𝙾𝚛𝚌𝚑𝚎𝚜𝚝𝚛𝚊𝚝𝚎 + 𝙼𝚘𝚗𝚒𝚝𝚘𝚛) + 𝙵𝚎𝚎𝚍𝚋𝚊𝚌𝚔(𝙰𝚗𝚊𝚕𝚢𝚣𝚎 + 𝙴𝚡𝚙𝚕𝚘𝚛𝚎)]


𝗦𝗽𝗼𝘁𝘁𝗶𝗻𝗴 𝘁𝗵𝗲 𝗗𝗶𝗳𝗳𝗲𝗿𝗲𝗻𝗰𝗲𝘀 🔄🔍

- DevOps connects developers and operations, while DataOps unites a larger group: developers, data scientists, data engineers, and business minds. 🌎🤗

- DataOps uniquely addresses the journey of data - from raw numbers to insightful analytics

- ensuring it’s clean, usable, and delivered without a hiccup! 📈✨

𝗪𝗵𝘆 𝗗𝗼𝗲𝘀 𝗜𝘁 𝗠𝗮𝘁𝘁𝗲𝗿? 🤷‍♀️🎯

Recognizing these subtle differences helps us implement the right strategies and tools in our projects.

Whether we’re crafting software with #DevOps or navigating the exciting world of data with #DataOps, identifying their unique abilities is key! 🔐🛠️

So, data pals, what are your thoughts? 🗣️💭

Dive into the comments and let's create a whirlpool of knowledge together! 🌀👥

If this friendly chat was a lightbulb moment, share it to spread the insight! 💡🔄

🌺 Your insights light up the community! Looking forward to reading your delightful thoughts below! 🌺

![1697159073135](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/2fd0bf01-65b5-4a93-bd1d-5905d6f98ae1)

## 12 Factor App
The 12 Factor App is a methodology for building scalable and maintainable web applications. It provides a set of guidelines for developing modern, cloud-native, and containerized applications. Here are the 12 factors explained in bullet points:

1. Codebase:
  - One codebase per application.
  - Use version control to manage code changes.

2. Dependencies:
  - Explicitly declare and isolate dependencies.
  - Avoid relying on system-wide packages.

3. Config:
  - Store configuration in environment variables.
  - Keep configuration separate from code.

4. Backing Services:
  - Treat external services (databases, caches, etc.) as attached resources.
  - Connect to them via URLs or environment variables.

5. Build, Release, Run:
  - Strictly separate the build, release, and run stages of the application.
  - Use consistent and repeatable build processes.

6. Processes:
  - Execute the application as stateless processes.
  - Avoid storing session data locally; use external services.

7. Port Binding:
  - Export services via a port and communicate over the network.
  - Web applications should bind to a port defined by the environment.

8. Concurrency:
  - Scale out via the process model.
  - Utilize multiple stateless processes to handle requests.

9. Disposability:
  - Maximize robustness with fast startup and graceful shutdown.
  - Terminate unneeded processes without impact.

10. Dev/Prod Parity:
  - Keep development, staging, and production environments as similar as possible.
  - Use the same dependencies and configuration.

11. Logs:
  - Treat logs as event streams.
  - Write application logs to standard output and allow log aggregation.

12. Admin Processes:
  - Run administrative tasks as one-off processes.
  - Use the same codebase and environment for administrative tasks.

Adhering to these 12 factors helps create applications that are easier to develop, deploy, and maintain, making them well-suited for cloud-native and containerized environments.

![1697068638860](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/ce886ab6-c65d-4c83-a005-135a6618ed6d)

## The 5 Deployment Patterns to Know in 2023
Software development is a complex process involving several stages.

Here is a simplified view of these stages:

𝗥𝗲𝗾𝘂𝗶𝗿𝗲𝗺𝗲𝗻𝘁𝘀 𝗚𝗮𝘁𝗵𝗲𝗿𝗶𝗻𝗴: The initial step where we determine and document the software needs from users or stakeholders.

𝗗𝗲𝘀𝗶𝗴𝗻: 𝗜n this phase, we architect the system, craft the user interface, and plan software component interactions.

𝗜𝗺𝗽𝗹𝗲𝗺𝗲𝗻𝘁𝗮𝘁𝗶𝗼𝗻 (𝗖𝗼𝗱𝗶𝗻𝗴): Developers write the software code in an appropriate programming language during this stage.

𝗧𝗲𝘀𝘁𝗶𝗻𝗴: The software is checked and rectified to ensure it functions as intended, free of bugs or issues.

𝗗𝗲𝗽𝗹𝗼𝘆𝗺𝗲𝗻𝘁: Post approval, the software is deployed, meaning it's set up in a live environment, available to end-users.

𝗠𝗮𝗶𝗻𝘁𝗲𝗻𝗮𝗻𝗰𝗲: Once live, the software requires continuous upkeep, including bug fixing, updates for new requirements, or performance enhancements.

Deployment is a crucial part of this process. It is not just about hitting a "launch" button; it's an art that requires strategic planning and precision. 🎯

That’s where deployment patterns come in. These are strategies that ensure the software's safe transition from the development environment to your devices.

Here are some common deployment patterns in software engineering:

1️⃣ 🐤 𝗖𝗮𝗻𝗮𝗿𝘆 𝗥𝗲𝗹𝗲𝗮𝘀𝗲𝘀: Imagine introducing a new feature like you're testing the waters. You release it to a small group first, monitor performance, and if all's well, roll it out to everyone. That's the beauty of Canary Releases - the early bird catching the worm! 🎯

2️⃣ 🔵🟢 𝗕𝗹𝘂𝗲/𝗚𝗿𝗲𝗲𝗻 𝗗𝗲𝗽𝗹𝗼𝘆𝗺𝗲𝗻𝘁: Picture having two production environments, as identical as twin peas in a pod. One serves live (Blue), while you deploy and test in the other (Green). Once ready, just flip the switch! Seamless transitions with near-zero downtime. 🔄

3️⃣ 🚦𝗙𝗲𝗮𝘁𝘂𝗿𝗲 𝗧𝗼𝗴𝗴𝗹𝗲𝘀: Also known as feature flags, this strategy is like having a superhero's dual identity! It allows developers to turn features on/off, enabling flexible releases and testing. You control who sees what and when - in real-time! ⏰

4️⃣ 🅰️/🅱️ 𝗔/𝗕 𝗧𝗲𝘀𝘁𝗶𝗻𝗴: Ever wished you could read your user's mind? A/B Testing comes close. It helps understand user preferences by comparing two versions (A and B) of a feature. It's a litmus test to identify what works best for your audience! 🎲

5️⃣ 🌑 𝗗𝗮𝗿𝗸 𝗟𝗮𝘂𝗻𝗰𝗵𝗲𝘀: Ever unveiled a magic trick before the grand performance? That's what Dark Launches are like! Features are quietly released to a subset of users to gather data and rectify issues before the actual launch. No fanfare, no fuss, just a whole lot of valuable insights! 🕵️

![1696963360598](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/66699046-96fe-47e1-a324-a607b874e854)

##  companies ship code to production
How do companies ship code to production? The method to download the high-resolution PDF is available at the end.

The diagram below illustrates the typical workflow.

Step 1: The process starts with a product owner creating user stories based on requirements.

Step 2: The dev team picks up the user stories from the backlog and puts them into a sprint for a two-week dev cycle.

Step 3: The developers commit source code into the code repository Git.

Step 4: A build is triggered in Jenkins. The source code must pass unit tests, code coverage threshold, and gates in SonarQube.

Step 5: Once the build is successful, the build is stored in artifactory. Then the build is deployed into the dev environment.

Step 6: There might be multiple dev teams working on different features. The features need to be tested independently, so they are deployed to QA1 and QA2.

Step 7: The QA team picks up the new QA environments and performs QA testing, regression testing, and performance testing.

Steps 8: Once the QA builds pass the QA team’s verification, they are deployed to the UAT environment.

Step 9: If the UAT testing is successful, the builds become release candidates and will be deployed to the production environment on schedule.

Step 10: SRE (Site Reliability Engineering) team is responsible for prod monitoring.
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/7af831c2-1398-4c3a-befa-c54a84ee819c)

## What happens when you type a URL into a browser?

What happens when you type a URL into a browser? The method to download the high-resolution PDF is available at the end.

Let’s look at the process step by step.

Step 1: The user enters a URL (www. bytebytego. com) into the browser and hits Enter. The first thing we need to do is to translate the URL to an IP address. The mapping is usually stored in a cache, so the browser looks for the IP address in multiple layers of cache: the browser cache, OS cache, local cache, and ISP cache. If the browser couldn’t find the mapping in the cache, it will ask the DNS (Domain Name System) resolver to resolve it.

Step 2: If the IP address cannot be found at any of the caches, the browser goes to DNS servers to do a recursive DNS lookup until the IP address is found.

Step 3: Now that we have the IP address of the server, the browser sends an HTTP request to the server. For secure access of server resources, we should always use HTTPS. It first establishes a TCP connection with the server via TCP 3-way handshake. Then it sends the public key to the client. The client uses the public key to encrypt the session key and sends to the server. The server uses the private key to decrypt the session key. The client and server can now exchange encrypted data using the session key.

Step 4: The server processes the request and sends back the response. For a successful response, the status code is 200. There are 3 parts in the response: HTML, CSS and Javascript. The browser parses HTML and generates DOM tree. It also parses CSS and generates CSSOM tree. It then combines DOM tree and CSSOM tree to render tree. The browser renders the content and display to the user.
![1696866325286](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/e6f85100-9486-4583-9c60-0534945d2046)

## sheet of various databases in cloud services
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/2333e327-5738-46a7-9ae5-49f819b7f24e)

## Very Powerful Words. Read it.
**What You #Can #Control** 💪

1. **Your #Actions** 🚶‍♂️: You have the power to decide what you do and how you behave in various situations.

2. **Your #Choices** 🤔: You can make decisions about your life, goals, and values.

3. **Your #Reactions** 😃: You can choose how you respond to challenges, setbacks, and emotions.

4. **Your #Attitude** 🧠: Your outlook on life is within your control, influencing how you perceive and approach situations.

5. **Your #Effort** ⭐: The level of effort and dedication you put into your endeavors is up to you.

**What You Can't #Control** 🤷‍♀️

1. **External #Events** 🌍: You can't control natural disasters, economic changes, or global events.

2. **Other #People's Actions** 👥: You can't control how others behave, but you can control your reactions to their actions.

3. **Past #Events** ⏳: You can't change what has already happened, but you can control how you move forward.

4. **Uncertain #Future** 🎯: The future is unpredictable; you can't control every #outcome, but you can plan and adapt.

Remember, focusing on what you can control can lead to greater personal #empowerment and resilience.

more #positive thoughts

#1. #Gratitude: Focus on what you're thankful for in your life.
#2. #Optimism: Embrace a positive outlook for the future.
#3. #SelfBelief: Believe in your abilities and potential.
#4. #Positivity: Surround yourself with positive energy and people.
#5. #Empowerment: Take control of your life and goals.
#6. #Resilience: Bounce back from challenges stronger than before.
#7. #Kindness: Spread kindness and positivity to others.
#8. #Mindfulness: Stay present and appreciate each moment.
#9. #Growth: Embrace personal and professional growth opportunities.
#10. #Happiness: Pursue activities and relationships that bring joy.

These positive thoughts can help improve your mindset and overall well-being

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/effefed1-1935-4199-8870-17954bd97d71)

## caching systems
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/ac24c797-1df5-45ca-b233-ffa28859188d)

## JWT Explained
1. JSON Format: JWTs are represented as JSON objects, making them easy to read by both humans and machines. They consist of three parts separated by dots (`.`): the Header, the Payload, and the Signature.

- Header: The Header typically consists of two parts: the type of the token (JWT) and the signing algorithm being used (e.g., HMAC SHA256 or RSA). It's Base64Url encoded to form the first part of the JWT.

- Payload: The Payload contains the claims, which are statements about an entity (usually, the user) and additional data. Claims can be categorized into three types:

- Registered Claims: These are predefined claims with specific meanings, such as "iss" (issuer), "sub" (subject), "aud" (audience), "exp" (expiration time), and "iat" (issued at time).

- Public Claims: These are user-defined claims that can be freely used, but it's a good practice to avoid common names to prevent conflicts.

- Private Claims: These are custom claims used between parties that agree on their meaning.

- Signature: The Signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't tampered with during transmission. The Signature is created by taking the encoded Header, encoded Payload, a secret (or private key in the case of RSA), and the chosen algorithm, then running them through the algorithm to produce a hash. This hash is used to verify the integrity of the token.

2. Encoding: Each of the three JWT components (Header, Payload, and Signature) is Base64Url encoded, which is a URL-safe variant of Base64 encoding. This encoding ensures that the JWT remains compact and can be safely transmitted in URLs, query parameters, or HTTP headers.

3. Usage: JWTs are often used in authentication and authorization workflows. Here's how it typically works:

- Authentication: When a user logs in or authenticates, the server generates a JWT and signs it with a secret key. This JWT is then sent back to the client, which can store it locally (e.g., in a cookie or local storage) and include it in subsequent requests to prove its identity.

- Authorization: The server, when receiving a request with a JWT, can verify the token's signature using the secret key. If the signature is valid, the server can trust the claims within the token to make authorization decisions, such as determining if the user has the right permissions to access a resource.

4. Statelessness: The server doesn't need to store session data because all the necessary information is contained within the token itself. This can simplify the design of distributed systems.

5. Expiration: JWTs can have an expiration time (specified in the "exp" claim), which means they are only valid for a certain period
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/20024722-91aa-4810-bf85-3e461a52727b)

## 
