# LinkedIn Learning

# Table of contents

- [LinkedIn Learning](#linkedin-learning)
  - [ğ— ğ—®ğ˜€ğ˜ğ—²ğ—¿ğ—¶ğ—»ğ—´ ğ——ğ—²ğ˜ƒğ—¢ğ—½ğ˜€: ğ—” ğ—©ğ—¶ğ˜€ğ˜‚ğ—®ğ—¹ ğ—šğ˜‚ğ—¶ğ—±ğ—²](#----)
  - [Hospital Managment SpringBoot APP](#hospital-managment-springboot-app)
  - [List of common annotations/methods used with Spring boot testing ğŸ”¥](#list-of-common-annotationsmethods-used-with-spring-boot-testing-)
  - [Companies List that are HIRING for 100% REMOTE.](#companies-list-that-are-hiring-for-100-remote)
  - [Scrum](#scrum)
  - [24 repos you can't miss out as a software engineer:](#24-repos-you-cant-miss-out-as-a-software-engineer)
    - [Interview preparation:](#interview-preparation)
    - [System design:](#system-design)
    - [LLM/AI:](#llmai)
    - [Complete roadmaps:](#complete-roadmaps)
    - [Frontend:](#frontend)
  - [Choosing the right database for your needs? Consider these points:](#choosing-the-right-database-for-your-needs-consider-these-points)
  - [6 Must Know Software Architectural Patterns](#6-must-know-software-architectural-patterns)
  - [Core Components of System Architecture](#core-components-of-system-architecture)
  - [ğ‡ğ¨ğ° ğ‘ğ„ğ’ğ“ ğ€ğğˆ ğ°ğ¨ğ«ğ¤?](#---)
  - [Single Sign-On (SSO) explained in simple terms.](#single-sign-on-sso-explained-in-simple-terms)
    - [ğ—ğ—²ğ˜† ğ—£ğ—¹ğ—®ğ˜†ğ—²ğ—¿ğ˜€ ğ—¶ğ—» ğ—¦ğ—¦ğ—¢](#---)
    - [ğ—•ğ—²ğ—»ğ—²ğ—³ğ—¶ğ˜ğ˜€ ğ—¼ğ—³ ğ—¦ğ—¦ğ—¢](#--)
    - [ğ—›ğ—¼ğ˜„ ğ—¦ğ—¦ğ—¢ ğ—ªğ—¼ğ—¿ğ—¸ğ˜€](#--)
  - [ChatGPT Mastery Cheat Sheet](#chatgpt-mastery-cheat-sheet)
  - [Hands-On Guide: Implementing CI/CD for your web application with AWS Codepipeline](#hands-on-guide-implementing-cicd-for-your-web-application-with-aws-codepipeline)
  - [IBM and Meta offering Web Development Courses for everyone.ğŸš€ğŸš€](#ibm-and-meta-offering-web-development-courses-for-everyone)
  - [How DNS Works - A Simplified Overview](#how-dns-works---a-simplified-overview)
  - [Insights into SSL Certificate Workflow:](#insights-into-ssl-certificate-workflow)
  - [Sorting algorithms](#sorting-algorithms)
  - [Log Parsing Cheat Sheet](#log-parsing-cheat-sheet)
  - [ğ‡ğ¨ğ° ğğ¨ ğ©ğ«ğ¨ğ­ğ¨ğœğ¨ğ¥ğ¬ ğ°ğ¨ğ«ğ¤ ğ¢ğ§ ğ­ğ¡ğ ğ“ğ‚ğ/ğˆğ ğ¨ğ« ğğ’ğˆ ğŒğ¨ğğğ¥â“](#---------)
  - [Java Exceptions](#java-exceptions)
  - [ğ—¢ğ—½ğ˜ğ—¶ğ—ºğ—¶ğ˜€ğ—² ğ—¬ğ—¼ğ˜‚ğ—¿ ğ——ğ—¼ğ—°ğ—¸ğ—²ğ—¿ ğ—ªğ—¼ğ—¿ğ—¸ğ—³ğ—¹ğ—¼ğ˜„ ğŸš€ğŸ’»](#----)
  - [Forget web developers/Web Designer](#forget-web-developersweb-designer)
  - [Session, Cookie, JWT, Token, SSO, and OAuth 2.0 Explained in One Diagram](#session-cookie-jwt-token-sso-and-oauth-20-explained-in-one-diagram)
  - [Top 12 Tips for API Security](#top-12-tips-for-api-security)
  - [](#)
  - 
## ğ— ğ—®ğ˜€ğ˜ğ—²ğ—¿ğ—¶ğ—»ğ—´ ğ——ğ—²ğ˜ƒğ—¢ğ—½ğ˜€: ğ—” ğ—©ğ—¶ğ˜€ğ˜‚ğ—®ğ—¹ ğ—šğ˜‚ğ—¶ğ—±ğ—²
![1706844743207](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/0f083413-adab-46d8-a0c4-0f0a4c469694)

## Hospital Managment SpringBoot APP
- Hospital Management API built in Spring Boot
- https://github.com/MirnaGama/hospital-management-api

## List of common annotations/methods used with Spring boot testing ğŸ”¥
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/a174cbf6-fe9d-49ca-bb92-d18d2e19724d)

## Companies List that are HIRING for 100% REMOTE.

1. Quest Software - https://lnkd.in/gqaB5RTN
2. Upstart - https://lnkd.in/g3sXD8DZ
3. Celigo - https://lnkd.in/gKhSMxNY (US & India)
4. Cengage Group - https://lnkd.in/gGkT6jRZ
5. Docker, Inc - https://lnkd.in/gfX5-pQG
6. hims & hers - https://lnkd.in/gr_SdVdE
7. UserGems ğŸ’ Interviews - https://lnkd.in/gXi3mNf6
8. Abnormal Security - https://lnkd.in/gn5M4VDF
9. Cash App - https://lnkd.in/gdp8yUm8
10. LogicGate - https://lnkd.in/gjgX27Bc
11. Faire - https://lnkd.in/gYRNr9VM
12. Renaissance Learning - https://lnkd.in/gesiM_Dw
13. Rec Room - https://lnkd.in/gErDuTNa
14. VGS (Very Good Security) - https://lnkd.in/g7Ajb77F
15. VAST Data - https://lnkd.in/gMUFt4y9
16. Sorcero - https://lnkd.in/gpmDTnH7
17. McGraw Hill - https://lnkd.in/g59pzFf4
18. Patreon - https://lnkd.in/gzQptMcQ (NY/San Francisco)
19. Beekeeper - https://lnkd.in/gxd7rs7Q (Senior PMM)
20. Upwork - https://lnkd.in/gt4HYmd6
21. DocuSign - https://lnkd.in/ggfUncZf
22. DealHub.io - https://lnkd.in/gyNED4yp
23. Census - https://lnkd.in/gAq7PGzc
24. Intrado - https://lnkd.in/gH3wuNWZ
25. Cloudflare - https://lnkd.in/g9JPXp2F
26. Funded.club - https://lnkd.in/gpH4FazA
27. Workiva - https://lnkd.in/g-FUYYdR
28. MissionWired - https://lnkd.in/gMA6AVdG
29. Workera - https://lnkd.in/g2YzZu-H
30. Jenius Bank - https://lnkd.in/gxGqHGkH

## Scrum

![1706495418935](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/9b3c8b1f-8318-4eca-86c4-17645650dc25)

## 24 repos you can't miss out as a software engineer:

### Interview preparation:

1. Tech Interview Handbook: https://lnkd.in/d2F5z4Af (by Yangshun Tay)

2. Guide to software engineering interviews: https://lnkd.in/dm2MbsgD (by Kevin Naughton)

3. Devops exercises: https://lnkd.in/dPCDT55k

### System design:

4. Big Tech engineering tech blogs: https://lnkd.in/dJaGjeES

5. System Design 101: https://lnkd.in/d5itZHgQ (by Alex Xu)

6. System design primer: https://lnkd.in/dkPScaCW (by Donne Martin)

7. Essential JS design patterns: https://lnkd.in/dWmBwK-i (by Addy Osmani)

8. Awesome scalability: https://lnkd.in/de4UZbiA

9. Awesome System Design Resources: https://lnkd.in/dU6wFXkn (by Ashish Pratap Singh)

10. Coding Challenges solutions: https://lnkd.in/dJV_8pgH (by John Crickett)

### LLM/AI:

11. Hands on LLM: https://lnkd.in/dww8GPdt (by Paul Iusztin)

12. Papers we love: https://lnkd.in/dkjsCq8z

13. Notes on AI for software engineers: https://lnkd.in/dANSnC4f

14. LLM 101 course: https://lnkd.in/dVKwvVUR (by Maxime Labonne)

15. ML paper of the week: https://lnkd.in/d66HxP52 (by Elvis S.)

### Complete roadmaps:

16. Path to senior engineer handbook: https://lnkd.in/dC3dQvy6 (by Jordan Cutler)

17. 100+ Resources to become a great Engineering leader: https://lnkd.in/dFwV2GMv (by Gregor Ojstersek)

18. DevOps roadmap in 2024: https://lnkd.in/ddE5DkDJ (by Dr Milan MilanoviÄ‡)

19. The Book of Secret Knowledge: https://lnkd.in/d69jrK4T

20. Free programming books: https://lnkd.in/d5JCRakw

21. The ultimate developer roadmap: https://lnkd.in/dsCJgDnS (by Kamran Ahmed)

### Frontend:

22. CSS for JS dev notes: https://lnkd.in/dCNavrNv (by Tiger Abrodi)

23. Javascript Questions: https://lnkd.in/dt_96xJZ (by Lydia Hallie)

24. Typescript advanced patterns workshop: https://lnkd.in/deTBDhCb (by Matt Pocock)

If you liked this, you'll love Hungry Minds, my free weekly newsletter curating the best deep dives, trends and tools to grow as a software engineer: https://hungryminds.dev

## Choosing the right database for your needs? Consider these points:
1 ACID Transactions (OLTP): RDS, Aurora, Azure SQL Database

2 Relational (Cloud Agnostic): SQL Server, Oracle, Cockroach, MySQL, PostgreSQL

3 Analytics (OLAP) Columnar: RedShift, Azure Synapse, Snowflake, BigQuery, Databricks, HIVE

4 Memory-store In-memory: Redis, Memcached, Hazelcast, Ignite

5 Key-Value: Redis, DynamoDB, CosmosDB, BigTable, RocksDB, Ignite

6 Wide Column Data Type: HBase, Cassandra, ScyllaDB

7 Semi-Structured: CosmosDB, BigTable, BigQuery, HBase, Cassandra

8 Time Series: CosmosDB, BigTable, BigQuery, TimescaleDB, OpenTSDB, InfluxDB

9 Graph: Neptune, CosmosDB, JanusGraph, Table Graph, Solr, PostGIS, MongoDB (GeoJSON), OrientDB, Neo4J, Tiger Graph
10 Document: CosmosDB, Firestore, MongoDB, Couchbase

11 Full Text Search: Cloud-Search, Cognitive Search, Elastic-Search, Solr, Elassandra

12 Unstructured (Rich) Text: S3, Blob Storage, Cloud Storage, HDFS, Blob

![1706096041699](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/86629c73-2387-4d2c-95c7-b3de74c11843)

## 6 Must Know Software Architectural Patterns
1 - Event-Driven Architecture
Decoupled Components and Asynchronous Communication.
Application: Ideal for systems where events trigger actions, fostering scalability and responsiveness.

2 - Layered Architecture
Hierarchical Structure with Distinct Layers (Presentation, Business Logic, Data).
Application: Common in enterprise applications, enhancing maintainability through compartmentalization and modular development.

3 - Monolithic Architecture
Unified Codebase and Deployment Unit.
Application: Suited for smaller applications or simplicity-focused instances. Streamlines development and deployment with potential scaling challenges.

4 - Microservices Architecture
Distributed System with Independent, Interoperable Services.
Application: Ideal for large and intricate systems, improving scalability, fault isolation, and enabling independent service development.

5 - Model-View-Controller (MVC)
Segregation of Concerns into Model, View, and Controller Components.
Application: Common in web applications, enhancing code organization and maintenance by separating complex UI logic.

6 - Master-Slave Architecture
Centralized Control (Master) with Multiple Worker Nodes (Slaves).
Application: Ubiquitous in distributed computing, optimizing parallel processing and load balancing.

![1706103060616](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/be177349-23dc-4156-88f4-65c1bbd158ad)


## Core Components of System Architecture
[Distributed Messaging Queues]
Enables seamless communication between different components of a system, ensuring efficient message exchange.

[DNS (Domain Name System)]
Facilitates the translation of user-friendly domain names into IP addresses, enabling browsers to locate web servers on the internet.

[Load Balancer]
Distributes incoming web traffic across multiple servers, ensuring optimal resource utilization and preventing overload on individual servers.

[Distributed Caching]
Stores frequently used data efficiently, reducing the need for repeated retrieval from slower databases.

[Database]
Organizes, stores, and retrieves data, serving as a central hub for various applications and services.

[Distributed Task Scheduler]
Efficiently organizes and assigns tasks across different system components, ensuring coordinated operations.

[Observability]
Provides insights into system performance, aiding issue identification and maintaining optimal functioning.

[Unstructured Data Storage]
Accommodates various data types without requiring predefined structures, offering flexibility.

[Scaling Services]
Enables the system to handle increased traffic and demand by expanding its capacity.

[Publish-Subscribe Model]
Facilitates communication between different system parts without direct connections.

[Unique ID Generator]
Creates distinct identifiers for each piece of data, ensuring data integrity and uniqueness.

[Rate-Limiting]
Controls the flow of requests to maintain a steady and manageable pace, preventing strain on the system.

![1706103060616](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/b0885934-5c90-42bd-8124-284f347456fb)

## ğ‡ğ¨ğ° ğ‘ğ„ğ’ğ“ ğ€ğğˆ ğ°ğ¨ğ«ğ¤?
At its core, ğ‘ğ„ğ’ğ“ (ğ‘ğğ©ğ«ğğ¬ğğ§ğ­ğšğ­ğ¢ğ¨ğ§ğšğ¥ ğ’ğ­ğšğ­ğ ğ“ğ«ğšğ§ğ¬ğŸğğ«) is an architectural style that provides a set of constraints for designing networked applications. REST APIs serve as the building blocks for communication between different software components, enabling them to request and exchange data seamlessly.

Here's a simplified breakdown of REST API for you!

ğ‘ğğ¬ğ¨ğ®ğ«ğœğğ¬: REST revolves around resources, which can be anything from a user profile to a product catalog. Each resource is uniquely identified by a URL, forming the basis for interactions.

ğ‡ğ“ğ“ğ ğ•ğğ«ğ›ğ¬: REST APIs make use of the HTTP methods (GET, POST, PUT, DELETE, etc.) to perform actions on resources. For instance, a GET request retrieves data, while a POST request creates new data.

ğ’ğ­ğšğ­ğğ¥ğğ¬ğ¬ ğ‚ğ¨ğ¦ğ¦ğ®ğ§ğ¢ğœğšğ­ğ¢ğ¨ğ§: One of REST's key principles is statelessness. Each request to a REST API should contain all the information needed to understand and process it, making the interactions independent of one another.

ğ”ğ§ğ¢ğŸğ¨ğ«ğ¦ ğˆğ§ğ­ğğ«ğŸğšğœğ: REST APIs have a consistent and uniform interface that follows conventions. This predictability simplifies development and integration.

ğ‘ğğ©ğ«ğğ¬ğğ§ğ­ğšğ­ğ¢ğ¨ğ§: Resources are represented in a format, often JSON or XML. This representation is sent between the client and server to carry information.

ğ‚ğ¥ğ¢ğğ§ğ­-ğ’ğğ«ğ¯ğğ« ğ€ğ«ğœğ¡ğ¢ğ­ğğœğ­ğ®ğ«ğ: REST emphasizes the separation between clients (the user interface) and servers (the data storage and processing), allowing for greater scalability and flexibility.

So, the next time you interact with an app on your smartphone, think about how REST APIs enable it to fetch your latest messages, update your profile, or show you the news. REST is the behind-the-scenes magician that ensures everything works seamlessly.

Let's keep the conversation going and demystify the tech that powers our digital world!

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/05d80a5f-5e68-494b-a5ed-28ddbfbc7f0f)

## Single Sign-On (SSO) explained in simple terms.

### ğ—ğ—²ğ˜† ğ—£ğ—¹ğ—®ğ˜†ğ—²ğ—¿ğ˜€ ğ—¶ğ—» ğ—¦ğ—¦ğ—¢

1. User - The individual seeking access to applications
2. Identity Provider (IDP) - Authenticates users (e.g. Google, Facebook)
3. Application - The software or service the user wants to access

### ğ—•ğ—²ğ—»ğ—²ğ—³ğ—¶ğ˜ğ˜€ ğ—¼ğ—³ ğ—¦ğ—¦ğ—¢

- Simplifies access with one set of credentials
- Enhances user experience
- Reduces password fatigue
- Centralizes security and access management
- Improves security
- Streamlines access control
- Simplifies compliance reporting
- Allows seamless integration

### ğ—›ğ—¼ğ˜„ ğ—¦ğ—¦ğ—¢ ğ—ªğ—¼ğ—¿ğ—¸ğ˜€

- User tries to log into an application
- Application redirects user to SSO/IDP
- IDP authenticates user
- IDP issues authenticated token
- Token sent back to browser
- Browser presents token to application
- Application grants access without re-entering credentials

This streamlined process enables single login access to multiple applications, improving convenience and security.

Over to you: With SSO facilitating access across various platforms, what measures do you consider essential to maintain the integrity and security of user identities?

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/9d4a2610-84ee-4061-a416-e797ec3783c7)

## ChatGPT Mastery Cheat Sheet
Unlock the full potential of ChatGPT:

ğ—”ğ—°ğ˜ ğ—®ğ˜€ ğ—® [ğ—¥ğ—¢ğ—Ÿğ—˜]:
â€¢ Support Representative
â€¢ Code Debugger
â€¢ Language Translator

ğ— ğ—¼ğ—±ğ—²ğ˜€ ğ—®ğ—»ğ—± ğ—¥ğ—¼ğ—¹ğ—²ğ˜€:
â€¢ Generate Ideas for [Project]
â€¢ Plan Schedule for [Event]
â€¢ Edit Content for [Publication]

ğ—¦ğ—²ğ˜ ğ—§ğ—¼ğ—»ğ—²ğ˜€:
â€¢ Formal
â€¢ Casual
â€¢ Enthusiastic

ğ—–ğ—¿ğ—²ğ—®ğ˜ğ—² ğ—® ğ—§ğ—®ğ˜€ğ—¸:
â€¢ Generate Code
â€¢ Plan Outline
â€¢ Write Story

ğ——ğ—²ğ—³ğ—¶ğ—»ğ—² [ğ—™ğ—¼ğ—¿ğ—ºğ—®ğ˜]:
â€¢ Bullet Points
â€¢ List
â€¢ Code Snippet

ğ—”ğ˜‚ğ˜ğ—¼ğ—ºğ—®ğ˜ğ—¶ğ—¼ğ—»:
â€¢ Streamlining Processes
â€¢ Repetitive Tasks
â€¢ Operational Streamlining

ğ—¥ğ—²ğ˜€ğ—²ğ—®ğ—¿ğ—°ğ—µ ğ—£ğ—¿ğ—¼ğ—ºğ—½ğ˜ğ˜€:
â€¢ Summarize Scientific Article
â€¢ Compile Recent Studies on [Topic]
â€¢ Explore Recent Research Studies

ğ——ğ—²ğ˜€ğ—¶ğ—´ğ—»ğ—²ğ—¿ ğ—£ğ—¿ğ—¼ğ—ºğ—½ğ˜ğ˜€:
â€¢ Design Distinctive Logo
â€¢ Develop Website Mockup
â€¢ Generate Color Palette

ğ— ğ—®ğ—¿ğ—¸ğ—²ğ˜ğ—²ğ—¿ ğ—£ğ—¿ğ—¼ğ—ºğ—½ğ˜ğ˜€:
â€¢ Craft Persuasive Marketing Copy
â€¢ Develop Tagline Ideas
â€¢ Create Social Media Posts

ğ——ğ—²ğ˜ƒğ—²ğ—¹ğ—¼ğ—½ğ—²ğ—¿ ğ—£ğ—¿ğ—¼ğ—ºğ—½ğ˜ğ˜€:
â€¢ Resolve Code Issues
â€¢ Generate Python Script
â€¢ Explain Algorithmic Concepts

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/ac24ee39-3ebc-4f9d-812e-a02abeaa7d6d)

## Hands-On Guide: Implementing CI/CD for your web application with AWS Codepipeline
https://www.linkedin.com/posts/mtayyabsattar_implementing-cicd-for-your-web-application-activity-7152670931243446274-fIw0?utm_source=share&utm_medium=member_desktop

## IBM and Meta offering Web Development Courses for everyone.ğŸš€ğŸš€

Repost so that all can take benifits

ğˆğğŒ ğ–ğğ› ğƒğğ¯ğğ¥ğ¨ğ©ğ¦ğğ§ğ­ ğ‚ğ¨ğ®ğ«ğ¬ğğ¬

ğŸ‘‰ https://lnkd.in/dKYZ_F9i

1. IBM Full Stack Software Developer Professional Certificate
ğŸ‘‰ https://lnkd.in/dADYt4Wz

2. Introduction to Web Development with HTML, CSS, JavaScript
ğŸ‘‰ https://lnkd.in/dgs9bQ-6

3. IBM Front-End Developer Professional Certificate
ğŸ‘‰ https://lnkd.in/dmP3PDaU

4. IBM Back-End Development Professional Certificate
ğŸ‘‰ https://lnkd.in/dfkdxEEr

5. IBM Python for Data Science, AI & Development
ğŸ‘‰ https://lnkd.in/dwVbZt7b

6. IBM Developing Cloud Apps with Node.js and React
ğŸ‘‰ https://lnkd.in/dSqJck7A

ğŒğğ­ğš ğ–ğğ› ğƒğğ¯ğğ¥ğ¨ğ©ğ¦ğğ§ğ­ ğ‚ğ¨ğ®ğ«ğ¬ğğ¬

1. Meta Front-End Developer Professional Certificate
ğŸ‘‰https://lnkd.in/dE7FKwMp

2. Meta React Native Specialization
ğŸ‘‰ https://lnkd.in/dXCs5ewA

3. Introduction to Front-End Development
ğŸ‘‰ https://lnkd.in/dxmyJ2iw

4. Meta HTML and CSS in depth
ğŸ‘‰ https://lnkd.in/dwyWkpqK

5. Advanced React
ğŸ‘‰ https://lnkd.in/dBaF8Krj

6. HTML, CSS, and Javascript for Web Developers
ğŸ‘‰ https://lnkd.in/d3Zm2h3P

7. Web Design for Everybody: Basics of Web Development & Coding Specialization
ğŸ‘‰ https://lnkd.in/dudsqPYK

8. Introduction to Web Development
ğŸ‘‰ https://lnkd.in/drdy75ig

9. Responsive Website Development and Design Specialization
ğŸ‘‰ https://lnkd.in/dn425Hps

10. Full Stack Web Development en EspaÃ±ol Specialization
ğŸ‘‰ https://lnkd.in/dPQ92M4u

11. Web Applications for Everybody Specialization
ğŸ‘‰ https://lnkd.in/dt_HS7Pm

## How DNS Works - A Simplified Overview
[1] User Types a URL:
A user enters a website's URL (Uniform Resource Locator) into their browser.
[2] Browser Contacts DNS Resolver:
The browser checks its local DNS resolver (usually provided by the internet service provider) to find the IP address associated with the entered domain.
[3] DNS Resolver Searches Cache:
The DNS resolver checks its cache for a previously resolved IP address for the requested domain. If found, the process skips to the next step.
[4] Recursive DNS Query:
If the resolver doesn't have the IP address, it starts a recursive query. It contacts the root DNS server, asking for information about the top-level domain (TLD) of the requested site.
[5] Root DNS Server Response:
The root DNS server responds with the TLD DNS server's address.
[6] TLD DNS Server Inquiry:
The resolver contacts the TLD DNS server, asking for information about the authoritative DNS server for the specific domain.
[7] Authoritative DNS Server Contact:
The TLD DNS server responds with the IP address of the authoritative DNS server for the domain.
[8] Domain's Authoritative DNS Server Response:
The resolver contacts the authoritative DNS server, requesting the IP address associated with the domain.
[9] Authoritative DNS Server Provides IP:
The authoritative DNS server responds with the IP address of the requested domain.
[10] DNS Resolver Caches IP:
The DNS resolver caches the obtained IP address for future use and sends it to the user's browser.
[11] Browser Connects to IP Address:
The browser uses the obtained IP address to connect to the web server hosting the requested website.

![1705680493626](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/3b64d226-cf65-481b-bcea-3cfb65a0bba3)


## Insights into SSL Certificate Workflow:
ClientHello:
The client initiates the SSL/TLS handshake by sending a "ClientHello" message to the server, indicating its intent to establish a secure connection.

ServerHello and Certificate Exchange:
The server responds with a "ServerHello" message, selecting a cipher suite for secure communication. It then presents its SSL certificate to the client, initiating the certificate exchange.

Trust Verification and Key Exchange:
The client verifies the certificate's authenticity by checking its digital signature against trusted CAs. Simultaneously, both parties engage in a key exchange, using public-key cryptography to establish a shared secret key.

Pre-master Secret and Session Keys:
The client generates a pre-master secret, encrypts it with the server's public key, and sends it back. Both client and server independently derive session keys from the pre-master secret, ensuring secure communication.

Finished:
Both parties exchange "Finished" messages, confirming that the handshake is complete. From this point onward, the established session keys encrypt and decrypt data, securing the communication channel.

![1705331828985](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/f56f48e4-6104-4899-80a7-d2e6c30ca12c)

## Sorting algorithms 
Sorting algorithms are fundamental techniques in computer science and are used to rearrange elements in a specified order. The efficiency of sorting algorithms is often evaluated based on factors like time complexity, space complexity, and stability.
âœ…Bubble Sort:
ğŸ”¶ Description: Bubble sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.
ğŸ”¶ Time Complexity: O(n^2) in the worst and average case, O(n) in the best case (when the list is already sorted).
ğŸ”¶ Space Complexity: O(1) (in-place algorithm).
âœ… Selection Sort:
ğŸ”¶ Description: Selection sort divides the input into a sorted and an unsorted region. It repeatedly selects the smallest (or largest, depending on the order) element from the unsorted region and moves it to the sorted region.
ğŸ”¶ Time Complexity: O(n^2) regardless of input.
ğŸ”¶ Space Complexity: O(1) (in-place algorithm).
âœ… Insertion Sort:
ğŸ”¶ Description: Insertion sort builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.
ğŸ”¶ Time Complexity: O(n^2) in the worst and average case, O(n) in the best case.
ğŸ”¶ Space Complexity: O(1) (in-place algorithm).
âœ… Merge Sort:
ğŸ”¶ Description: Merge sort is a divide-and-conquer algorithm that divides the input array into two halves, recursively sorts them, and then merges the sorted halves.
ğŸ”¶ Time Complexity: O(n log n) in all cases.
ğŸ”¶ Space Complexity: O(n) additional space is required for the merging process.
âœ… Quick Sort:
ğŸ”¶ Description: Quick sort is another divide-and-conquer algorithm that partitions the array into two parts, with elements less than a chosen pivot on one side and elements greater on the other. The process is applied recursively to the two sub-arrays.
ğŸ”¶ Time Complexity: O(n^2) in the worst case, O(n log n) on average.
ğŸ”¶ Space Complexity: O(log n) on average for the recursive call stack.
âœ… Heap Sort:
ğŸ”¶ Description: Heap sort is based on the binary heap data structure. It first builds a max heap from the input array and repeatedly extracts the maximum element, ensuring that the remaining elements form a valid heap.
ğŸ”¶ Time Complexity: O(n log n) in all cases.
ğŸ”¶ Space Complexity: O(1) (in-place algorithm).
Sorting algorithms are chosen based on the specific requirements of the application and the characteristics of the data to be sorted. Different algorithms may be more suitable for different scenarios, depending on factors such as data size, stability, and memory constraints.

![1705509378264](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/a280c10d-a4b6-48eb-a070-19616b9527a3)

## Log Parsing Cheat Sheet

The diagram below lists the ğ˜ğ—¼ğ—½ ğŸ² ğ—¹ğ—¼ğ—´ ğ—½ğ—®ğ—¿ğ˜€ğ—¶ğ—»ğ—´ ğ—°ğ—¼ğ—ºğ—ºğ—®ğ—»ğ—±ğ˜€.

1. GREP

GREP searches any given input files, selecting lines that match one or more patterns.

2. CUT

CUT cuts out selected portions of each line from each file and writes them to the standard output.

3. SED

SED reads the specified files, modifying the input as specified by a list of commands.

4. AWK

AWK scans each input file for lines that match any of a set of patterns.

5. SORT

SORT sorts text and binary files by lines.

6. UNIQ

UNIQ reads the specified input file comparing adjacent lines and writes a copy of each unique input line to the output file.

ğ—Ÿğ—²ğ˜â€™ğ˜€ ğ˜„ğ—®ğ—¹ğ—¸ ğ˜ğ—µğ—¿ğ—¼ğ˜‚ğ—´ğ—µ ğ—®ğ—» ğ—²ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—².

To count the number of hits from the top 10 IP addresses requesting the path "/api/payments" from the access log in this common log format:

216.67.1.91 - leon [01/Jul/2002:12:11:52 +0000] "GET /index.html HTTP/1.1" 200 431

We can use a combination of grep, cut, sort, and uniq commands. ğ—›ğ—²ğ—¿ğ—² ğ—¶ğ˜€ ğ—® ğ˜€ğ—®ğ—ºğ—½ğ—¹ğ—² ğ—°ğ—¼ğ—ºğ—ºğ—®ğ—»ğ—±:

grep '/api/payments' access.log | cut -d ' ' -f 1 | sort | uniq -c | sort -rn | head -10

Here's what each part of the command does:

- grep '/api/payments' access.log: This filters the lines containing "/api/payments" from the access.log file.

- cut -d ' ' -f 1: This extracts the first field (the IP address) from each line. The -d ' ' option specifies space as the field delimiter.

- sort: This sorts the IP addresses.

- uniq -c: This removes duplicate lines and prefixes lines by the number of occurrences.

- sort -rn: This sorts the lines in reverse order (highest first) numerically.

- head -10: This shows only the first 10 lines of the output, which correspond to the top 10 IP addresses.

Over to you: Please share your top log parsing tips and tricks.

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/2a93fe91-df1d-4f08-8beb-39ad5c9f36f8)

## ğ‡ğ¨ğ° ğğ¨ ğ©ğ«ğ¨ğ­ğ¨ğœğ¨ğ¥ğ¬ ğ°ğ¨ğ«ğ¤ ğ¢ğ§ ğ­ğ¡ğ ğ“ğ‚ğ/ğˆğ ğ¨ğ« ğğ’ğˆ ğŒğ¨ğğğ¥â“
The TCP/IP and OSI models are frameworks that describe how data is transmitted over a network.

ğ“ğ‚ğ/ğˆğ ğŒğ¨ğğğ¥:
The TCP/IP model is simpler, with four layers:

Link Layer (Network Interface Layer):

Manages the physical transmission of data over a network. Converts binary data from the Transport Layer into network frames, preparing them for physical transmission over the network.

Components: Network interface cards (NICs), Ethernet, and protocols like ARP (Address 
Resolution Protocol).

Internet Layer (Network Layer):

Handles the logical transmission of data across the network. Determines the best path for data packets to travel across networks using IP addresses.

Components: Routers and protocols like IP (Internet Protocol), ICMP (Internet Control Message Protocol).

Transport Layer:

Manages end-to-end communication between hosts. Ensures data is sent and received in order, without errors. TCP provides reliable communication, while UDP offers faster, but less reliable, transfer.

Components: Protocols like TCP (Transmission Control Protocol) and UDP (User Datagram Protocol).

Application Layer:

Provides protocols for specific user applications. This layer is where user applications interact with the network stack, using protocols suited to different types of data and services.

Components: Protocols like HTTP (Hypertext Transfer Protocol), SMTP (Simple Mail Transfer Protocol).

ğğ’ğˆ ğŒğ¨ğğğ¥:
The OSI model is more detailed, with seven layers:

Physical Layer:

Transmits raw bit stream over the physical medium.Manages the physical connection between devices.

Components: Cables, switches, and the physical aspects of the network.

Data Link Layer:

Ensures error-free transmission over the physical layer. Frames data packets, handles error detection and correction.

Components: Bridges, switches, and protocols like Ethernet.

Network Layer:

Manages device addressing and path determination. Routes data across multiple networks.

Components: Routers, and protocols like IP.

Transport Layer:

Similar to the TCP/IP model, it manages end-to-end communication and data integrity.

Session Layer:

Manages sessions between applications.Establishes, manages, and terminates sessions.

Components: APIs and services that enable communication between machines.

Presentation Layer:

Translates data between the application layer and the network. Ensures that data is in the correct format for the application layer.

Components: Encryption, compression, and translation services.

Application Layer:

Similar to the TCP/IP model, interfaces directly with user applications.

The TCP/IP model is more practical and aligned with real-world networking.
In practice, TCP/IPâ€™s Application Layer encompasses OSI's Application, Presentation, and Session layers.

![1704805635565](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/8b68fccf-46ed-4894-9273-5eff8c342ac2)


## Java Exceptions
You would agree that Exception handling is a critical aspect of a Java Application.

Let's refresh some basic tips on handling exceptions -

[*] Catch with Precision
- Catch specific exceptions rather than generic ones like Exception.
- This allows you to handle each exception type differently and provide tailored solutions.

try {
 // Code that may throw specific exceptions
} catch (FileNotFoundException e) {
 // Handle file not found exception
} catch (IOException e) {
 // Handle IO exception
}


[*] Graceful Error Handling
- When an exception strikes, don't leave your users in the dark!
- Provide meaningful error messages or logs to facilitate troubleshooting and enhance the user experience.

try {
 // Code that may throw an exception
} catch (Exception e) {
 logger.error("An error occurred: " + e.getMessage());
 // Provide meaningful error message to aid in troubleshooting
}


[*] Resource Cleanup with Finesse
- Use the 'finally' block only to release system resources like file handles, database connections, or network connections.

try (FileInputStream fileInputStream = new FileInputStream("file.txt")) {
 // Code
} catch (IOException e) {
 // Handle exception 
} finally {
 // Cleanup: The file input stream will be closed automatically
}


[*] Rethrow Strategically
- Consider whether to re-throw an exception or wrap it in a new one. 
- Rethrowing can be useful for propagating errors, but remember to provide valuable context for smooth debugging.

try {
 // Code that may throw an exception
} catch (IOException e) {
 logger.error("An error occurred: " + e.getMessage());
 throw new CustomException("An error occurred while processing the data.", e);
 // Rethrow the exception while providing additional context
}


[*] Mindful Checked Exceptions
- Choose checked exceptions wisely. Excessive use can clutter code and make it harder to maintain.
- Opt for unchecked exceptions or custom types when they fit the bill.

public void readFile() throws IOException {
 // Code that may throw IOException
}


[*] Embrace the Power of 'try-with-resources':
- For automatic resource management, leverage the elegance of the try-with-resources statement.
- It ensures proper resource closure and minimizes leaks.

try (Connection connection = DriverManager.getConnection(url, username, password);
 Statement statement = connection.createStatement()) {
 // Code that uses the connection and statement
} catch (SQLException e) {
 // Handle any exceptions that occur
}


[*] Ignoring is Not an Option
- Avoid turning a blind eye to exceptions!
  
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/17d4f67f-9115-4b3a-8af0-193d321eaaf2)

## ğ—¢ğ—½ğ˜ğ—¶ğ—ºğ—¶ğ˜€ğ—² ğ—¬ğ—¼ğ˜‚ğ—¿ ğ——ğ—¼ğ—°ğ—¸ğ—²ğ—¿ ğ—ªğ—¼ğ—¿ğ—¸ğ—³ğ—¹ğ—¼ğ˜„ ğŸš€ğŸ’»

Supercharge your Docker skills with these key commands:

ğŸ­. ğ—¿ğ˜‚ğ—»: Launch containers from images.
ğŸ®. ğ˜€ğ˜ğ—¼ğ—½: Gracefully halt running containers.
ğŸ¯. ğ˜€ğ˜ğ—®ğ—¿ğ˜: Revitalize stopped containers.
ğŸ°. ğ—²ğ˜…ğ—²ğ—°: Execute commands within containers.
ğŸ±. ğ—½ğ—¼ğ—¿ğ˜: Identify a container's public-facing port.
ğŸ². ğ—¿ğ—²ğ—»ğ—®ğ—ºğ—²: Give containers new identities.
ğŸ³. ğ—½ğ—®ğ˜‚ğ˜€ğ—²/ğ˜‚ğ—»ğ—½ğ—®ğ˜‚ğ˜€ğ—²: Suspend/resume container processes.
ğŸ´. ğ—¸ğ—¶ğ—¹ğ—¹: Halt running containers.
ğŸµ. ğ—¯ğ˜‚ğ—¶ğ—¹ğ—±: Create custom Docker images.
ğŸ­ğŸ¬. ğ˜ğ—¼ğ—½: Display running processes of a container.
ğŸ­ğŸ­. ğ—°ğ—½: Copy files between containers and local system.
ğŸ­ğŸ®. ğ—¿ğ—º: Remove stopped containers.
ğŸ­ğŸ¯. ğ˜€ğ˜ğ—®ğ˜ğ˜€: Monitor real-time container resource usage.
ğŸ­ğŸ°. ğ—½ğ˜€: View container processes.
ğŸ­ğŸ±. ğ—µğ—¶ğ˜€ğ˜ğ—¼ğ—¿ğ˜†: View image evolution history.
ğŸ­ğŸ². ğ—¶ğ—ºğ—®ğ—´ğ—² ğ—¹ğ˜€: List available Docker images.
ğŸ­ğŸ³. ğ—¹ğ—¼ğ—´ğ˜€: Retrieve and analyze container logs.
ğŸ­ğŸ´. ğ˜ƒğ—²ğ—¿ğ˜€ğ—¶ğ—¼ğ—»: Check Docker version.
ğŸ­ğŸµ. ğ—¶ğ—»ğ—³ğ—¼: Fetch crucial Docker system information.
ğŸ®ğŸ¬. ğ—¶ğ—»ğ˜€ğ—½ğ—²ğ—°ğ˜: Explore details of containers, images, networks.


![1704294993746](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/3bc5086b-9037-4dee-866d-00c8b6550199)


## Forget web developers/Web Designer
Here is the list of 8 AI tool that creates your website in 5 min:

1 10Web.io

It helps users to build or recreate any website with AI in minutes.

2 Dora

Design and publish stunning 3D & animated websites effortlessly, without the need for coding.

3 Durable

Build a website in 30 secs using AI .

4 Bookmark

Get your business online in a minute

5 Framer

It is an amazing tool that makes it possible to create a website in less than two minutes.

6 sitekickai

It allows you to create beautiful landing pages. Without the need for coding, design or copywriting skills.

7 Makelanding AI

Make a beautiful landing page in seconds .

8 Createwebsite

It is not just about creating websites, it's about creating powerful, lightning-fast digital experiences.

## Session, Cookie, JWT, Token, SSO, and OAuth 2.0 Explained in One Diagram
When you login to a website, your identity needs to be managed. Here is how different solutions work:

- Session - The server stores your identity and gives the browser a session ID cookie. This allows the server to track login state. But cookies don't work well across devices.

- Token - Your identity is encoded into a token sent to the browser. The browser sends this token on future requests for authentication. No server session storage is required. But tokens need encryption/decryption.

- JWT - JSON Web Tokens standardize identity tokens using digital signatures for trust. The signature is contained in the token so no server session is needed.

- SSO - Single Sign On uses a central authentication service. This allows a single login to work across multiple sites.

- OAuth2 - Allows limited access to your data on one site by another site, without giving away passwords.

Over to you: QR code logins are gaining popularity. Do you know how it works?


![1703745073045](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/9dadf720-9f36-4b29-9994-6ff234da87d9)


## Top 12 Tips for API Security
- Use HTTPS
- Use OAuth2
- Use WebAuthn
- Use Leveled API Keys
- Authorization
- Rate Limiting
- API Versioning
- Whitelisting
- Check OWASP API Security Risks
- Use API Gateway
- Error Handling
- Input Validation

![1703833728966](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/1766c0c9-f242-4668-8754-227cba85cc0a)

## ğ—¦ğ˜†ğ—ºğ—ºğ—²ğ˜ğ—¿ğ—¶ğ—° ğ˜ƒğ˜€. ğ—”ğ˜€ğ˜†ğ—ºğ—ºğ—²ğ˜ğ—¿ğ—¶ğ—° ğ—˜ğ—»ğ—°ğ—¿ğ˜†ğ—½ğ˜ğ—¶ğ—¼ğ—» ğ—˜ğ˜…ğ—½ğ—¹ğ—®ğ—¶ğ—»ğ—²ğ—± ğŸ”’
Whether you're a cybersecurity enthusiast, a developer, or someone curious about securing digital communication, understanding these encryption methods is necessary.

Let's delve into the key distinctions:

ğ—¦ğ˜†ğ—ºğ—ºğ—²ğ˜ğ—¿ğ—¶ğ—° ğ—˜ğ—»ğ—°ğ—¿ğ˜†ğ—½ğ˜ğ—¶ğ—¼ğ—»:
- Description: Symmetric encryption employs a single, shared key for both encryption and decryption.
- Use Case: Ideal for scenarios where a secure channel already exists for key exchange.

ğ—”ğ˜€ğ˜†ğ—ºğ—ºğ—²ğ˜ğ—¿ğ—¶ğ—° ğ—˜ğ—»ğ—°ğ—¿ğ˜†ğ—½ğ˜ğ—¶ğ—¼ğ—»:
- Description: Asymmetric encryption uses a pair of keys, public and private, for encryption and decryption.
- Use Case: Suitable for secure communication over untrusted networks, eliminating the need for a shared secret.

ğ—ğ—²ğ˜† ğ——ğ—¶ğ—³ğ—³ğ—²ğ—¿ğ—²ğ—»ğ—°ğ—²ğ˜€: ğ—¦ğ˜†ğ—ºğ—ºğ—²ğ˜ğ—¿ğ—¶ğ—° ğ˜ƒğ˜€. ğ—”ğ˜€ğ˜†ğ—ºğ—ºğ—²ğ˜ğ—¿ğ—¶ğ—°

ğŸ­. ğ—ğ—²ğ˜† ğ— ğ—®ğ—»ğ—®ğ—´ğ—²ğ—ºğ—²ğ—»ğ˜:
- Symmetric: Requires secure key distribution mechanisms.
- Asymmetric: Public keys can be openly shared, while private keys are closely guarded.

ğŸ®. ğ—–ğ—¼ğ—ºğ—½ğ˜‚ğ˜ğ—®ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—–ğ—¼ğ—ºğ—½ğ—¹ğ—²ğ˜…ğ—¶ğ˜ğ˜†:
- Symmetric: Generally faster and less computationally intensive.
- Asymmetric: Slower due to complex mathematical operations.

ğŸ¯. ğ—¦ğ—°ğ—®ğ—¹ğ—®ğ—¯ğ—¶ğ—¹ğ—¶ğ˜ğ˜†:
- Symmetric: Efficient for large-scale data encryption.
- Asymmetric: More resource-intensive, especially for bulk data.

ğŸ°. ğ—¨ğ˜€ğ—² ğ—–ğ—®ğ˜€ğ—²ğ˜€:
- Symmetric: Secure, established channels, and resource-constrained environments.
- Asymmetric: Secure communication over untrusted networks, digital signatures, and key exchange.

ğ—¥ğ—²ğ—®ğ—¹-ğ—ªğ—¼ğ—¿ğ—¹ğ—± ğ—”ğ—½ğ—½ğ—¹ğ—¶ğ—°ğ—®ğ˜ğ—¶ğ—¼ğ—»ğ˜€:

ğŸ­. ğ—¦ğ˜†ğ—ºğ—ºğ—²ğ˜ğ—¿ğ—¶ğ—° ğ—˜ğ—»ğ—°ğ—¿ğ˜†ğ—½ğ˜ğ—¶ğ—¼ğ—» ğ—¶ğ—» ğ—£ğ—¿ğ—®ğ—°ğ˜ğ—¶ğ—°ğ—²:
- Utilized in HTTPS/TLS for securing web traffic.
- Commonly applied in VPNs for secure communication between network devices.

ğŸ®. ğ—”ğ˜€ğ˜†ğ—ºğ—ºğ—²ğ˜ğ—¿ğ—¶ğ—° ğ—˜ğ—»ğ—°ğ—¿ğ˜†ğ—½ğ˜ğ—¶ğ—¼ğ—» ğ—¶ğ—» ğ—£ğ—¿ğ—®ğ—°ğ˜ğ—¶ğ—°ğ—²:
- Facilitates secure email communication through digital signatures.
- Forms the basis for secure communication in blockchain technology.

ğ—–ğ—µğ—¼ğ—¼ğ˜€ğ—¶ğ—»ğ—´ ğ˜ğ—µğ—² ğ—¥ğ—¶ğ—´ğ—µğ˜ ğ—˜ğ—»ğ—°ğ—¿ğ˜†ğ—½ğ˜ğ—¶ğ—¼ğ—» ğ—¦ğ˜ğ—¿ğ—®ğ˜ğ—²ğ—´ğ˜†:

- Data Sensitivity: Assess the level of sensitivity of your data and communication.
- Resource Constraints: Consider the computational resources available for encryption and decryption.
- Key Distribution: Evaluate the feasibility of securely distributing and managing encryption keys.


![1703426416669](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/0c21005f-ee3e-4f07-abcd-2c52fe63e926)


## Key Concepts to Understand Database Sharding
Database sharding refers to splitting data across multiple database servers and is commonly used for scaling. However, sharding introduces major operational and infrastructure complexity that should be ğ—®ğ˜ƒğ—¼ğ—¶ğ—±ğ—²ğ—± ğ˜‚ğ—»ğ—¹ğ—²ğ˜€ğ˜€ ğ—®ğ—¯ğ˜€ğ—¼ğ—¹ğ˜‚ğ˜ğ—²ğ—¹ğ˜† ğ—»ğ—²ğ—°ğ—²ğ˜€ğ˜€ğ—®ğ—¿ğ˜†.

ğ—”ğ—½ğ—½ğ—¿ğ—¼ğ—®ğ—°ğ—µğ—²ğ˜€ ğ˜ğ—¼ ğ—½ğ—¼ğ˜€ğ˜ğ—½ğ—¼ğ—»ğ—² ğ˜€ğ—µğ—®ğ—¿ğ—±ğ—¶ğ—»ğ—´

Vertical Scaling: Use more powerful single database servers - more CPUs, memory, storage and I/O bandwidth. Much simpler to manage than sharding while allowing sizable expansion.

SQL Optimization: Tune SQL queries and database schema to maximize performance on a single server. Requires proper indexes, efficient SQL, etc.

Caching: Use in-memory caches like Redis to reduce database load by avoiding hitting it for every common query.

Read Replicas + Load Balancer: Adds horizontal read scaleability without full complexity of sharding. Directs reads across replicas.

These optimization approaches should be ğ—²ğ˜…ğ—µğ—®ğ˜‚ğ˜€ğ˜ğ—²ğ—± ğ—¯ğ—²ğ—³ğ—¼ğ—¿ğ—² ğ˜€ğ—µğ—®ğ—¿ğ—±ğ—¶ğ—»ğ—´ ğ—´ğ—¶ğ˜ƒğ—²ğ—» ğ˜ğ—µğ—² ğ—°ğ—¼ğ—ºğ—½ğ—¹ğ—²ğ˜…ğ—¶ğ˜ğ˜†.

ğ—›ğ—¼ğ—¿ğ—¶ğ˜‡ğ—¼ğ—»ğ˜ğ—®ğ—¹ ğ˜ƒğ˜€ ğ—©ğ—²ğ—¿ğ˜ğ—¶ğ—°ğ—®ğ—¹ ğ—¦ğ—µğ—®ğ—¿ğ—±ğ—¶ğ—»ğ—´

There are two high-level approaches:

Vertical Sharding: Split database into columnar tables or sections vs rows. For example, having one table for names and another table for emails.

Horizontal Sharding: Split database into row partitions distributed evenly across multiple servers.

Some horizontal sharding methods:

1. ğ—¥ğ—®ğ—»ğ—´ğ—² ğ—•ğ—®ğ˜€ğ—²ğ—±: Segment rows based on range values like age groups. Can cause uneven data distribution and hot spots.

2. ğ——ğ—¶ğ—¿ğ—²ğ—°ğ˜ğ—¼ğ—¿ğ˜† ğ—•ğ—®ğ˜€ğ—²ğ—±: Use a lookup directory to locate rows. Allows flexibility but single point of failure risk.

3. ğ—›ğ—®ğ˜€ğ—µ ğ—•ğ—®ğ˜€ğ—²ğ—±: Apply hash functions to spread rows uniformly across shards. Harder to rebalance.

When sharding, use the simplest approach that meets requirements to minimize complexity. Seek to avoid until necessary.

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/08d0d9f4-ca4f-4d82-8946-c85ce05ebafc)

## Logging, tracing and metrics are 3 pillars of system observability. 
The diagram below shows their definitions and typical architectures.

ğŸ”¹ Logging
Logging records discrete events in the system. For example, we can record an incoming request or a visit to databases as events. It has the highest volume. ELK (Elastic-Logstash-Kibana) stack is often used to build a log analysis platform. We often define a standardized logging format for different teams to implement, so that we can leverage keywords when searching among massive amounts of logs.

ğŸ”¹ Tracing
Tracing is usually request-scoped. For example, a user request goes through the API gateway, load balancer, service A, service B, and database, which can be visualized in the tracing systems. This is useful when we are trying to identify the bottlenecks in the system. We use OpenTelemetry to showcase the typical architecture, which unifies the 3 pillars in a single framework.

ğŸ”¹ Metrics
Metrics are usually aggregatable information from the system. For example, service QPS, API responsiveness, service latency, etc. The raw data is recorded in time-series databases like InfluxDB. Prometheus pulls the data and transforms the data based on pre-defined alerting rules. Then the data is sent to Grafana for display or to the alert manager which then sends out email, SMS, or Slack notifications or alerts.

![1703782033069](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/b5f3d648-cbe6-491d-88c2-8d9df3c4acc7)


## How SSO/SAML works!

AssumeRole: Easily switch roles within your AWS account or between accounts for straightforward permission management.

AssumeRoleWithSAML: Use SAML (a secure standard) to get credentials for users, making sure only the right people have access.

AssumeRoleWithWebIdentity: For users signing in via Amazon Cognito, Google, or Facebook, AWS suggests using Cognito for a hassle-free login.

GetSessionToken: Boost security by adding Multi-Factor Authentication (MFA) for users or the main AWS account holder.

GetFederationToken: Great for apps acting on behalf of users, this gives temporary access to those who need it, keeping things flexible yet secure.

Identity Federation in AWS: This lets you extend AWS access to users outside of AWS, without having to individually manage each user. It's great for organizations that already have their own identity systems (like Active Directory) or for apps that need to use AWS resources.

Key features include:

SAML 2.0 Integration: Works smoothly with well-known identity providers, granting temporary access to AWS services.

Custom Identity Broker: A solution for when your identity provider isn't SAML-compatible, managing authentication and AWS access.

Learn more about how SAML and AWS federation can simplify your access management, keeping your AWS resources secure and easily manageable. Dive into the world of AWS Identity Federation and unlock the full potential of your AWS resources!

![1703302178016](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/2c27d8c9-811b-4100-8b11-a2c68ce2e0b1)

## Java Development - Cache Types
Effective caching is fundamental to designing scalable and responsive data-intensive applications.

How it helps?

By caching intermediate results, frequently accessed data, or query results, these applications can minimize the need for repeated and resource-intensive computations.

This enhances application responsiveness and minimizes the impact of I/O operations on performance.

Caching can be implemented at various levels, such as application-level caching, database query result caching, or distributed caching, to ensure timely access to data and improve overall system performance.

Let's talk about different type of Caches -

[1.] L1 Cache
On-CPU cache, includes L1 Instruction Cache (L1i) for machine code instructions and L1 Data Cache (L1d) for frequently used data.

[2.] In-Memory Caching
Uses Java Collections Framework (e.g., HashMap, ConcurrentHashMap) to cache data in memory.

[3.] Distributed Caching
Utilizes frameworks like Ehcache, Hazelcast, or Redis to distribute cached data across multiple nodes.

[4.] Second-Level Caching
In Hibernate, caches database query results to reduce redundant database calls.

[5.] Spring Caching
Leverages Spring's caching abstraction to integrate caching mechanisms (e.g., Ehcache, Redis) into applications.

[6.] Web Caching
Uses HTTP caching headers (e.g., Cache-Control, ETag) for client-side or intermediary proxy caching.

[7.] Query Result Caching
In Hibernate, caches results of database queries to optimize performance.

[8.] Aspect-Oriented Caching
Utilizes AspectJ or Spring AOP to separate caching logic from business logic.

[9.] JCache (JSR-107)
Implements javax.cache, a standard caching API for Java applications.

[10.] Guava Cache
Incorporates Google Guava Cache, an in-memory caching library with features like expiration and eviction.

[11.] OS-Level Caching
Leverages the file system cache for reading frequently accessed files to improve performance.

## Some common #SQL interview questions along with their queries:
1. Write a SQL query to find the second highest salary from the 'emp' table. (Columns: id, salary)
```sql
SELECT MAX(salary) AS second_highest_salary
FROM emp
WHERE salary < (SELECT MAX(salary) FROM emp);
```

2. Write a SQL query to find numbers that consecutively occur 3 times in the 'id' column of a table. (Columns: id, numbers)
```sql
SELECT DISTINCT a.numbers
FROM table_name a, table_name b, table_name c
WHERE a.numbers = b.numbers AND b.numbers = c.numbers
AND a.id = b.id - 1 AND b.id = c.id - 1;
```

3. Write a SQL query to find the days when the temperature was higher than its previous dates. (Columns: Days, Temp)
```sql
SELECT Days, Temp
FROM table_name t1
WHERE Temp > (SELECT Temp FROM table_name t2 WHERE t2.Days = t1.Days - 1);
```
4. Write a SQL query to delete duplicate rows in a table.
```sql
DELETE FROM table_name
WHERE ROWID NOT IN (SELECT MIN(ROWID) FROM table_name GROUP BY column1, column2, ...);
```

5. Write a SQL query for the cumulative sum of salary for each employee from January to July. (Columns: Emp_id, Month, Salary)
```sql
SELECT Emp_id, Month, SUM(Salary) OVER (PARTITION BY Emp_id ORDER BY Month) AS Cumulative_Salary
FROM salary_table
WHERE Month BETWEEN 'January' AND 'July';
```

6. Write a SQL query to display year-on-year growth for each product. (Columns: transaction_id, Product_id, transaction_date, spend, Output: year, product_id, yoy_growth)
```sql
SELECT EXTRACT(YEAR FROM transaction_date) AS year,
    Product_id,
    (spend - LAG(spend, 1, 0) OVER (PARTITION BY Product_id ORDER BY transaction_date)) / LAG(spend, 1, 0) OVER (PARTITION BY Product_id ORDER BY transaction_date) * 100 AS yoy_growth
FROM transactions;
```

7. Write a SQL query to find the rolling average of posts on a daily basis for each user_id. (Columns: user_id, date, post_count)
```sql
SELECT user_id,
    date,
    ROUND(AVG(post_count) OVER (PARTITION BY user_id ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW), 2) AS rolling_average
FROM posts_table;
```
8. Write a SQL query to get emp id and department for each department, considering employees who recently joined the organization and are currently working. (Columns: emp id, first name, last name, date of join, date of exit, department)
```sql
SELECT e.emp_id, e.first_name, e.last_name, e.date_of_join, e.date_of_exit, d.department
FROM employees e
JOIN departments d ON e.department_id = d.department_id
WHERE e.date_of_join > DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)
AND e.date_of_exit IS NULL;
```
9. Write a query to get mean, median, and mode for earning? (Columns: Emp_id, salary)
```sql
SELECT 
 AVG(salary) AS mean_earning, 
 PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) AS median_earning,
 MODE() WITHIN GROUP (ORDER BY salary) AS mode_earning
FROM earnings_table;
```

## ğ— ğ—¶ğ—°ğ—¿ğ—¼ğ˜€ğ—²ğ—¿ğ˜ƒğ—¶ğ—°ğ—²ğ˜€ ğ—¥ğ—¼ğ—®ğ—±ğ—ºğ—®ğ—½: ğ€ ğ‚ğ¨ğ¦ğ©ğ«ğğ¡ğğ§ğ¬ğ¢ğ¯ğ ğ†ğ®ğ¢ğğ ğ­ğ¨ ğğ®ğ¢ğ¥ğğ¢ğ§ğ  ğŒğ¨ğğğ«ğ§ ğ€ğ«ğœğ¡ğ¢ğ­ğğœğ­ğ®ğ«ğğ¬ ğŸš€
ğ——ğ—®ğ˜ğ—®ğ—¯ğ—®ğ˜€ğ—²ğ˜€:
- SQL: Traditional relational databases for structured data.
- NoSQL: Flexible, scalable databases for unstructured data.
- MySQL, PostgreSQL: Popular SQL databases.
- MongoDB, Cassandra, DynamoDB, HBase: Leading NoSQL databases.

ğ— ğ—²ğ˜€ğ˜€ğ—®ğ—´ğ—² ğ—•ğ—¿ğ—¼ğ—¸ğ—²ğ—¿:
- Kafka, RabbitMQ, Amazon SQS: Efficient and reliable message brokers for seamless communication between microservices.

ğ— ğ—¼ğ—»ğ—¶ğ˜ğ—¼ğ—¿ğ—¶ğ—»ğ—´:
- Grafana, Kibana, Prometheus: Monitoring tools providing visibility into microservices' performance and health.

ğ—Ÿğ—®ğ—»ğ—´ğ˜‚ğ—®ğ—´ğ—²ğ˜€:
- Java, .Net, Go, NodeJS, Python: A diverse set of languages catering to different development preferences and requirements.

ğ—–ğ—œ/ğ—–ğ——:
- GitHub Actions, Jenkins, TeamCity, Gitlab, CircleCI: CI/CD tools automating the development, testing, and deployment process.

ğ—¦ğ—²ğ—°ğ˜‚ğ—¿ğ—¶ğ˜ğ˜†:
- JWT, OAuth 2.0, API Authz., TLS: Essential security protocols and encryption methods ensuring data integrity and access control.

ğ—–ğ—¹ğ—¼ğ˜‚ğ—± ğ—£ğ—¿ğ—¼ğ˜ƒğ—¶ğ—±ğ—²ğ—¿:
- AWS, Azure, GCP, Linode, Digital Ocean: Cloud providers offering infrastructure and services for hosting microservices.

ğ—–ğ—¼ğ—»ğ˜ğ—®ğ—¶ğ—»ğ—²ğ—¿ ğ—¢ğ—¿ğ—°ğ—µğ—²ğ˜€ğ˜ğ—¿ğ—®ğ˜ğ—¶ğ—¼ğ—»:
- ECS, Open Shift, Hashicorp, Kubernetes: Orchestrators facilitating the deployment, scaling, and management of containerized applications.

ğ—–ğ—¼ğ—»ğ˜ğ—®ğ—¶ğ—»ğ—²ğ—¿ğ˜€:
- Docker, Podman: Containerization technologies ensuring consistency and portability across different environments.

![1703426210710](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/71a1eb62-2c49-4b7b-9c02-5fc6225ebd1b)


## ğ—Ÿğ—²ğ—®ğ—¿ğ—» ğ—”ğ—¯ğ—¼ğ˜‚ğ˜ ğ˜ğ—µğ—² ğ——ğ—¶ğ˜ƒğ—²ğ—¿ğ˜€ğ—² ğ—ªğ—¼ğ—¿ğ—¹ğ—± ğ—¼ğ—³ ğ—”ğ—£ğ—œ ğ—£ğ—¿ğ—¼ğ˜ğ—¼ğ—°ğ—¼ğ—¹ğ˜€:

Let's dive into the world of API protocols, the hidden heroes behind the seamless flow of data and communication in our digital lives.

ğŸ­. ğ—šğ—¿ğ—®ğ—½ğ—µğ—¤ğ—Ÿ: Imagine a flexible way to request specific data from an API. That's GraphQL! It allows developers to tailor responses and optimize performance.

ğŸ®. ğ—ªğ—²ğ—¯ğ—µğ—¼ğ—¼ğ—¸ğ˜€: Think of instant updates and notifications between systems. Webhooks use HTTP callbacks to make this happen, keeping everything in sync.

ğŸ¯. ğ—¥ğ—˜ğ—¦ğ—§: This is the classic API design, built on simplicity and statelessness. It's the foundation for countless web applications and services.

ğŸ°. ğ—¦ğ—²ğ—¿ğ˜ƒğ—²ğ—¿-ğ—¦ğ—²ğ—»ğ˜ ğ—˜ğ˜ƒğ—²ğ—»ğ˜ğ˜€ (ğ—¦ğ—¦ğ—˜): Experience real-time data updates with SSE. This lightweight protocol is ideal for dynamic content and instant information.

ğŸ±. ğ—˜ğ—¹ğ—²ğ—°ğ˜ğ—¿ğ—¼ğ—»ğ—¶ğ—° ğ——ğ—®ğ˜ğ—® ğ—œğ—»ğ˜ğ—²ğ—¿ğ—°ğ—µğ—®ğ—»ğ—´ğ—² (ğ—˜ğ——ğ—œ): Standardizes the exchange of business documents, making transactions smoother and faster.

ğŸ². ğ—˜ğ˜ƒğ—²ğ—»ğ˜-ğ——ğ—¿ğ—¶ğ˜ƒğ—²ğ—» ğ—”ğ—¿ğ—°ğ—µğ—¶ğ˜ğ—²ğ—°ğ˜ğ˜‚ğ—¿ğ—² (ğ—˜ğ——ğ—”): Systems communicate through events in this model, making them loosely coupled and scalable.

ğŸ³. ğ—ªğ—²ğ—¯ğ˜€ğ—¼ğ—°ğ—¸ğ—²ğ˜ğ˜€: Imagine real-time chat applications or collaborative editing. Websockets enable this by allowing two-way communication between clients and servers.

ğŸ´. ğ—¦ğ—¶ğ—ºğ—½ğ—¹ğ—² ğ—¢ğ—¯ğ—·ğ—²ğ—°ğ˜ ğ—”ğ—°ğ—°ğ—²ğ˜€ğ˜€ ğ—£ğ—¿ğ—¼ğ˜ğ—¼ğ—°ğ—¼ğ—¹ (ğ—¦ğ—¢ğ—”ğ—£): This protocol defines a set of structured rules for communication, making it reliable and secure for specific scenarios.

ğŸµ. ğ—´ğ—¥ğ—£ğ—– (ğ—¥ğ—²ğ—ºğ—¼ğ˜ğ—² ğ—£ğ—¿ğ—¼ğ—°ğ—²ğ—±ğ˜‚ğ—¿ğ—² ğ—–ğ—®ğ—¹ğ—¹ğ˜€): High-performance and efficient, gRPC uses protocol buffers to facilitate faster communication between services.

ğŸ­ğŸ¬. ğ— ğ—²ğ˜€ğ˜€ğ—®ğ—´ğ—² ğ—¤ğ˜‚ğ—²ğ˜‚ğ—¶ğ—»ğ—´ ğ—§ğ—²ğ—¹ğ—²ğ—ºğ—²ğ˜ğ—¿ğ˜† ğ—§ğ—¿ğ—®ğ—»ğ˜€ğ—½ğ—¼ğ—¿ğ˜ (ğ— ğ—¤ğ—§ğ—§): This lightweight protocol excels in scenarios like IoT devices and low-latency communication.

ğŸ­ğŸ­. ğ—”ğ—±ğ˜ƒğ—®ğ—»ğ—°ğ—²ğ—± ğ— ğ—²ğ˜€ğ˜€ğ—®ğ—´ğ—² ğ—¤ğ˜‚ğ—²ğ˜‚ğ—¶ğ—»ğ—´ ğ—£ğ—¿ğ—¼ğ˜ğ—¼ğ—°ğ—¼ğ—¹ (ğ—”ğ— ğ—¤ğ—£): Versatile and feature-rich, AMQP is ideal for building scalable and robust messaging systems.

![1702293451390](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/a4b42c15-27a6-404d-aba4-7f7dc06e4304)

## The Evolving Landscape of API Protocols in 2023
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/08a3bbc9-e8d2-4e7e-bd26-87261ecd415a)


## Docker's growing adoption 

Docker's growing adoption makes it a crucial skill across various tech roles - from developers to QA engineers.

Here's a neat guide to fundamental Docker concepts and commands, vital for anyone in tech today.

ğŸ”¹ Setup & Image Management:
  - Build an image: ğšğš˜ğšŒğš”ğšğš› ğš‹ğšğš’ğš•ğš -ğš ğš–ğš¢ğšŠğš™ğš™ .
  - Fetch an image: ğšğš˜ğšŒğš”ğšğš› ğš™ğšğš•ğš• ğšğš‹ğšğš—ğšğš
  - Store image remotely: ğšğš˜ğšŒğš”ğšğš› ğš™ğšğšœğš‘ ğš–ğš¢ğšğšœğšğš›/ğš–ğš¢ğšŠğš™ğš™
  - List local images: ğšğš˜ğšŒğš”ğšğš› ğš’ğš–ğšŠğšğšğšœ
  - Remove an image: ğšğš˜ğšŒğš”ğšğš› ğš›ğš–ğš’ ğš’ğš–ğšŠğšğš_ğš—ğšŠğš–ğš
  - Image layers history: ğšğš˜ğšŒğš”ğšğš› ğš‘ğš’ğšœğšğš˜ğš›ğš¢ ğš’ğš–ğšŠğšğš_ğš—ğšŠğš–ğš
  - Tag an image: ğšğš˜ğšŒğš”ğšğš› ğšğšŠğš ğšœğš˜ğšğš›ğšŒğš_ğš’ğš–ğšŠğšğš ğšğšŠğš›ğšğšğš_ğš’ğš–ğšŠğšğš
  - Save image to file: ğšğš˜ğšŒğš”ğšğš› ğšœğšŠğšŸğš -ğš˜ ğš˜ğšğšğš™ğšğšğšğš’ğš•ğš.ğš’ğš–ğš ğš–ğš¢ğš’ğš–ğšŠğšğš
  - Load image from file: ğšğš˜ğšŒğš”ğšğš› ğš•ğš˜ğšŠğš -ğš’ ğš’ğš—ğš™ğšğšğšğš’ğš•ğš.ğš’ğš–ğš

ğŸ”¹ Running & Managing Containers:
  - Start a container: ğšğš˜ğšŒğš”ğšğš› ğš›ğšğš— ğš’ğš–ğšŠğšğš_ğš—ğšŠğš–ğš
  - Stop a container: ğšğš˜ğšŒğš”ğšğš› ğšœğšğš˜ğš™ ğšŒğš˜ğš—ğšğšŠğš’ğš—ğšğš›_ğš’ğš
  - Force stop a container: ğšğš˜ğšŒğš”ğšğš› ğš”ğš’ğš•ğš• ğšŒğš˜ğš—ğšğšŠğš’ğš—ğšğš›_ğš’ğš
  - Restart a container: ğšğš˜ğšŒğš”ğšğš› ğš›ğšğšœğšğšŠğš›ğš ğšŒğš˜ğš—ğšğšŠğš’ğš—ğšğš›_ğš’ğš
  - Rename a container: ğšğš˜ğšŒğš”ğšğš› ğš›ğšğš—ğšŠğš–ğš ğš˜ğš•ğš_ğš—ğšŠğš–ğš ğš—ğšğš _ğš—ğšŠğš–ğš
  - View container logs: ğšğš˜ğšŒğš”ğšğš› ğš•ğš˜ğšğšœ ğšŒğš˜ğš—ğšğšŠğš’ğš—ğšğš›_ğš’ğš
  - Interact with container: ğšğš˜ğšŒğš”ğšğš› ğšğš¡ğšğšŒ -ğš’ğš ğšŒğš˜ğš—ğšğšŠğš’ğš—ğšğš›_ğš’ğš ğš‹ğšŠğšœğš‘
  - Pause container: ğšğš˜ğšŒğš”ğšğš› ğš™ğšŠğšğšœğš ğšŒğš˜ğš—ğšğšŠğš’ğš—ğšğš›_ğš’ğš
  - Resume container: ğšğš˜ğšŒğš”ğšğš› ğšğš—ğš™ğšŠğšğšœğš ğšŒğš˜ğš—ğšğšŠğš’ğš—ğšğš›_ğš’ğš

ğŸ”¹ Network & Storage:
  - List networks: ğšğš˜ğšŒğš”ğšğš› ğš—ğšğšğš ğš˜ğš›ğš” ğš•ğšœ
  - Create a volume: ğšğš˜ğšŒğš”ğšğš› ğšŸğš˜ğš•ğšğš–ğš ğšŒğš›ğšğšŠğšğš ğš–ğš¢ğšŸğš˜ğš•ğšğš–ğš
  - List volumes: ğšğš˜ğšŒğš”ğšğš› ğšŸğš˜ğš•ğšğš–ğš ğš•ğšœ

ğŸ”¹ Clean-up & Maintenance:
  - Clean up resources: ğšğš˜ğšŒğš”ğšğš› ğšœğš¢ğšœğšğšğš– ğš™ğš›ğšğš—ğš
  - Delete a container: ğšğš˜ğšŒğš”ğšğš› ğš›ğš– ğšŒğš˜ğš—ğšğšŠğš’ğš—ğšğš›_ğš’ğš
  - Container details: ğšğš˜ğšŒğš”ğšğš› ğš’ğš—ğšœğš™ğšğšŒğš ğšŒğš˜ğš—ğšğšŠğš’ğš—ğšğš›_ğš’ğš
  - Real-time stats: ğšğš˜ğšŒğš”ğšğš› ğšœğšğšŠğšğšœ
  - List running containers: ğšğš˜ğšŒğš”ğšğš› ğš™ğšœ
  - List all containers: ğšğš˜ğšŒğš”ğšğš› ğš™ğšœ -ğšŠ

ğŸ”¹ Docker Compose (Multiple Containers):
  - Start multi-container app: ğšğš˜ğšŒğš”ğšğš›-ğšŒğš˜ğš–ğš™ğš˜ğšœğš ğšğš™
  - Stop services: ğšğš˜ğšŒğš”ğšğš›-ğšŒğš˜ğš–ğš™ğš˜ğšœğš ğšœğšğš˜ğš™
  - Remove resources: ğšğš˜ğšŒğš”ğšğš›-ğšŒğš˜ğš–ğš™ğš˜ğšœğš ğšğš˜ğš ğš—
  - View logs: ğšğš˜ğšŒğš”ğšğš›-ğšŒğš˜ğš–ğš™ğš˜ğšœğš ğš•ğš˜ğšğšœ
  - Restart services: ğšğš˜ğšŒğš”ğšğš›-ğšŒğš˜ğš–ğš™ğš˜ğšœğš ğš›ğšğšœğšğšŠğš›ğš

ğŸ”¹ Advanced Utilities & Miscellaneous:
  - Copy files from container: ğšğš˜ğšŒğš”ğšğš› ğšŒğš™ ğšŒğš˜ğš—ğšğšŠğš’ğš—ğšğš›_ğš’ğš:/ğš™ğšŠğšğš‘
  - Changes in FS: ğšğš˜ğšŒğš”ğšğš› ğšğš’ğšğš ğšŒğš˜ğš—ğšğšŠğš’ğš—ğšğš›_ğš’ğš
  - Running processes: ğšğš˜ğšŒğš”ğšğš› ğšğš˜ğš™ ğšŒğš˜ğš—ğšğšŠğš’ğš—ğšğš›_ğš’ğš
  - Search Docker Hub: ğšğš˜ğšŒğš”ğšğš› ğšœğšğšŠğš›ğšŒğš‘ ğšğšğš›ğš–
  - Public ports: ğšğš˜ğšŒğš”ğšğš› ğš™ğš˜ğš›ğš ğšŒğš˜ğš—ğšğšŠğš’ğš—ğšğš›_ğš’ğš
  - Docker Hub login: ğšğš˜ğšŒğš”ğšğš› ğš•ğš˜ğšğš’ğš—
  - Docker Hub logout: ğšğš˜ğšŒğš”ğšğš› ğš•ğš˜ğšğš˜ğšğš

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/878eaffb-79c2-4d14-b833-a25c10bc15b7)

## Docker Architecture and Components
1. Docker Daemon (`dockerd`):
- ğ—¥ğ—¼ğ—¹ğ—²: Manages Docker containers on a system.
- ğ—¥ğ—²ğ˜€ğ—½ğ—¼ğ—»ğ˜€ğ—¶ğ—¯ğ—¶ğ—¹ğ—¶ğ˜ğ—¶ğ—²ğ˜€: Building, running, and managing containers.
  
2. Docker Client (`docker`):
- ğ—¥ğ—¼ğ—¹ğ—²: Interface through which users interact with Docker.
- ğ—–ğ—¼ğ—ºğ—ºğ—®ğ—»ğ—±ğ˜€: build, pull, run, etc.
  
3. Docker Images:
- ğ——ğ—²ğ—³ğ—¶ğ—»ğ—¶ğ˜ğ—¶ğ—¼ğ—»: Read-only templates used to create containers.
- ğ—¥ğ—¼ğ—¹ğ—²: Serve as the basis for creating containers.
- ğ—¥ğ—²ğ—´ğ—¶ğ˜€ğ˜ğ—¿ğ˜†/ğ—›ğ˜‚ğ—¯: A storage and distribution system for Docker images.

4. Docker Containers:
- ğ——ğ—²ğ—³ğ—¶ğ—»ğ—¶ğ˜ğ—¶ğ—¼ğ—»: Runnable instances of Docker images.
- ğ—¥ğ—¼ğ—¹ğ—²: Encapsulate the application and its environment.

5. Docker Registry:
- ğ—¥ğ—¼ğ—¹ğ—²: Store Docker images.
- ğ—£ğ˜‚ğ—¯ğ—¹ğ—¶ğ—° ğ—¥ğ—²ğ—´ğ—¶ğ˜€ğ˜ğ—¿ğ˜†: Docker Hub.
- ğ—£ğ—¿ğ—¶ğ˜ƒğ—®ğ˜ğ—² ğ—¥ğ—²ğ—´ğ—¶ğ˜€ğ˜ğ—¿ğ˜†: Can be hosted by users.


Docker Workflow

A. Development Phase

1. ğ—ªğ—¿ğ—¶ğ˜ğ—² ğ—–ğ—¼ğ—±ğ—²:
   - Developers write code locally.
   
2. ğ—•ğ˜‚ğ—¶ğ—¹ğ—± ğ——ğ—¼ğ—°ğ—¸ğ—²ğ—¿ ğ—œğ—ºğ—®ğ—´ğ—²:
   - ğ——ğ—¼ğ—°ğ—¸ğ—²ğ—¿ğ—³ğ—¶ğ—¹ğ—²: A script with instructions to create a Docker image.
   - ğ—–ğ—¼ğ—ºğ—ºğ—®ğ—»ğ—±: ğšğš˜ğšŒğš”ğšğš› ğš‹ğšğš’ğš•ğš -ğš ğš–ğš¢-ğš’ğš–ğšŠğšğš .
   
3. ğ—§ğ—²ğ˜€ğ˜ ğ—Ÿğ—¼ğ—°ğ—®ğ—¹ğ—¹ğ˜†:
   - Run the application inside a Docker container locally.
   - ğ—–ğ—¼ğ—ºğ—ºğ—®ğ—»ğ—±: ğšğš˜ğšŒğš”ğšğš› ğš›ğšğš— ğš–ğš¢-ğš’ğš–ğšŠğšğš
   
B. Share/Deploy Phase

4. ğ—£ğ˜‚ğ˜€ğ—µ ğ—œğ—ºğ—®ğ—´ğ—² ğ˜ğ—¼ ğ—¥ğ—²ğ—´ğ—¶ğ˜€ğ˜ğ—¿ğ˜†:
   - Push the Docker image to a registry (Docker Hub, AWS ECR, etc.).
   - ğ—–ğ—¼ğ—ºğ—ºğ—®ğ—»ğ—±: ğšğš˜ğšŒğš”ğšğš› ğš™ğšğšœğš‘ ğš–ğš¢-ğš’ğš–ğšŠğšğš
   
5. ğ——ğ—²ğ—½ğ—¹ğ—¼ğ˜† ğ—¼ğ—» ğ—® ğ—¦ğ—²ğ—¿ğ˜ƒğ—²ğ—¿/ğ—–ğ—¹ğ˜‚ğ˜€ğ˜ğ—²ğ—¿:
   - Pull the Docker image from the registry.
   - ğ—–ğ—¼ğ—ºğ—ºğ—®ğ—»ğ—±: ğšğš˜ğšŒğš”ğšğš› ğš™ğšğš•ğš• ğš–ğš¢-ğš’ğš–ğšŠğšğš
   - Run the container on a server or a cluster (like Kubernetes).
   - ğ—–ğ—¼ğ—ºğ—ºğ—®ğ—»ğ—±: ğšğš˜ğšŒğš”ğšğš› ğš›ğšğš— ğš–ğš¢-ğš’ğš–ğšŠğšğš

C. CI/CD Integration

6. ğ—–ğ—¼ğ—»ğ˜ğ—¶ğ—»ğ˜‚ğ—¼ğ˜‚ğ˜€ ğ—œğ—»ğ˜ğ—²ğ—´ğ—¿ğ—®ğ˜ğ—¶ğ—¼ğ—» (ğ—–ğ—œ):
   - Integrate code changes and build the Docker image.
   - Push the built image to a registry.
   
7. ğ—–ğ—¼ğ—»ğ˜ğ—¶ğ—»ğ˜‚ğ—¼ğ˜‚ğ˜€ ğ——ğ—²ğ—½ğ—¹ğ—¼ğ˜†ğ—ºğ—²ğ—»ğ˜ (ğ—–ğ——):
   - Deploy the Docker image from the registry to production environments.
   
D. Scaling & Management

8. ğ—¦ğ—°ğ—®ğ—¹ğ—¶ğ—»ğ—´:
   - Increase or decrease the number of running containers based on demand.
   
9. ğ— ğ—¼ğ—»ğ—¶ğ˜ğ—¼ğ—¿ğ—¶ğ—»ğ—´ & ğ—Ÿğ—¼ğ—´ğ—´ğ—¶ğ—»ğ—´:
   - Track the performance and logs of running containers.

10. ğ—¨ğ—½ğ—±ğ—®ğ˜ğ—² & ğ—¥ğ—¼ğ—¹ğ—¹ğ—¯ğ—®ğ—°ğ—¸:
   - Deploy updates by pushing new Docker images to the registry and updating running containers.
   - Rollback to a previous version if needed by running containers from an older Docker image.

E. Networking & Storage

11. ğ—¡ğ—²ğ˜ğ˜„ğ—¼ğ—¿ğ—¸ğ—¶ğ—»ğ—´:
   - Manage communication between containers and the outside world.

12. ğ—¦ğ˜ğ—¼ğ—¿ğ—®ğ—´ğ—²:
   - Manage data and persist state using volumes.
![1699974906033](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/d1e6633d-cb12-49b0-90d0-a9b0e1b65887)

## Log Parsing Cheatsheet
In the IT industry, the fundamental skill of log parsing remains as vital as ever.

It's the backbone of troubleshooting, security analysis, and system monitoring.

To aid in this crucial task, I've compiled a comprehensive Log Parsing Cheatsheet that is perfect for IT professionals of all stripes.

Hereâ€™s a breakdown of each command and how you can use it:

ğŸ” ğ—›ğ—˜ğ—”ğ——: ğš‘ğšğšŠğš ğšğš’ğš•ğš.ğš•ğš˜ğš gives you the top ten lines of a file, which is often where critical recent error logs can be found. For instance, ğš‘ğšğšŠğš -ğš— ğŸ¸ğŸ¶ ğšğš’ğš•ğš.ğš•ğš˜ğš displays the first 20 lines.

ğŸ” ğ—§ğ—”ğ—œğ—Ÿ: ğšğšŠğš’ğš• ğšğš’ğš•ğš.ğš•ğš˜ğš does the opposite, showing you the last ten lines of a file â€” where the most recent events are logged. Try ğšğšŠğš’ğš• -ğš ğšğš’ğš•ğš.ğš•ğš˜ğš to get a real-time stream of log updates.

ğŸ”„ ğ—–ğ—¢ğ— ğ— : ğšŒğš˜ğš–ğš– ğšğš’ğš•ğšğŸ·.ğš•ğš˜ğš ğšğš’ğš•ğšğŸ¸.ğš•ğš˜ğš helps you compare two sorted files. It's perfect for finding discrepancies between log versions, like ğšŒğš˜ğš–ğš– -ğŸ¹ ğšœğšğš›ğšŸğšğš›ğŸ·.ğš•ğš˜ğš ğšœğšğš›ğšŸğšğš›ğŸ¸.ğš•ğš˜ğš to see lines unique to each.

ğŸ”£ ğ—Ÿğ—˜ğ—¦ğ—¦: ğš•ğšğšœğšœ ğšğš’ğš•ğš.ğš•ğš˜ğš allows for on-the-fly viewing of large log files. Navigate with ğ™¶, ğšğš, and /ğšœğšğšŠğš›ğšŒğš‘_ğšğšğš›ğš–.

ğŸ“Š ğ—–ğ—¦ğ—©ğ—ğ—œğ—§: ğšŒğšœğšŸğšŒğšğš -ğšŒ ğŸ¹ ğšğšŠğšğšŠ.ğšŒğšœğšŸ can extract columns from CSVs. For example, ğšŒğšœğšŸğšŒğšğš -ğš— ğšğšŠğšğšŠ.ğšŒğšœğšŸ lists column names.

ğŸ“‘ ğ—ğ—¤: ğš“ğšš .ğšğš˜ğš˜ ğšğšŠğšğšŠ.ğš“ğšœğš˜ğš— is for JSON parsing â€” invaluable for modern web app logs. Use ğš“ğšš '.[] | .ğš—ğšŠğš–ğš' ğšğšœğšğš›ğšœ.ğš“ğšœğš˜ğš— to extract user names from a list.

ğŸ” ğ—šğ—¥ğ—˜ğ—£: ğšğš›ğšğš™ 'ğšğš›ğš›ğš˜ğš›' ğšğš’ğš•ğš.ğš•ğš˜ğš finds all occurrences of 'error' in a file. Advanced usage like ğšğš›ğšğš™ -ğ™´ "ğŸº[ğŸ¶-ğŸ¿]{ğŸ¸}" ğšğš’ğš•ğš.ğš•ğš˜ğš finds all 400-level errors in HTTP logs.

ğŸ“¡ ğ—¡ğ—šğ—¥ğ—˜ğ—£: ğš—ğšğš›ğšğš™ -ğš ğšğšğš‘ğŸ¶ 'ğŸºğŸ¶ğŸº' ğš™ğš˜ğš›ğš ğŸ¾ğŸ¶ listens on the network for specific data, useful for real-time traffic analysis.

ğŸ”§ ğ—§ğ—¥: ğšğš› '[:ğš•ğš˜ğš ğšğš›:]' '[:ğšğš™ğš™ğšğš›:]' < ğšğš’ğš•ğš.ğšğš¡ğš transforms lowercase to uppercase. Remove duplicates with ğšğš› -ğšœ '\ğš—'.

ğŸ”ª ğ—–ğ—¨ğ—§: ğšŒğšğš -ğš ',' -ğš ğŸ¸ ğšğš’ğš•ğš.ğš•ğš˜ğš can parse fields from delimited logs, making it simple to see specific data columns.

ğŸ”¨ ğ—¦ğ—˜ğ——: ğšœğšğš 'ğšœ/ğš˜ğš•ğš/ğš—ğšğš /ğš' ğšğš’ğš•ğš.ğš•ğš˜ğš finds and replaces text â€” ğšœğšğš '/^$/ğš' ğšğš’ğš•ğš.ğš•ğš˜ğš removes empty lines.

ğŸ”¢ ğ—¦ğ—¢ğ—¥ğ—§: ğšœğš˜ğš›ğš ğšğš’ğš•ğš.ğšğš¡ğš sorts text files line by line. For numeric sort, use ğšœğš˜ğš›ğš -ğš— ğšğš’ğš•ğš.ğšğš¡ğš.

ğŸŒŸ ğ—¨ğ—¡ğ—œğ—¤: ğšğš—ğš’ğšš -ğšŒ ğšğš’ğš•ğš.ğšğš¡ğš counts and removes duplicates. Case-insensitive search can be done using ğšğš—ğš’ğšš -ğš’ ğšğš’ğš•ğš.ğšğš¡ğš.

ğŸ“ƒ ğ——ğ—œğ—™ğ—™: ğšğš’ğšğš ğšğš’ğš•ğšğŸ·.ğš•ğš˜ğš ğšğš’ğš•ğšğŸ¸.ğš•ğš˜ğš compares files line by line, crucial for version differences.

ğŸ–‹ï¸ ğ—”ğ—ªğ—: ğšŠğš ğš” '{ğš™ğš›ğš’ğš—ğš $ğŸ¸}' ğšğš’ğš•ğš.ğš•ğš˜ğš prints the second word in each line. Itâ€™s perfect for text processing scripts, like summarizing logs.

## HTTPS encryption

![1699473793533](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/3def4dca-d6be-4739-b46c-5d6366bb76d5)

## API Courses
As we approach the year's end, I'm sharing one last time the free courses that have already empowered numerous individuals.

I've invested a considerable amount of time crafting a series of  API courses designed to not only elevate your skill set but also ensure you're primed for success in interviews and beyond.

These courses are tailored to provide you with the key skills that will distinguish you in the competitive tech landscape.

If you're looking to demystify APIs and gain a clear understanding, these resources are for you.


 1. ğ—”ğ—£ğ—œ ğ—™ğ˜‚ğ—»ğ—±ğ—®ğ—ºğ—²ğ—»ğ˜ğ—®ğ—¹ğ˜€: https://lnkd.in/e8eMet_k
 2. ğ—”ğ—£ğ—œ ğ—¦ğ—¶ğ—ºğ—½ğ—¹ğ—¶ğ—³ğ—¶ğ—²ğ—±: https://lnkd.in/er9JiGxw
 3. ğ—”ğ—£ğ—œ ğ— ğ—²ğ˜ğ—µğ—¼ğ—±ğ˜€: https://lnkd.in/ey9v7-hU
 4. ğ—”ğ—£ğ—œ ğ—§ğ—²ğ—¿ğ—ºğ—¶ğ—»ğ—¼ğ—¹ğ—¼ğ—´ğ—¶ğ—²ğ˜€: https://lnkd.in/eRsPMzpd
 5. ğ—”ğ—£ğ—œ ğ—”ğ˜‚ğ˜ğ—µğ—²ğ—»ğ˜ğ—¶ğ—°ğ—®ğ˜ğ—¶ğ—¼ğ—»: https://lnkd.in/eNPfpAdE
 6. ğ—”ğ—£ğ—œ ğ—¦ğ˜ğ—®ğ˜ğ˜‚ğ˜€ ğ—–ğ—¼ğ—±ğ—²ğ˜€: https://lnkd.in/egXizUrS
 7. ğ—¥ğ—˜ğ—¦ğ—§ ğ—”ğ—£ğ—œ ğ˜ƒğ˜€ ğ—šğ—¿ğ—®ğ—½ğ—µğ—¤ğ—Ÿ: https://lnkd.in/eZHREdgC
 8. ğ—”ğ—£ğ—œ ğ—œğ—»ğ˜ğ—²ğ—´ğ—¿ğ—®ğ˜ğ—¶ğ—¼ğ—»: https://lnkd.in/eDASPP5m
 9. ğ—”ğ—£ğ—œ ğ—œğ—»ğ˜ğ—²ğ—´ğ—¿ğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—¶ğ—» ğ——ğ—²ğ˜ğ—®ğ—¶ğ—¹: https://lnkd.in/eZwFVrH7
10. ğ—”ğ—£ğ—œ ğ—§ğ—²ğ˜€ğ˜ğ—¶ğ—»ğ—´: https://lnkd.in/emgmWJqH
11. ğ—”ğ—£ğ—œ ğ˜„ğ—¶ğ˜ğ—µ ğ—£ğ˜†ğ˜ğ—µğ—¼ğ—»: https://lnkd.in/eM23ah2y
12. ğ—”ğ—£ğ—œ ğ—¦ğ—°ğ—®ğ—¹ğ—¶ğ—»ğ—´: https://lnkd.in/e3mZSvmn
13. ğ——ğ—²ğ˜ƒğ—²ğ—¹ğ—¼ğ—½ğ—¶ğ—»ğ—´ ğ—¥ğ—¼ğ—¯ğ˜‚ğ˜€ğ˜ ğ—”ğ—£ğ—œğ˜€: https://lnkd.in/eBXzbFyg
14. ğ—”ğ—£ğ—œğ˜€ ğ˜„ğ—¶ğ˜ğ—µ ğ—£ğ—¼ğ˜€ğ˜ğ—ºğ—®ğ—»: https://lnkd.in/ezue3d4B
15. ğ—§ğ—²ğ˜€ğ˜ğ—¶ğ—»ğ—´ ğ—”ğ—£ğ—œğ˜€ ğ˜„ğ—¶ğ˜ğ—µ ğ—£ğ—¼ğ˜€ğ˜ğ—ºğ—®ğ—»: https://lnkd.in/eCPnGTGi
16. ğ—”ğ—£ğ—œ ğ—¦ğ—²ğ—°ğ˜‚ğ—¿ğ—¶ğ˜ğ˜†: https://lnkd.in/e79ZYfPa
17. ğ—”ğ—£ğ—œğ˜€ ğ—³ğ—¼ğ—¿ ğ—˜ğ˜ƒğ—²ğ—¿ğ˜†ğ—¼ğ—»ğ—²: https://lnkd.in/e4WGDffA

## Elevate Your Software Development with REST APIs
Elevate Your Software Development with REST APIs


In the dynamic world of technology, Application Programming Interfaces (APIs) are the linchpin, enabling seamless communication between applications. REST APIs, known for their simplicity and scalability, stand out as key facilitators of innovation.

Understanding APIs and REST:
APIs empower developers to integrate systems, enhance functionalities, and foster innovation. REST APIs, with their flexibility and stateless nature, have gained widespread popularity in facilitating seamless data exchange.

Key Principles for REST API Design:

REST Methods: Utilize standard HTTP methods (GET, POST, PUT, DELETE) for specific purposes.
Cacheable: Optimize performance by allowing responses to be cached.
Stateless: Each client request contains all necessary information, ensuring no server-side storage of client state.
Simple & Fine-Grained: Design should offer fine-grained control over resources for efficient manipulation.
Pagination, Filtering, Ordering: Support for handling large datasets and flexible data retrieval.
Connectedness: Resources should be interconnected, promoting discoverability.
Security: Implement secure authentication and authorization mechanisms for data protection.


Best Practices for Implementation:

Versioning: Support versioning to manage changes without breaking existing client implementations.
Self-Descriptive Messages: Responses include metadata for better understanding and utilization.
HATEOAS: Promote API discoverability by allowing clients to navigate through resource representations.
Layered System & Uniform Interface: Enhance modularity and user experience through a consistent and layered design.
CORS & Idempotence: Enable controlled cross-origin resource sharing and ensure predictability in operations.
Authentication, Logging, Input Validations: Prioritize security, reliability, and data integrity.
TLS & Rate Limiting: Encrypt communication and implement rate limiting for performance and security.

Conclusion:
Designing a robust REST API is an art that shapes the interconnected landscape of the digital world. These principles serve as a comprehensive guide for architects and developers, unlocking the true potential of REST APIs. As technology advances, well-designed APIs will continue to drive innovation and evolution in modern applications.

![1700221799574](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/77328784-8afe-410f-bf58-f0100858bd77)

## Session, Cookie, JWT, Token, SSO, and OAuth 2.0 Explained in One Diagram

![1700239541390](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/0889ccd1-21be-445a-977d-d852d101c2a9)

## ğŸŒ Spring Security Architecture Overview ğŸ›¡ï¸
ğŸ° Key Components:

1. Authentication Manager ğŸ¤:
- Responsible for validating user credentials.
- Utilizes various authentication providers (e.g., LDAP, JDBC).

2. Security Context ğŸ§‘â€ğŸ’¼:
- Stores details of the currently authenticated user.
- Ensures security information is accessible throughout the application.

3. Authentication Provider ğŸ”’:
- Implements the actual authentication process.
- Supports multiple authentication mechanisms (e.g., username/password, OAuth).

4. UserDetailsService ğŸ‘©â€ğŸ’¼:
- Retrieves user-related information (like roles and permissions) from the data store.

5. Authorization ğŸš¦:
- Controls access to specific resources based on user roles and permissions.
- Uses access control expressions (ACL) for fine-grained authorization.

ğŸ”„ Authentication Flow:

1. Filter Chain ğŸ”„:
- Requests pass through a series of filters.
- Each filter handles a specific aspect of the authentication process.

2. Username and Password Authentication ğŸ”‘:
- Typical login involves the `UsernamePasswordAuthenticationFilter`.
- Validates user credentials against the `AuthenticationManager`.

3. Token-Based Authentication ğŸ«:
- Enables stateless authentication using tokens (e.g., JWT).
- Great for microservices architecture.

ğŸš€ Customization and Extensibility:

1. Configurer Interface âš™ï¸:
- Allows easy customization of security settings.
- Implement `WebSecurityConfigurerAdapter` for more advanced configurations.

2. Custom Authentication Providers ğŸ› ï¸:
- Implement your custom logic by extending `AuthenticationProvider`.

ğŸŒ Conclusion:

Spring Security provides a robust and flexible security framework for Java applications. Understanding its architecture empowers developers to build secure and scalable systems. ğŸ’ªâœ¨

![1699964498730](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/21ae7e59-03c8-4149-8fca-abcac7d9cb9f)

## Single Sign-On (SSO) explained in simple terms.
The concepts of SSO revolve around the three key players: the User, the Identity Provider (IDP), and the Application.

1. The end-user or individual who seeks access to various applications.

2. Identity Provider (IDP): An entity responsible for user authentication and verification. Common IDPs include Google, Facebook, and company-specific systems.

3. Application: The software or service that the user wants to access. Applications rely on the IDP for user authentication. With SSO, users can seamlessly log in to various applications with a single set of credentials, enhancing convenience and security.

Single Sign-On (SSO) simplifies user access by enabling them to log in to multiple applications with a single set of credentials, enhancing the user experience and reducing password fatigue. It also centralizes security and access management, improving security, streamlining access control, and saving time and costs.

Over to you: What's your perspective on the future of secure authentication in the digital realm?

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/2d03a4b8-053d-4c20-8606-41e342ff12d5)

## Imperative Vs Functional Vs Object-oriented Programming

In software development, different programming paradigms offer unique ways to structure code. Three main paradigms are Imperative, Functional, and Object-oriented programming, each with distinct approaches to problem-solving.

1. Imperative Programming:
- Works by changing program state through a sequence of commands.
- Uses control structures like loops and conditional statements for execution flow.
- Emphasizes on mutable data and explicit steps for task completion.
- Examples: C, Python, and most procedural languages.

2. Functional Programming:
- Relies on pure functions, emphasizing computation without side effects.
- Promotes immutability and the avoidance of mutable state.
- Supports higher-order functions, recursion, and declarative programming.
- Examples: Haskell, Lisp, Scala, and functional features in languages like JavaScript.

3. Object-oriented Programming:
- Focuses on modeling real-world entities as objects, containing data and methods.
- Encourages concepts such as inheritance, encapsulation, and polymorphism.
- Utilizes classes, objects, and interfaces to structure code.
- Examples: Java, C++, Python, and Ruby.

Over to you: Which one resonates with your coding style? Ever had an 'aha' moment while using a particular paradigm? Share your perspective.
![1699893935849](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/0615fd24-2448-49e5-bed7-be3f16fb6737)

## Docker Key Commands Map ğŸ‘‡
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/13b9329c-fa00-4d75-ad77-7dc1fb8239c3)

## How do we design effective and safe APIs?
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/38c38c67-2af1-4e8b-a4d9-3fb33ddeb582)

## Github Repos to Become Master in React
1 Under the Hood React JS

https://lnkd.in/d2PVfbFS

2 Roadmap to becoming a React developer : https://lnkd.in/d5tGtcvj

3 Curated List of React Components & Libraries : https://lnkd.in/dMUWujd5

4 Higher-Order Components for React

https://lnkd.in/dwecQ_ZC

5 Beautiful React Hooks: https://lnkd.in/dVJdQG3m

6 Cheatsheets for experienced React developers getting started with TypeScript

https://lnkd.in/dFfuPqiA

7 30 Seconds of React : https://lnkd.in/dy-MWrgW

8 React Redux Links : https://lnkd.in/dZWje8S4

9 Bullet Proof React : https://lnkd.in/dqKvEFaa

## ğŸ§ Understanding Linux File Permissions ğŸš€
ğŸ§ Understanding Linux File Permissions ğŸš€

In the Linux world, file permissions are like the gatekeepers of your data fortress! They control who can enter, read, write, or execute files and directories. Let's break it down:

1. Command Structure:
- ğŸ•¹ï¸ `chmod`: Stands for "change mode," the command to tweak permissions.
- ğŸ“š `r` (read), ğŸ“ `w` (write), and ğŸƒ `x` (execute) are the three permission types.

2. Permission Levels:
- ğŸ¤´ Owner: The file's creator.
- ğŸŒ Group: Users in the file's group.
- ğŸŒ Others: The rest of the world.

3. Numeric Notation:
- ğŸ“Š Each permission has a numeric value: ğŸ“– `r` (read) = 4, ğŸ“ `w` (write) = 2, ğŸƒ `x` (execute) = 1.
- ğŸ¤¯ Combine them to set permissions. For example, read and execute (rx) = 5, read and write (rw) = 6, all permissions (rwx) = 7.

4. Setting Permissions:
- ğŸ› ï¸ `chmod` is used like this: `chmod [permissions] [file/directory]`.
- ğŸš§ Example: `chmod 755 myfile` grants read, write, and execute to the owner, and read/execute to the group and others.

5. Symbolic Notation:
- ğŸ§© `u` (user/owner), ğŸ¤ `g` (group), and ğŸŒ `o` (others) are used in symbolic notation.
- ğŸŒˆ `+` adds, `-` removes, and `=` sets permissions.
- ğŸ“ Example: `chmod u+x myfile` adds execute permission for the owner.

![1699571091120](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/cca5e335-e7ed-4c14-a8cf-5fa29b05e545)

## Most used design patterns

Ever wondered how top-notch software architects build robust and scalable systems? Look no further! Here are the 10 most used design patterns that can elevate your coding game:

1 Singleton Pattern: Ensure a class has only one instance and provide a global point of access. Perfect for managing a unique resource, like a configuration manager.

2 Factory Pattern: Create objects without specifying their exact class. Ideal for creating families of related or dependent objects.

3 Adapter Pattern: Bridge the gap between two incompatible interfaces. Think of it as a language translator for objects!

4 Facade Pattern: Provide a simplified interface to a set of interfaces, making complex systems more manageable. Like a one-stop-shop for subsystems.

5 Decorator Pattern: Attach additional responsibilities to an object dynamically. Great for adding features to objects without altering their structure.

6 Proxy Pattern: Control access to an object by acting as a placeholder. Handy for scenarios like lazy loading or access control.

7 Command Pattern: Encapsulate a request as an object, allowing parameterization of clients with different requests and queuing of requests. Perfect for command queues and undo functionalities.

8 Template Pattern: Define the skeleton of an algorithm in the superclass but let subclasses override specific steps. Useful for implementing algorithms with shared steps.

9 Strategy Pattern: Define a family of algorithms, encapsulate each one, and make them interchangeable. Useful when you want to switch algorithms at runtime.

10 Observer Pattern: Define a one-to-many dependency between objects, ensuring that when one object changes state, all its dependents are notified and updated. Think of it as subscribing to updates.

Each pattern comes with its own superpower in solving specific problems. Mastering these design patterns can level up your software architecture game!

What's your favorite design pattern, and how have you applied it in your projects? Share your thoughts below!
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/0873fd61-2ba9-4453-96ad-f7a27f9a918f)

## Understanding OAuth
OAuth is an open standard that allows users to grant limited access to their data on one site to other sites or applications without exposing their passwords. It has become the backbone of secure authorization across the web and mobile apps.

The OAuth ecosystem

OAuth connects three main players:

- The User who wants to grant access to their data without sharing login credentials
- The Server that hosts the user's data and provides access tokens
- The Identity Provider (IdP) that authenticates the user's identity and issues tokens

How OAuth works

When a user tries to access their data through a third-party app, they are redirected to log in through the IdP. The IdP sends an access token to the app, which presents it to the server. Recognizing the valid token, the server grants access.

The OAuth flows

OAuth 2.0 defines four flows for obtaining authorization tokens:

- Authorization Code Flow - for server-side applications
- Client Credentials Flow - when the app is the resource owner
- Implicit Code Flow - not secure and no longer recommended
- Resource Owner Flow - for trusted apps using owner credentials

Key benefits

- Enhances user experience by eliminating multiple passwords
- Allows secure data access across platforms using tokens
- Balances accessibility and security

OAuth 2.0 has become the standard for authorization. It enables secure, convenient data sharing while protecting user accounts.
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/dd38cec9-57f3-41cd-9f37-0d7da694b033)

## AWS Security Reference Architecture!
In the ever-changing world of cloud computing, security is a top priority for businesses of all sizes. The AWS Security Reference Architecture (AWS SRA) provides a comprehensive framework for designing, building, and managing secure cloud environments. This detailed architecture gives a complete picture of security controls and services across multiple organizational units (OUs) and accounts, making sure that security is built into the entire cloud infrastructure.

Key Highlights of the AWS SRA

ğŸ’¥Comprehensive Coverage: The AWS SRA encompasses a wide range of security services, including identity and access management, network security, data protection, and threat detection.

ğŸ’¥Modular Design: The architecture is divided into distinct OUs and accounts, each with specific security objectives and associated services.

ğŸ’¥Customization Options: The AWS SRA provides flexibility to tailor security implementations to unique organizational requirements and risk profiles.

Benefits of Adopting the AWS SRA:

âœ…Enhanced Security Posture: The AWS SRA helps organizations achieve a robust security posture by providing a comprehensive and well-structured approach to cloud security.

âœ…Simplified Security Management: The modular design and clear guidelines simplify the management of security controls across multiple cloud accounts.

âœ…Reduced Security Risks: By implementing the AWS SRA, organizations can effectively mitigate security risks and protect their sensitive data and applications.

âœ…Embracing Security in the Cloud:
The AWS SRA serves as a valuable resource for organizations seeking to establish and maintain a secure cloud environment.

![1699413574428](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/a73bc66d-3db8-412e-8ff5-5c5b64ff0836)

## Software Production Release Step by Step Guide
1. Planning:
- Identify the goals and features for the upcoming release.
- Prioritize tasks based on importance and dependencies.
- Define timelines and allocate resources accordingly.

2. Development:
- Programmers start coding based on the planned features.
- Regular code reviews and collaboration to maintain code quality.
- Version control systems track changes for better collaboration.

3. Building Artifact:
- Compile the source code into executable or deployable artifacts.
- Generate documentation and other necessary files.
- Automation tools can be used to streamline this process.

4. Testing:
- Conduct various levels of testing (unit, integration, system, etc.).
- Identify and fix bugs or issues.
- Ensure compatibility with different platforms and configurations.

5. Environments
- Set up different environments for development, testing, and production.
- Ensure consistency across environments to minimize deployment issues.
- Monitor and troubleshoot any discrepancies between environments.

6. Release:
- Once testing is successful, prepare for the release.
- Generate release notes documenting changes and updates.
- Coordinate with other teams for a smooth rollout.
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/fc09c94a-53fc-4e9f-986f-fcaebc44dabb)

## 8 Essential Internet Protocols You Must Know
8 Essential Internet Protocols You Must Know

â–· HTTP (Hypertext Transfer Protocol) is a standard for transmitting web content over the internet.

â–· HTTPS (Hypertext Transfer Protocol Secure) is a secure version of HTTP that encrypts data for safe web communication.

â–· TCP (Transmission Control Protocol) is a reliable, connection-oriented protocol for transmitting data over networks, ensuring data delivery.

â–· IP (Internet Protocol) is a set of rules governing the routing and addressing of data packets across the internet.

â–· FTP (File Transfer Protocol) is used to transfer files between computers on a network or over the internet.

â–· SSH (Secure Shell) is a secure protocol for remote access to network devices and servers.

â–· SMTP (Simple Mail Transfer Protocol) is used for sending email messages between email servers.

â–· UDP (User Datagram Protocol) is a connectionless and faster protocol for transmitting data over networks, but it doesn't guarantee delivery.

![1699312494770](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/c1c1de75-91ce-4bde-ba25-7025dfa91086)

## Improving API performance
Improving API performance is crucial for delivering a seamless and efficient user experience. Here are the top 6 approaches to achieve a 10x improvement in API performance:

Caching: Implementing caching mechanisms can significantly boost API performance. Cache frequently accessed data or responses, reducing the load on your servers. Use in-memory caches like Redis or Memcached for high-speed data retrieval.

Connection Pooling: Maintaining a connection pool helps manage and reuse database connections efficiently. This minimizes the overhead of establishing new connections for every API request, enhancing performance.

Pagination: When dealing with large datasets, implement pagination to limit the amount of data returned in a single response. This reduces the payload size and response time, making the API more responsive.

Payload Compression: Compressing API responses, such as using GZIP or Brotli, reduces the amount of data transferred over the network. Smaller payloads result in faster response times and lower bandwidth usage.

Load Balancer: Distribute incoming API requests across multiple servers or instances using a load balancer. This ensures even distribution of traffic, prevents overloading of any single server, and provides redundancy for improved reliability.

Avoid N+1 Problem: When fetching related data, avoid the N+1 query problem. Use techniques like eager loading or GraphQL to fetch all required data in a single request, reducing the number of database queries and improving response times.
If you're new to these terms or looking to dive deeper, give this a â¤ï¸ and share!
Together, we can make tech jargon easier to grasp for everyone. ğŸŒ

ğŸ’â€â™‚ï¸Are you ready to take that pivotal step towards landing your dream job? Look no further than NextLevel (https://lnkd.in/dZCPrEez) â€“ your ultimate gateway to career success!

![1699104673502](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/331f3f5e-7425-4eff-b284-72abcfae2ef4)

## Don't only apply for the job but also ensure to establish a network with the recruiter for the future.
Interview Mail Tips-

You can achieve this by sending thoughtful emails.

âœ… ğ—”ğ—½ğ—½ğ—¹ğ˜†ğ—¶ğ—»ğ—´ ğ—³ğ—¼ğ—¿ ğ—·ğ—¼ğ—¯ ğ—˜ğ—ºğ—®ğ—¶ğ—¹:

ğ—¦ğ˜‚ğ—¯ğ—·ğ—²ğ—°ğ˜: Application for [Job Title] - [Your Name]

Dear [Hiring Manager's Name],

I hope this message finds you well. I am writing to express my interest in the [Job Title] position at [Company Name] that I recently came across. I believe my skills and experience align well with the requirements of the role.

With a background in [Relevant Skills/Experience], I am excited about the opportunity to contribute to [Company Name]'s [specific project/department/goal], and I am confident in my ability to make a positive impact. I have attached my resume for your consideration.

I would appreciate the chance to discuss how my background and expertise could benefit your team. Please let me know if there is a convenient time for a call or a meeting.

Thank you for considering my application. I look forward to the opportunity to speak with you.

Best regards,
[Your Name]

âœ… ğ—™ğ—¼ğ—¹ğ—¹ğ—¼ğ˜„-ğ—¨ğ—½ ğ—˜ğ—ºğ—®ğ—¶ğ—¹:

ğ—¦ğ˜‚ğ—¯ğ—·ğ—²ğ—°ğ˜: Follow-Up on My Interview

Hi [Hiring Manager's Name],

I hope you're doing well. I wanted to follow up on the interview we had for the [Job Title] position at [Company Name]. I'm really excited about the opportunity and would love to hear about the next steps in the process.

Looking forward to your response.

Best regards,
[Your Name]

âœ… ğ—¥ğ—²ğ—·ğ—²ğ—°ğ˜ğ—¶ğ—¼ğ—» ğ—˜ğ—ºğ—®ğ—¶ğ—¹:

ğ—¦ğ˜‚ğ—¯ğ—·ğ—²ğ—°ğ˜: Appreciation and Future Consideration

Hi [Hiring Manager's Name],

I hope this message finds you well. I wanted to express my gratitude for considering me for the [Job Title] position. Although I didn't make it to the next round, I'm thankful for the chance to learn about [Company Name]. I look forward to potentially crossing paths again in the future.

Thank you once again.

Best regards,
[Your Name]

âœ… ğ—”ğ—°ğ—°ğ—²ğ—½ğ˜ğ—®ğ—»ğ—°ğ—² ğ—˜ğ—ºğ—®ğ—¶ğ—¹:

ğ—¦ğ˜‚ğ—¯ğ—·ğ—²ğ—°ğ˜: Accepting the [Job Title] Position

Hello [Hiring Manager's Name],

I hope you're doing well. I wanted to formally accept the offer for the [Job Title] position at [Company Name]. I'm really excited about joining the team and contributing to [Company Name]'s success. Please let me know the next steps and any additional information you need from my end.

Thank you and looking forward to starting on [Start Date].

Best regards,
[Your Name]

âœ… ğ—¦ğ—®ğ—¹ğ—®ğ—¿ğ˜† ğ—¡ğ—²ğ—´ğ—¼ğ˜ğ—¶ğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—˜ğ—ºğ—®ğ—¶ğ—¹:

ğ—¦ğ˜‚ğ—¯ğ—·ğ—²ğ—°ğ˜: Salary Discussion for [Job Title] Position

Hello [Hiring Manager's Name],

I hope this message finds you well. I'm excited about the offer for the [Job Title] role at [Company Name]. I would like to discuss the compensation package to ensure that it aligns with my skills and experience. Could we set up a time to talk about this further?

Thank you and looking forward to your response.

##  HTTP â€œverbsâ€
GET, POST, PUT... Common HTTP â€œverbsâ€ in one figure. The method to download the high-resolution PDF is available at the end.

1. HTTP GET
This retrieves a resource from the server. It is idempotent. Multiple identical requests return the same result.

2. HTTP PUT
This updates or Creates a resource. It is idempotent. Multiple identical requests will update the same resource.

3. HTTP POST
This is used to create new resources. It is not idempotent, making two identical POST will duplicate the resource creation.

4. HTTP DELETE
This is used to delete a resource. It is idempotent. Multiple identical requests will delete the same resource.

5. HTTP PATCH
The PATCH method applies partial modifications to a resource.

6. HTTP HEAD
The HEAD method asks for a response identical to a GET request but without the response body.

7. HTTP CONNECT
The CONNECT method establishes a tunnel to the server identified by the target resource.

8. HTTP OPTIONS
This describes the communication options for the target resource.

9. HTTP TRACE
This performs a message loop-back test along the path to the target resource.

Over to you: What other HTTP verbs have you used?

![1699289122056](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/83a2ffeb-9b40-4e2d-8833-e10325f2f3a5)

## Key Difference between SQL and NoSQL Databases!
Making the right database choice is a crucial decision for your projects. Let's break down SQL and NoSQL in a quick cheat sheet to help you make an informed decision!

SQL (Structured Query Language):

ğŸ”¸ Structure: Tables with predefined schemas.
ğŸ”¸ Data Consistency: Strong consistency and ACID transactions.
ğŸ”¸ Scalability: Vertical scaling (add more resources to a server).
ğŸ”¸ Use Cases: Well-suited for structured data and complex queries.
ğŸ”¸ Query Language: SQL for complex queries.

NoSQL (Not Only SQL):

ğŸ”¹ Structure: Flexible, schema-less data models (e.g., JSON, XML).
ğŸ”¹ Data Consistency: Eventual consistency, often BASE (Basically Available, Soft state, Eventually consistent).
ğŸ”¹ Scalability: Horizontal scaling (add more servers to a cluster).
ğŸ”¹ Use Cases: Ideal for unstructured or semi-structured data, high-velocity data, and distributed systems.
ğŸ”¹ Examples: MongoDB, Cassandra, Redis.


When to Choose:

SQL: Choose for well-defined data structures, complex queries, and strong data consistency needs.
NoSQL: Opt for flexibility, high scalability, and rapid development with evolving data requirements.

Remember, there's no one-size-fits-all solution. Your choice depends on your project's unique needs!
![1698975062735](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/94f56ded-23a4-4603-a9e9-cd1d1d6395d1)

## How does HTTPS work?
Hypertext Transfer Protocol Secure (HTTPS) is an extension of HTTP that utilizes Transport Layer Security (TLS) to encrypt communication between a client and server. Any intercepted data will be unreadable and secure from tampering and eavesdropping.

What's the process for encrypting and decrypting data?

Step 1 - The journey begins with the client (like your browser) establishing a TCP connection with the server.

Step 2 - Next comes the â€œclient helloâ€ where the browser sends a message containing supported cipher suites and the highest TLS version it can handle. Cipher suites are sets of algorithms that typically include: a key exchange method to share keys between devices, a bulk encryption algorithm to encrypt data, and a message authentication code algorithm to check data integrity.

The server responds with a â€œserver helloâ€, confirming the chosen cipher suite and TLS version that they can both understand. The server then sends a TLS certificate to the client containing its domain name, certificate authority signature, and the serverâ€™s public key. The client checks this certificate to validate it is trusted and belongs to the server.

Step 3 - Once the TLS certificate is validated, the client creates a session key to be used for encrypting the bulk data transfer. Bulk data transfer refers to the transmission of the actual application data between client and server once the secure TLS connection is established. To securely send this session key to the server, itâ€™s encrypted with the serverâ€™s public key. The server, with its private key, is the only one who can decrypt this encrypted session key.

Step 4 - Now that both parties have the secret session key, they shift gears to symmetric encryption. Itâ€™s like theyâ€™ve agreed on a private language that only they understand. This makes the data transfer very secure. Symmetric encryption is much faster for large amounts of data.

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/e6fd8128-ce04-4124-96ff-c76a0f157c0c)

## Which latency numbers you should know?
Please note those are not precise numbers. They are based on some online benchmarks (Jeff Deanâ€™s latency numbers + some other sources).

ğŸ”¹L1 and L2 caches: 1 ns, 10 ns
E.g.: They are usually built onto the microprocessor chip. Unless you work with hardware directly, you probably donâ€™t need to worry about them.

ğŸ”¹RAM access: 100 ns
E.g.: It takes around 100 ns to read data from memory. Redis is an in-memory data store, so it takes about 100 ns to read data from Redis.

ğŸ”¹Send 1K bytes over 1 Gbps network: 10 us
E.g.: It takes around 10 us to send 1KB of data from Memcached through the network.

ğŸ”¹Read from SSD: 100 us
E.g.: RocksDB is a disk-based K/V store, so the read latency is around 100 us on SSD.

ğŸ”¹Database insert operation: 1 ms.
E.g.: Postgresql commit might take 1ms. The database needs to store the data, create the index, and flush logs. All these actions take time.

ğŸ”¹Send packet CA->Netherlands->CA: 100 ms
E.g.: If we have a long-distance Zoom call, the latency might be around 100 ms.

ğŸ”¹Retry/refresh internal: 1-10s
E.g: In a monitoring system, the refresh interval is usually set to 5~10 seconds (default value on Grafana).

Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/fb492ed1-9f8f-4d3a-90dd-1ba88062c058)

## deployment strategies
Over my years in IT, I've come across various deployment strategies, each with its unique approach and benefits.

Today, I wanted to share a quick rundown of the "Top 7 Deployment Strategies" I've encountered:

1. ğ—–ğ—®ğ—»ğ—®ğ—¿ğ˜† ğ—¥ğ—²ğ—¹ğ—²ğ—®ğ˜€ğ—²ğ˜€:
This strategy is all about caution. ğŸ¥ Instead of deploying a new version to everyone, we release it to a small subset of users. It's like sending out a 'canary in a coal mine' to test if the environment is safe. If issues arise, they affect a limited audience, making it easier to manage and rectify.

2. ğ—•ğ—¹ğ˜‚ğ—²/ğ—šğ—¿ğ—²ğ—²ğ—» ğ——ğ—²ğ—½ğ—¹ğ—¼ğ˜†ğ—ºğ—²ğ—»ğ˜ğ˜€:
Think of it as having a stunt double for your application. ğŸ­ You maintain two identical production environments - Blue (live) and Green (idle). When you have a new release, you deploy to the idle environment. Once tested and ready, you switch traffic to the new environment, ensuring zero downtime.

3. ğ—™ğ—²ğ—®ğ˜ğ˜‚ğ—¿ğ—² ğ—§ğ—¼ğ—´ğ—´ğ—¹ğ—²ğ˜€:
A magician's trick for developers. ğŸª„ With toggles, you can dynamically turn features on or off. This means we can deploy a feature but keep it hidden until it's ready for prime time.

4. ğ—”/ğ—• ğ—§ğ—²ğ˜€ğ˜ğ—¶ğ—»ğ—´:
It's like a taste test for features. ğŸğŸ By releasing two different versions to different user groups, we can gather data on which one performs better and is more preferred by users.

5. ğ——ğ—®ğ—¿ğ—¸ ğ—Ÿğ—®ğ˜‚ğ—»ğ—°ğ—µğ—²ğ˜€:
The covert ops of the deployment world. ğŸŒ˜ We release new features in the background without users knowing. This helps in stress-testing and ensuring everything works seamlessly when it eventually goes live to the audience.

6. ğ—¥ğ—¼ğ—¹ğ—¹ğ—¶ğ—»ğ—´ ğ——ğ—²ğ—½ğ—¹ğ—¼ğ˜†ğ—ºğ—²ğ—»ğ˜:
Think of it as a relay race. ğŸƒâ€â™‚ï¸ğŸƒâ€â™€ï¸ Instead of deploying a new version to all servers or instances at once, we do it one by one. This ensures there's always a version available to users, reducing downtime.

7.ğ—£ğ—µğ—®ğ˜€ğ—²ğ—± ğ—¥ğ—¼ğ—¹ğ—¹ğ—¼ğ˜‚ğ˜ğ˜€: Similar to Canary deployments but with more structured phases.Instead of moving from a small subset of users to everyone, there might be several intermediate stages, like deploying to 10%, then 25%, then 50%, and so on

Understanding these strategies is vital for any software professional.

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/bd15a147-23cb-4ff9-aba5-e30576ec83e6)

## YAML and why?
Hello, tech enthusiasts! It's the weekend, and I hope no bugs are interrupting your well-deserved rest. Today, we will discuss YAML and the reasons why you should learn it as a programmer.

YAML (YAML Ain't Markup Language) is a human-readable data serialization format. It's often used for configuration files, data exchange between languages with different data structures, and as a data format in applications where human-readable text is preferred. YAML is important to learn for several reasons:

ğŸ“’ Human-Readable: YAML is designed to be easily read and written by humans. Its simple and intuitive structure makes it a preferred choice for configuration files, where human readability is essential.

ğŸ“’ Simple Syntax: YAML uses indentation and colons to define key-value pairs and data structures, making it straightforward to understand and write, even for those new to the format.

ğŸ“’ Language-Agnostic: YAML is not tied to a specific programming language, making it a versatile choice for data exchange between different systems. It is supported by numerous programming languages through libraries and parsers.

ğŸ“’ Versatile Data Structures: YAML supports a wide range of data structures, including scalars (strings, numbers, booleans, null), lists (arrays), dictionaries (objects), and nested combinations of these. This flexibility makes it suitable for various use cases.

ğŸ“’ Configuration Files: YAML is commonly used for configuration files in software applications. It allows developers to specify settings, options, and parameters in a human-readable format.

ğŸ“’ Data Serialization: YAML can be used to serialize and deserialize complex data structures, making it suitable for data storage and exchange between applications or systems.

ğŸ“’ Data Transformation: It is also used for data transformation in ETL (Extract, Transform, Load) processes, allowing data to be represented in a structured, human-readable format before further processing.

ğŸ“’ Markup Language Replacement: While not a full markup language, YAML is sometimes used as a more human-friendly alternative to markup languages like XML or JSON for simple data representation.

ğŸ“’ Continuous Integration and Deployment (CI/CD): Many CI/CD pipelines use YAML for defining build and deployment configurations. This allows automation and repeatability in the deployment process.

If you found this post insightful, please engage with it and consider sharing â™». Your participation is greatly valued.
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/511baa60-5af9-4f9f-8653-9e36f5a8d5e2)

## How To Release A Mobile App
The mobile app release process differs from conventional methods. This illustration simplifies the journey to help you understand.

Typical Stages in a Mobile App Release Process:

1. Registration & Development (iOS & Android): 
- Enroll in Apple's Developer Program and Google Play Console as iOS and Android developer
- Code using platform-specific tools: Swift/Obj-C for iOS, and Java/Kotlin for Android

2. Build & Test (iOS & Android): 
Compile the app's binary, run extensive tests on both platforms to ensure functionality and performance. Create a release candidate build.

3. QA:
- Internally test the app for issue identification (dogfooding)
- Beta test with external users to collect feedback
- Conduct regression testing to maintain feature stability

4. Internal Approvals:
- Obtain approval from stakeholders and key team members.
- Comply with app store guidelines and industry regulations
- Obtain security approvals to safeguard user data and privacy

5. App Store Optimization (ASO):
- Optimize metadata, including titles, descriptions, and keywords, for better search visibility
- Design captivating screenshots and icons to entice users
- Prepare engaging release notes to inform users about new features and updates

6. App Submission To Store:
- Submit the iOS app via App Store Connect following Apple's guidelines
- Submit the Android app via Google Play Console, adhering to Google's policies
- Both platforms may request issues resolution for approval

7. Release:
- Upon approval, set a release date to coordinate the launch on both iOS and Android platforms

Over to you:
What's the most challenging phase you've encountered in the mobile app release process?

![1698765350870](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/e4f34666-4757-4653-ae2a-d695bf05995e)

## Top 12 Tips for API Security
- Use HTTPS
- Use OAuth2
- Use WebAuthn
- Use Leveled API Keys
- Authorization
- Rate Limiting
- API Versioning
- Whitelisting
- Check OWASP API Security Risks
- Use API Gateway
- Error Handling
- Input Validation
![1698680730762](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/acc61b1a-cb98-4f74-a57d-11960007e923)


## Synchronous vs Asynchronous Explained.
ğŸ”„ Synchronous (Sync) Processing ğŸ”„

Imagine a restaurant where the chef makes one burger at a time. ğŸ”ğŸ•

1. You order a burger.
2. The chef starts making your burger and won't do anything else until it's done.
3. Only after your burger is ready, you can order another one.

This is how synchronous processing works in programming. It's like a step-by-step, one-at-a-time approach. It can make you wait, just like waiting for your burger to finish before ordering more.

â© Asynchronous (Async) Processing â©

Now, let's switch to a fast-food kitchen. ğŸ”ğŸŸâ­

1. You order a burger and fries.
2. The chef starts making the burger but doesn't wait for it to finish.
3. While the burger's cooking, they also start frying your fries.
4. When each item is ready, they serve it to you, no need to wait.

This is asynchronous processing in programming. It's like multitasking, where different tasks happen simultaneously, making things faster. You don't have to wait for one task to finish before starting another.

So, synchronous is like a slow, one-at-a-time approach, while asynchronous is a faster, multitasking approach in programming. ğŸš€ğŸ‘¨â€ğŸ’»

![1698625303361 (1)](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/e7821355-1acc-405f-bf7f-422fddfc88f8)

## Navigating the Database Landscape â—ï¸â—ï¸
Choosing the right database for your project is a critical decision. Hereâ€™s a step-by-step guide to help you make an informed choice:

1. ğŸ“ Understand Your Project Requirements: Identify the specific needs of your project, including data volume, complexity, performance, scalability, and security requirements.
2.ğŸ—‚ï¸ Data Model: Decide on the data model your project requires: structured (ğŸ¢), semi-structured (ğŸ“„), or unstructured (ğŸ“¦) data. This choice may lead you toward SQL or NoSQL databases.
3.ğŸ”„ SQL or NoSQL: If your data is structured and you require complex queries and transactions, consider SQL databases like PostgreSQL, MySQL, or Microsoft SQL Server (âš™ï¸ğŸ’¼). For more flexibility and scalability, opt for NoSQL databases like MongoDB, Cassandra, or Redis (ğŸ”ƒğŸ“ˆ).
4.ğŸ“ˆ Scalability: Determine whether you need horizontal (ğŸ”€) or vertical (â¬†ï¸) scalability. NoSQL databases often offer better horizontal scalability for large datasets.
5.âš–ï¸ CAP theorem: Understand the trade-offs between consistency (ğŸ§©), availability (ğŸƒ), and partition tolerance (ğŸ§±). Different databases prioritize these aspects differently.
6.ğŸ’¼ Open Source vs. Commercial: Decide between open-source databases (ğŸ§) and commercial databases (ğŸ’²). Licensing costs and support may influence this decision.
7.ğŸ‘¥ Community and Ecosystem: Evaluate the community support (ğŸ¤) and available resources. An active community can be a valuable resource for problem-solving.
8.â˜ï¸ Cloud or On-Premises: Consider whether you want to manage the database infrastructure yourself (ğŸ¢) or prefer a managed database service in the cloud (ğŸŒ¥ï¸).
9.ğŸ’° Budget: Assess the total cost of ownership, including licensing, hardware, and maintenance costs.
10.ğŸ” Security: Prioritize data security (ğŸ”’). Ensure the database provides encryption, access control, and compliance with relevant regulations.
11.ğŸ›¡ï¸ Backup and Recovery: Check the databaseâ€™s backup and recovery capabilities to prevent data loss.
12.ğŸ Performance and Optimization: Think about performance tuning, indexing, and query optimization (ğŸ”ğŸ“Š) to meet your projectâ€™s performance requirements.
13.ğŸ§ª Testing and Prototyping: Consider testing the database with a small-scale prototype (ğŸ”ğŸ”¬) before committing to it for a large project.
14.ğŸš€ Future Growth: Think about your projectâ€™s long-term needs (ğŸ”®). Will the chosen database support future requirements and growth?
15.ğŸ—£ï¸ Feedback and Recommendations: Seek input from colleagues, mentors, or online communities (ğŸŒğŸ’¬) to gather insights and recommendations.

By following these steps and considering your projectâ€™s specific needs, youâ€™ll be better equipped to choose the most suitable database for your application.

![1698645565323](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/862286cc-249c-4fc5-ad4d-326ed9547e76)

## HTTP (Hypertext Transfer Protocol) 
- is a fundamental protocol used for communication on the World Wide Web. It is the foundation for data communication on the internet and is responsible for the exchange of data between a client (usually a web browser) and a server.
Here is a list of some key features and characteristics of HTTP:

1. Stateless Protocol ğŸ“œ
2. Request-Response Model ğŸ”„
3. Text-Based Protocol ğŸ“„
4. Connectionless ğŸšª
5. Uniform Resource Identifier (URI) ğŸ”—
6. Methods (HTTP Verbs) ğŸš€
7. Headers ğŸ“‘
8. Status Codes ğŸš¦
9. Content Negotiation ğŸ¤
10. Caching ğŸï¸
11. Redirection â†©ï¸
12. Security ğŸ”’
13. Cookies and Sessions ğŸª
14. Authentication ğŸ”
15. Content Types ğŸ“°
16. Proxy Support ğŸŒ
17. Cross-Origin Resource Sharing (CORS) ğŸŒ
18. Compression ğŸ“¦
19. WebSockets ğŸ§©
20. HTTP/2 and HTTP/3 ğŸš€
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/af144350-1567-49f2-8b00-0065208fc405)

## Linux File Permissions Explained to a 5 year old ğŸ˜
Imagine your toy box ğŸ§¸ğŸ“¦ in your room â€“ it's like a little computer!

ğŸ”’ğŸ‘€ Now, think of each toy as a file ğŸ“„ or a picture ğŸ–¼ï¸ on your computer. These toys/files have three special locks:

1. Owner lock ğŸ‘‘ğŸ”: Only the person who owns the toy/file can play with it or change it. ğŸ™‹â€â™‚ï¸ğŸ”“
  
2. Group lock ğŸ‘¥ğŸ”: This is like a club for your friends. Only the friends in this club can play with the toy/file, but others can't. ğŸ‘¦ğŸ‘§ğŸ”“
  
3. Everyone lock ğŸŒğŸ”: It's like sharing with everyone! If this lock is open, anyone can see or play with the toy/file. If it's closed, they can't. ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦ğŸš«

So, when your computer is a detective ğŸ•µï¸â€â™‚ï¸, it checks these locks to see who can do what with the toys/files. If you're the owner, you can open your toy box and play. If you're in the group, you can play with your friends. And if the everyone lock is open, everyone can join the fun! ğŸ‰ğŸˆ

That's how Linux keeps things safe and lets the right people do the right things with their stuff. Remember, it's like your toy box, but with secret locks! ğŸ—ï¸ğŸ¤«
![1698238907249](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/d7146363-6b1a-43f4-ab9c-e859d521485f)

## Session, cookie, JWT, token, SSO, and OAuth 2.0 - what are they?
These terms relate to managing user identity when logging into websites. You declare who you are (identification), your identity is verified (authentication), and you're granted appropriate permissions (authorization). Many solutions exist and continue to emerge.

From simple to more complex:

ğŸ”¹WWW-Authenticate is very basic. The browser prompts for username and password. It lacks control over the login lifecycle, so is rarely used today.

ğŸ”¹Session-cookie is prevalent in browsers. Servers maintain session storage, and browsers store session IDs in cookies. While browsers primarily use cookies, mobile apps can use them in web views but often prefer tokens for native functions.

ğŸ”¹Tokens are encoded data used for validation, allowing clients to avoid sending credentials repeatedly. They ensure data integrity but aren't always encrypted.

ğŸ”¹JWT provides a standardized format for tokens. They are digitally signed to ensure their authenticity. Because JWTs can hold session or user data in their claims, servers don't need to store this information separately for verification.

ğŸ”¹SSO (single sign-on) lets you log in once then access multiple sites. Uses central authentication service (CAS) to maintain cross-site info.

ğŸ”¹OAuth 2.0 authorizes one site to access your info on another site.

How do you see this landscape evolving? Will any particular standards dominate for web and mobile login?
![1698293519750](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/1d0f1cce-0fe2-465d-85ad-528181fe27b8)

## ğ„ğ¯ğğ«ğ² ğ„ğ§ğ ğ¢ğ§ğğğ« ğŒğ®ğ¬ğ­ ğ¤ğ§ğ¨ğ° ğ­ğ¡ğ ğ“ğ¨ğ© ğŸğŸ ğƒğğ¬ğ¢ğ ğ§ ğğšğ­ğ­ğğ«ğ§ğ¬ â—ï¸â—ï¸
Several design patterns are commonly used in software development to solve recurring problems. Some of the most frequently used design patterns.

1.Singleton Pattern: ğŸ•º Ensures a class has only one instance and provides a global point of access to it.
2.Factory Method Pattern: ğŸ­ Defines an interface for creating an object but allows subclasses to alter the type of objects that will be created.
3.Abstract Factory Pattern: ğŸ­ğŸ­ Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
4.Builder Pattern: ğŸ—ï¸ Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.
5.Prototype Pattern: ğŸ§¬ Creates new objects by copying an existing object, known as the prototype, instead of creating objects from scratch.
6.Adapter Pattern: ğŸ§©Allows the interface of an existing class to be used as another interface, making it compatible with client code.
7.Decorator Pattern: ğŸ¨ Attaches additional responsibilities to an object dynamically, providing a flexible alternative to subclassing for extending functionality.
8.Observer Pattern: ğŸ‘ï¸â€ğŸ—¨ï¸Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
9.Strategy Pattern: ğŸ¹Defines a family of algorithms, encapsulates each one, and makes them interchangeable. It lets the algorithm vary independently from clients that use it.
10.Command Pattern: âœ…Encapsulates a request as an object, thereby allowing for parameterization of clients with requests, queuing of requests, and logging of requests.
11.MVC (Model-View-Controller) Pattern: ğŸ–¥ï¸ Separates an application into three interconnected components â€“ the Model (data and business logic), View (presentation and user interface), and Controller (user input and control flow).
12.Composite Pattern: ğŸŒ² Composes objects into tree structures to represent part-whole hierarchies. Clients can treat individual objects and compositions of objects uniformly.
13.State Pattern: ğŸ³ï¸Allows an object to alter its behavior when its internal state changes. The object will appear to change its class.
14.Chain of Responsibility Pattern: ğŸ”—Passes a request along a chain of handlers, allowing each handler to decide either to process the request or to pass it to the next handler in the chain.

These design patterns help in creating maintainable, flexible, and efficient software systems by promoting good coding practices and modularity. The choice of pattern depends on the specific problem youâ€™re trying to solve and the design goals you want to achieve.
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/180a2b92-1eed-4264-9038-33a1a0a8698a)

## 6 Database Types You Must Know
1. Relational Database ğŸ’¼
  - Data Model: Organizes data into tables with rows and columns.
  - Examples: MySQL, PostgreSQL, Oracle, SQL Server.
  - Key Features: ACID compliance, strong data consistency, structured data storage, support for SQL queries, well-suited for complex transactions and reporting.

2. Document Database ğŸ“„
  - Data Model: Stores data in semi-structured or JSON-like documents.
  - Examples: MongoDB, CouchDB, Firebase Firestore.
  - Key Features: Flexible schema, horizontal scalability, support for semi-structured data, well-suited for content management systems and real-time applications.

3. In-Memory Database ğŸš€
  - Data Model: Stores data entirely in the system's main memory (RAM).
  - Examples: Redis, Memcached, Apache Ignite.
  - Key Features: Ultra-fast data retrieval, low-latency, suitable for caching, session management, and real-time analytics.

4. Graph Database ğŸŒ
  - Data Model: Represents data as nodes and edges to model relationships.
  - Examples: Neo4j, Amazon Neptune, ArangoDB.
  - Key Features: Efficient querying of complex relationships, graph traversal, suitable for social networks, recommendation systems, and fraud detection.

5. Time-Series Database ğŸ“ˆ
  - Data Model: Optimized for time-ordered data points, like sensor readings or log files.
  - Examples: InfluxDB, Prometheus, TimescaleDB.
  - Key Features: Efficient storage and retrieval of time-series data, aggregations, retention policies, ideal for monitoring, IoT, and event data.

6. Spatial Database ğŸŒ
  - Data Model: Designed for storing and querying spatial or geographic data.
  - Examples: PostGIS (extension for PostgreSQL), MongoDB Geospatial, Microsoft SQL Server Spatial.
  - Key Features: Geospatial indexing, support for spatial data types (points, polygons, lines), useful for location-based services, GIS (Geographic Information Systems), and map applications.

![1698277235447](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/8393257a-c862-4052-a8ec-57c8ddeccfe2)

## 9 types of API testing
Explaining 9 types of API testing. The method to download the high-resolution PDF is available at the end.

ğŸ”¹ Smoke Testing
This is done after API development is complete. Simply validate if the APIs are working and nothing breaks.

ğŸ”¹ Functional Testing
This creates a test plan based on the functional requirements and compares the results with the expected results.

ğŸ”¹ Integration Testing
This test combines several API calls to perform end-to-end tests. The intra-service communications and data transmissions are tested.

ğŸ”¹ Regression Testing
This test ensures that bug fixes or new features shouldnâ€™t break the existing behaviors of APIs.

ğŸ”¹ Load Testing
This tests applicationsâ€™ performance by simulating different loads. Then we can calculate the capacity of the application.

ğŸ”¹ Stress Testing
We deliberately create high loads to the APIs and test if the APIs are able to function normally.

ğŸ”¹ Security Testing
This tests the APIs against all possible external threats.

ğŸ”¹ UI Testing
This tests the UI interactions with the APIs to make sure the data can be displayed properly.

ğŸ”¹ Fuzz Testing
This injects invalid or unexpected input data into the API and tries to crash the API. In this way, it identifies the API vulnerabilities

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/f99ce25d-aa29-4955-a263-be6cb3fa303b)

## API Gateway 
An API Gateway is a server that acts as a single entry point for managing, aggregating, and routing API requests.


It's the key to efficiently handling API traffic, ensuring security, and optimizing performance. ğŸš€

The API Gateway Architecture consists of several layers, each serving a unique purpose. Here are top 4 layers -

1ï¸âƒ£ ğ—¡ğ—²ğ˜ğ˜„ğ—¼ğ—¿ğ—¸ ğ—¦ğ—²ğ—°ğ˜‚ğ—¿ğ—¶ğ˜ğ˜† ğ—Ÿğ—®ğ˜†ğ—²ğ—¿ ğŸ›¡ï¸:
This layer takes care of protecting your API infrastructure from threats. It enforces security policies such as SSL/TLS, DDoS protection, and rate limiting, ensuring that your APIs are not vulnerable to unauthorized access or misuse.

2ï¸âƒ£ ğ—”ğ—±ğ—ºğ—¶ğ—»ğ—¶ğ˜€ğ˜ğ—¿ğ—®ğ˜ğ—¶ğ˜ƒğ—² ğ—Ÿğ—®ğ˜†ğ—²ğ—¿ ğŸ› ï¸:
Managing APIs is no small task. That's where the Administrative Layer comes in. It provides features for API versioning, monitoring, logging, and analytics. With these tools, you can keep track of API usage, diagnose issues, and gain insights into how your APIs are performing.

3ï¸âƒ£ ğ—”ğ—°ğ—°ğ—²ğ˜€ğ˜€ ğ—Ÿğ—®ğ˜†ğ—²ğ—¿ ğŸ—ï¸:
Controlling who gets access to your APIs is crucial. The Access Layer handles authentication, authorization, and access control policies. Whether it's through API keys, OAuth tokens, or other mechanisms, you have the power to decide who can access your APIs and what they can do.

4ï¸âƒ£ ğ—§ğ—¿ğ—®ğ—»ğ˜€ğ—³ğ—¼ğ—¿ğ—ºğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—Ÿğ—®ğ˜†ğ—²ğ—¿ ğŸ”„:
APIs come in all shapes and sizes, and it's not always easy to make them work together. The Transformation Layer helps by providing tools for data transformation and protocol conversion. Whether you need to convert JSON to XML, handle different authentication schemes, or support legacy systems, this layer has got you covered.

ğ—•ğ—²ğ—»ğ—²ğ—³ğ—¶ğ˜ğ˜€ ğ—¼ğ—³ ğ—®ğ—» ğ—”ğ—£ğ—œ ğ—šğ—®ğ˜ğ—²ğ˜„ğ—®ğ˜†

ğŸš€ Performance Boost
ğŸ›¡ï¸ Enhanced Security
ğŸ§© Simplified Microservices
ğŸ’¡ Unified API Management

ğ—§ğ˜†ğ—½ğ—²ğ˜€ ğ—¼ğ—³ ğ—”ğ—£ğ—œ ğ—šğ—®ğ˜ğ—²ğ˜„ğ—®ğ˜†

âœ… Edge Gateways: Placed on the outer layer of your network, they handle public APIs, focusing on load balancing, security, and caching.

âœ… Internal Gateways: Catering to internal APIs, they help optimize inter-service communication and manage internal API traffic.

âœ… Micro-Gateways: Lightweight and tailored for specific use cases, they're deployed in close proximity to specific services, often within containerized environments.


ğ—£ğ—¼ğ—½ğ˜‚ğ—¹ğ—®ğ—¿ ğ—”ğ—£ğ—œ ğ—šğ—®ğ˜ğ—²ğ˜„ğ—®ğ˜† ğ—§ğ—¼ğ—¼ğ—¹ğ˜€

ğŸ”µ Amazon API Gateway
ğŸŸ¢ Kong
ğŸ”´ Apigee Edge
ğŸ”¶ Azure API Management
ğŸŸ£ Tyk

Did I miss any crucial concept?

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/dec7d8d6-bb78-4b8c-b76a-04041915a3c3)

## WORLD OF MICROSERVICES DESIGN PATTERN!!

[1698043583699.pdf](https://github.com/jdbirla/JD-Common-Learning/files/14416358/1698043583699.pdf)

## How Do C++, Java, and Python Function? We just made a video on this topic.
How Do C++, Java, and Python Function? We just made a video on this topic.

The illustration details the processes of compilation and execution.

Languages that compile transform source code into machine code using a compiler. This machine code can subsequently be run directly by the CPU. For instance: C, C++, Go.

In contrast, languages like Java first convert the source code into bytecode. The Java Virtual Machine (JVM) then runs the program. Occasionally, a Just-In-Time (JIT) compiler translates the source code into machine code to enhance execution speed. Some examples are Java and C#.

Languages that are interpreted don't undergo compilation. Instead, their code is processed by an interpreter during execution. Python, Javascript, and Ruby are some examples.

Generally, compiled languages have a speed advantage over interpreted ones.
![1698075576783](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/48f41339-57a0-45f3-815e-44910396fc88)

## How do we transform a system to be Cloud Native?
The diagram below shows the action spectrum and adoption roadmap. You can use it as a blueprint for adopting cloud-native in your organization.

For a company to adopt cloud native architecture, there are 6 aspects in the spectrum:

1. Application definition development
2. Orchestration and management
3. Runtime
4. Provisioning
5. Observability
6. Serverless

Over to you: Where does your system stand in the adoption roadmap?

Reference: Cloud & DevOps: Continuous Transformation by MIT
Redrawn by ByteByteGo
![1695656751388](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/5752afbe-2ac6-4843-8552-a58ceb540be5)


## Best ways to test system functionality. Next week's topic will be listed at the end.
Best ways to test system functionality. Next week's topic will be listed at the end.

Testing system functionality is a crucial step in software development and engineering processes.

It ensures that a system or software application performs as expected, meets user requirements, and operates reliably.

Here we delve into the best ways:

1. Unit Testing: Ensures individual code components work correctly in isolation.

2. Integration Testing: Verifies that different system parts function seamlessly together.

3. System Testing: Assesses the entire system's compliance with user requirements and performance.

4. Load Testing: Tests a system's ability to handle high workloads and identifies performance issues.

5. Error Testing: Evaluates how the software handles invalid inputs and error conditions.

6. Test Automation: Automates test case execution for efficiency, repeatability, and error reduction.

Over to you: How do you approach testing system functionality in your software development or engineering projects?

Over to you: what's your company's release process look like?

Next week, we will talk about:
- Python vs. C++ vs. Java (YouTube)
- Cloud provider cheatsheet (AWS, GCP, Azure, Oracle, Alibaba Cloud)
- Object stores
- Tech interview materials
- Mobile release

![1697988792124](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/15bc6771-8542-4d4f-baad-252c15726b9a)
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/75a9e697-f581-4765-964a-469f7db1fd29)

## Cloud Certifications - Role Based Roadmap ğŸ‘‡
Navigating the certification paths for 8 popular roles.

AWS:
1. Solutions Architect:
Cloud Practitioner Foundational
Solutions Architect Associate
Solutions Architect Professional

2. Cloud Data Engineer:
Cloud Practitioner Foundational
Solutions Architect Associate
Data Analytics Specialty

3. Software Development Engineer:
Cloud Practitioner Foundational
Developer Associate

4. System Administrator:
Cloud Practitioner Foundational
SyOps Administrator Associate

5. Cloud DevOps Engineer:
Cloud Practitioner Foundational
Developer Associate
DevOps Engineer Professional

6. Cloud Security Engineer:
Cloud Practitioner Foundational
SyOps Administrator Associate
Security Specialty

7. Network Engineer:
Cloud Practitioner Foundational
Solutions Architect Associate
Advanced Networking Specialty

8. Machine Learning Engineer:
Cloud Practitioner Foundational
Solutions Architect Associate
Machine Learning Specialty


Azure:
1. Solutions Architect:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Solutions Architect Expert

2. Cloud Data Engineer:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Data Engineer Associate

3. Software Development Engineer:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Developer Associate

4. System Administrator:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Administrator Associate

5. Cloud DevOps Engineer:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Developer Associate
Microsoft Certified: DevOps Engineer Expert

6. Cloud Security Engineer:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Administrator Associate
Microsoft Certified: Azure Security Engineer Associate

7. Network Engineer:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure Network Engineer Associate

8. Machine Learning Engineer:
Microsoft Certified: Azure Fundamentals
Microsoft Certified: Azure AI Engineer Associate


Google Cloud:
1. Solutions Architect:
Associate Cloud Engineer
Professional Cloud Architect

2. Cloud Data Engineer:
Associate Cloud Engineer
Professional Data Engineer

3. Software Development Engineer:
Associate Cloud Engineer
Professional Cloud Developer

4. System Administrator:
Associate Cloud Engineer

5. Cloud DevOps Engineer:
Associate Cloud Engineer
Professional DevOps Engineer

6. Cloud Security Engineer:
Associate Cloud Engineer
Professional Security Engineer

7. Network Engineer:
Associate Cloud Engineer
Professional Network Engineer

8. Machine Learning Engineer:
Associate Cloud Engineer
Professional Machine Learning Engineer

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/c759d1ca-855e-4d78-942c-21a7b4984820)

## Explaining 5 unique ID generators in distributed systems.
The diagram below shows how they work. Each generator has its pros and cons.

1. UUID
A UUID has 128 bits. It is simple to generate and no need to call another service. However, it is not sequential and inefficient for database indexing. Additionally, UUID doesnâ€™t guarantee global uniqueness. We need to be careful with ID conflicts (although the chances are slim.)

2. Snowflake
Snowflakeâ€™s ID generation process has multiple components: timestamp, machine ID, and serial number. The first bit is unused to ensure positive IDs. This generator doesnâ€™t need to talk to an ID generator via the network, so is fast and scalable.

Snowflake implementations vary. For example, data center ID can be added to the â€œMachineIDâ€ component to guarantee global uniqueness.

3. DB auto-increment
Most database products offer auto-increment identity columns. Since this is supported in the database, we can leverage its transaction management to handle concurrent visits to the ID generator. This guarantees uniqueness in one table. However, this involves network communications and may expose sensitive business data to the outside. For example, if we use this as a user ID, our business competitors will have a rough idea of the total number of users registered on our website.

4. DB segment
An alternative approach is to retrieve IDs from the database in batches and cache them in the ID servers, each ID server handling a segment of IDs. This greatly saves the I/O pressure on the database.

5. Redis
We can also use Redis key-value pair to generate unique IDs. Redis stores data in memory, so this approach offers better performance than the database.
![1697823917063](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/3da6f09e-14bb-4a8a-929c-b9901a259c8e)


## Explaining JSON Web Token (JWT) to a 10 year old Kid.
Explaining JSON Web Token (JWT) to a 10 year old Kid.
.
.
Imagine you have a special box called a JWT. Inside this box, there are three parts: a header, a payload, and a signature.

The header is like the label on the outside of the box. It tells us what type of box it is and how it's secured. It's usually written in a format called JSON, which is just a way to organize information using curly braces { } and colons : .

The payload is like the actual message or information you want to send. It could be your name, age, or any other data you want to share. It's also written in JSON format, so it's easy to understand and work with.

Now, the signature is what makes the JWT secure. It's like a special seal that only the sender knows how to create. The signature is created using a secret code, kind of like a password. This signature ensures that nobody can tamper with the contents of the JWT without the sender knowing about it.

When you want to send the JWT to a server, you put the header, payload, and signature inside the box. Then you send it over to the server. The server can easily read the header and payload to understand who you are and what you want to do.

Over to you: When should we use JWT for authentication? What are some other authentication methods?

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/c8564cba-4f34-46cf-b072-44430a1d3059)

## IBM MQ -> RabbitMQ -> Kafka ->Pulsar
IBM MQ -> RabbitMQ -> Kafka ->Pulsar, How do message queue architectures evolve?

ğŸ”¹ IBM MQ
IBM MQ was launched in 1993. It was originally called MQSeries and was renamed WebSphere MQ in 2002. It was renamed to IBM MQ in 2014. IBM MQ is a very successful product widely used in the financial sector. Its revenue still reached 1 billion dollars in 2020.

ğŸ”¹ RabbitMQ
RabbitMQ architecture differs from IBM MQ and is more similar to Kafka concepts. The producer publishes a message to an exchange with a specified exchange type. It can be direct, topic, or fanout. The exchange then routes the message into the queues based on different message attributes and the exchange type. The consumers pick up the message accordingly.

ğŸ”¹ Kafka
In early 2011, LinkedIn open sourced Kafka, which is a distributed event streaming platform. It was named after Franz Kafka. As the name suggested, Kafka is optimized for writing. It offers a high-throughput, low-latency platform for handling real-time data feeds. It provides a unified event log to enable event streaming and is widely used in internet companies.

Kafka defines producer, broker, topic, partition, and consumer. Its simplicity and fault tolerance allow it to replace previous products like AMQP-based message queues.

ğŸ”¹ Pulsar
Pulsar, developed originally by Yahoo, is an all-in-one messaging and streaming platform. Compared with Kafka, Pulsar incorporates many useful features from other products and supports a wide range of capabilities. Also, Pulsar architecture is more cloud-native, providing better support for cluster scaling and partition migration, etc.

There are two layers in Pulsar architecture: the serving layer and the persistent layer. Pulsar natively supports tiered storage, where we can leverage cheaper object storage like AWS S3 to persist messages for a longer term.

Over to you: which message queues have you used?

![1697177276062](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/041a3d1c-27bc-4db3-87ed-df08489db5a2)
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/d5def874-bd44-4562-8f49-f4e5840583f1)

## Top 6 Load Balancing Algorithms
Top 6 Load Balancing Algorithms

ğŸ”¹ Static Algorithms
1. Round robin
The client requests are sent to different service instances in sequential order. The services are usually required to be stateless.

2. Sticky round-robin
This is an improvement of the round-robin algorithm. If Aliceâ€™s first request goes to service A, the following requests go to service A as well.

3. Weighted round-robin
The admin can specify the weight for each service. The ones with a higher weight handle more requests than others.

4. Hash
This algorithm applies a hash function on the incoming requestsâ€™ IP or URL. The requests are routed to relevant instances based on the hash function result.

ğŸ”¹ Dynamic Algorithms
5. Least connections
A new request is sent to the service instance with the least concurrent connections.

6. Least response time
A new request is sent to the service instance with the fastest response time.
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/39021daa-2c10-444b-bf0f-ece6e5f69849)

## ğ—–ğ—¹ğ—²ğ—®ğ—¿ğ—¶ğ—»ğ—´ ğ˜ğ—µğ—² ğ—™ğ—¼ğ—´: ğ——ğ—®ğ˜ğ—®ğ—¢ğ—½ğ˜€ ğ—¶ğ˜€ ğ—¡ğ—¢ğ—§ ğ— ğ—²ğ—¿ğ—²ğ—¹ğ˜† ğ——ğ—²ğ˜ƒğ—¢ğ—½ğ˜€ ğ—³ğ—¼ğ—¿ ğ——ğ—®ğ˜ğ—®!

Thereâ€™s a bit of a myth we need to bust today: DataOps is NOT DevOps for data. ğŸš«

âŒ So letâ€™s unwrap this mystery together, but in super straightforward words! ğŸ

ğ——ğ—²ğ˜ƒğ—¢ğ—½ğ˜€ ğ—¶ğ—» ğ—® ğ—¡ğ˜‚ğ˜ğ˜€ğ—µğ—²ğ—¹ğ—¹ ğŸ¥œğŸ‘¥

- ğ——ğ—²ğ˜ƒğ—¢ğ—½ğ˜€: Picture this as a perfect tag team! One teammate, the developer, builds software, while the other, the operations team, ensures it runs seamlessly. Together, they aim to deliver quick and flawless software to users. Itâ€™s all about a speedy and efficient creation
and delivery process. ğŸš€ğŸ’»

ğ™³ğšğšŸğ™¾ğš™ğšœ = [ğ™¿ğš•ğšŠğš— + ğ™²ğš˜ğšğš + ğ™²ğ™¸(ğ™±ğšğš’ğš•ğš + ğšƒğšğšœğš) + ğ™²ğ™³(ğ™³ğšğš™ğš•ğš˜ğš¢) + ğ™¾ğš™ğšğš›ğšŠğšğš(ğšğšğš— + ğ™¼ğš˜ğš—ğš’ğšğš˜ğš›) + ğ™µğšğšğšğš‹ğšŠğšŒğš”(ğ™»ğšğšŠğš›ğš— + ğ™¿ğš•ğšŠğš—)]

ğ——ğ—¶ğ—´ğ—´ğ—¶ğ—»ğ—´ ğ—¶ğ—»ğ˜ğ—¼ ğ——ğ—®ğ˜ğ—®ğ—¢ğ—½ğ˜€ ğŸ•µï¸â€â™‚ï¸ğŸ“Š

- ğ——ğ—®ğ˜ğ—®ğ—¢ğ—½ğ˜€: While itâ€™s got some vibe from DevOps, itâ€™s got its unique flavor! Itâ€™s less about building software and more about ensuring data flows like a peaceful river through your organization, always clear, trustworthy, and ready to make informed business decisions! It involves ensuring everyone from data scientists to business analysts is on the same page. ğŸï¸ğŸ“˜
ğ™³ğšŠğšğšŠğ™¾ğš™ğšœ = [ğ™´ğš¡ğš™ğš•ğš˜ğš›ğš(ğš‚ğšŠğš—ğšğš‹ğš˜ğš¡ ğ™¼ğšŠğš—ğšŠğšğšğš–ğšğš—ğš) + ğ™³ğšğšŸğšğš•ğš˜ğš™ + ğ™²ğ™¸(ğ™¾ğš›ğšŒğš‘ğšğšœğšğš›ğšŠğšğš + ğšƒğšğšœğš) + ğ™²ğ™³(ğ™³ğšğš™ğš•ğš˜ğš¢) + ğ™¾ğš™ğšğš›ğšŠğšğš(ğ™¾ğš›ğšŒğš‘ğšğšœğšğš›ğšŠğšğš + ğ™¼ğš˜ğš—ğš’ğšğš˜ğš›) + ğ™µğšğšğšğš‹ğšŠğšŒğš”(ğ™°ğš—ğšŠğš•ğš¢ğš£ğš + ğ™´ğš¡ğš™ğš•ğš˜ğš›ğš)]


ğ—¦ğ—½ğ—¼ğ˜ğ˜ğ—¶ğ—»ğ—´ ğ˜ğ—µğ—² ğ——ğ—¶ğ—³ğ—³ğ—²ğ—¿ğ—²ğ—»ğ—°ğ—²ğ˜€ ğŸ”„ğŸ”

- DevOps connects developers and operations, while DataOps unites a larger group: developers, data scientists, data engineers, and business minds. ğŸŒğŸ¤—

- DataOps uniquely addresses the journey of data - from raw numbers to insightful analytics

- ensuring itâ€™s clean, usable, and delivered without a hiccup! ğŸ“ˆâœ¨

ğ—ªğ—µğ˜† ğ——ğ—¼ğ—²ğ˜€ ğ—œğ˜ ğ— ğ—®ğ˜ğ˜ğ—²ğ—¿? ğŸ¤·â€â™€ï¸ğŸ¯

Recognizing these subtle differences helps us implement the right strategies and tools in our projects.

Whether weâ€™re crafting software with #DevOps or navigating the exciting world of data with #DataOps, identifying their unique abilities is key! ğŸ”ğŸ› ï¸

So, data pals, what are your thoughts? ğŸ—£ï¸ğŸ’­

Dive into the comments and let's create a whirlpool of knowledge together! ğŸŒ€ğŸ‘¥

If this friendly chat was a lightbulb moment, share it to spread the insight! ğŸ’¡ğŸ”„

ğŸŒº Your insights light up the community! Looking forward to reading your delightful thoughts below! ğŸŒº

![1697159073135](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/2fd0bf01-65b5-4a93-bd1d-5905d6f98ae1)

## 12 Factor App
The 12 Factor App is a methodology for building scalable and maintainable web applications. It provides a set of guidelines for developing modern, cloud-native, and containerized applications. Here are the 12 factors explained in bullet points:

1. Codebase:
  - One codebase per application.
  - Use version control to manage code changes.

2. Dependencies:
  - Explicitly declare and isolate dependencies.
  - Avoid relying on system-wide packages.

3. Config:
  - Store configuration in environment variables.
  - Keep configuration separate from code.

4. Backing Services:
  - Treat external services (databases, caches, etc.) as attached resources.
  - Connect to them via URLs or environment variables.

5. Build, Release, Run:
  - Strictly separate the build, release, and run stages of the application.
  - Use consistent and repeatable build processes.

6. Processes:
  - Execute the application as stateless processes.
  - Avoid storing session data locally; use external services.

7. Port Binding:
  - Export services via a port and communicate over the network.
  - Web applications should bind to a port defined by the environment.

8. Concurrency:
  - Scale out via the process model.
  - Utilize multiple stateless processes to handle requests.

9. Disposability:
  - Maximize robustness with fast startup and graceful shutdown.
  - Terminate unneeded processes without impact.

10. Dev/Prod Parity:
  - Keep development, staging, and production environments as similar as possible.
  - Use the same dependencies and configuration.

11. Logs:
  - Treat logs as event streams.
  - Write application logs to standard output and allow log aggregation.

12. Admin Processes:
  - Run administrative tasks as one-off processes.
  - Use the same codebase and environment for administrative tasks.

Adhering to these 12 factors helps create applications that are easier to develop, deploy, and maintain, making them well-suited for cloud-native and containerized environments.

![1697068638860](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/ce886ab6-c65d-4c83-a005-135a6618ed6d)

## The 5 Deployment Patterns to Know in 2023
Software development is a complex process involving several stages.

Here is a simplified view of these stages:

ğ—¥ğ—²ğ—¾ğ˜‚ğ—¶ğ—¿ğ—²ğ—ºğ—²ğ—»ğ˜ğ˜€ ğ—šğ—®ğ˜ğ—µğ—²ğ—¿ğ—¶ğ—»ğ—´: The initial step where we determine and document the software needs from users or stakeholders.

ğ——ğ—²ğ˜€ğ—¶ğ—´ğ—»: ğ—œn this phase, we architect the system, craft the user interface, and plan software component interactions.

ğ—œğ—ºğ—½ğ—¹ğ—²ğ—ºğ—²ğ—»ğ˜ğ—®ğ˜ğ—¶ğ—¼ğ—» (ğ—–ğ—¼ğ—±ğ—¶ğ—»ğ—´): Developers write the software code in an appropriate programming language during this stage.

ğ—§ğ—²ğ˜€ğ˜ğ—¶ğ—»ğ—´: The software is checked and rectified to ensure it functions as intended, free of bugs or issues.

ğ——ğ—²ğ—½ğ—¹ğ—¼ğ˜†ğ—ºğ—²ğ—»ğ˜: Post approval, the software is deployed, meaning it's set up in a live environment, available to end-users.

ğ— ğ—®ğ—¶ğ—»ğ˜ğ—²ğ—»ğ—®ğ—»ğ—°ğ—²: Once live, the software requires continuous upkeep, including bug fixing, updates for new requirements, or performance enhancements.

Deployment is a crucial part of this process. It is not just about hitting a "launch" button; it's an art that requires strategic planning and precision. ğŸ¯

Thatâ€™s where deployment patterns come in. These are strategies that ensure the software's safe transition from the development environment to your devices.

Here are some common deployment patterns in software engineering:

1ï¸âƒ£ ğŸ¤ ğ—–ğ—®ğ—»ğ—®ğ—¿ğ˜† ğ—¥ğ—²ğ—¹ğ—²ğ—®ğ˜€ğ—²ğ˜€: Imagine introducing a new feature like you're testing the waters. You release it to a small group first, monitor performance, and if all's well, roll it out to everyone. That's the beauty of Canary Releases - the early bird catching the worm! ğŸ¯

2ï¸âƒ£ ğŸ”µğŸŸ¢ ğ—•ğ—¹ğ˜‚ğ—²/ğ—šğ—¿ğ—²ğ—²ğ—» ğ——ğ—²ğ—½ğ—¹ğ—¼ğ˜†ğ—ºğ—²ğ—»ğ˜: Picture having two production environments, as identical as twin peas in a pod. One serves live (Blue), while you deploy and test in the other (Green). Once ready, just flip the switch! Seamless transitions with near-zero downtime. ğŸ”„

3ï¸âƒ£ ğŸš¦ğ—™ğ—²ğ—®ğ˜ğ˜‚ğ—¿ğ—² ğ—§ğ—¼ğ—´ğ—´ğ—¹ğ—²ğ˜€: Also known as feature flags, this strategy is like having a superhero's dual identity! It allows developers to turn features on/off, enabling flexible releases and testing. You control who sees what and when - in real-time! â°

4ï¸âƒ£ ğŸ…°ï¸/ğŸ…±ï¸ ğ—”/ğ—• ğ—§ğ—²ğ˜€ğ˜ğ—¶ğ—»ğ—´: Ever wished you could read your user's mind? A/B Testing comes close. It helps understand user preferences by comparing two versions (A and B) of a feature. It's a litmus test to identify what works best for your audience! ğŸ²

5ï¸âƒ£ ğŸŒ‘ ğ——ğ—®ğ—¿ğ—¸ ğ—Ÿğ—®ğ˜‚ğ—»ğ—°ğ—µğ—²ğ˜€: Ever unveiled a magic trick before the grand performance? That's what Dark Launches are like! Features are quietly released to a subset of users to gather data and rectify issues before the actual launch. No fanfare, no fuss, just a whole lot of valuable insights! ğŸ•µï¸

![1696963360598](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/66699046-96fe-47e1-a324-a607b874e854)

##  companies ship code to production
How do companies ship code to production? The method to download the high-resolution PDF is available at the end.

The diagram below illustrates the typical workflow.

Step 1: The process starts with a product owner creating user stories based on requirements.

Step 2: The dev team picks up the user stories from the backlog and puts them into a sprint for a two-week dev cycle.

Step 3: The developers commit source code into the code repository Git.

Step 4: A build is triggered in Jenkins. The source code must pass unit tests, code coverage threshold, and gates in SonarQube.

Step 5: Once the build is successful, the build is stored in artifactory. Then the build is deployed into the dev environment.

Step 6: There might be multiple dev teams working on different features. The features need to be tested independently, so they are deployed to QA1 and QA2.

Step 7: The QA team picks up the new QA environments and performs QA testing, regression testing, and performance testing.

Steps 8: Once the QA builds pass the QA teamâ€™s verification, they are deployed to the UAT environment.

Step 9: If the UAT testing is successful, the builds become release candidates and will be deployed to the production environment on schedule.

Step 10: SRE (Site Reliability Engineering) team is responsible for prod monitoring.
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/7af831c2-1398-4c3a-befa-c54a84ee819c)

## What happens when you type a URL into a browser?

What happens when you type a URL into a browser? The method to download the high-resolution PDF is available at the end.

Letâ€™s look at the process step by step.

Step 1: The user enters a URL (www. bytebytego. com) into the browser and hits Enter. The first thing we need to do is to translate the URL to an IP address. The mapping is usually stored in a cache, so the browser looks for the IP address in multiple layers of cache: the browser cache, OS cache, local cache, and ISP cache. If the browser couldnâ€™t find the mapping in the cache, it will ask the DNS (Domain Name System) resolver to resolve it.

Step 2: If the IP address cannot be found at any of the caches, the browser goes to DNS servers to do a recursive DNS lookup until the IP address is found.

Step 3: Now that we have the IP address of the server, the browser sends an HTTP request to the server. For secure access of server resources, we should always use HTTPS. It first establishes a TCP connection with the server via TCP 3-way handshake. Then it sends the public key to the client. The client uses the public key to encrypt the session key and sends to the server. The server uses the private key to decrypt the session key. The client and server can now exchange encrypted data using the session key.

Step 4: The server processes the request and sends back the response. For a successful response, the status code is 200. There are 3 parts in the response: HTML, CSS and Javascript. The browser parses HTML and generates DOM tree. It also parses CSS and generates CSSOM tree. It then combines DOM tree and CSSOM tree to render tree. The browser renders the content and display to the user.
![1696866325286](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/e6f85100-9486-4583-9c60-0534945d2046)

## sheet of various databases in cloud services
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/2333e327-5738-46a7-9ae5-49f819b7f24e)

## Very Powerful Words. Read it.
**What You #Can #Control** ğŸ’ª

1. **Your #Actions** ğŸš¶â€â™‚ï¸: You have the power to decide what you do and how you behave in various situations.

2. **Your #Choices** ğŸ¤”: You can make decisions about your life, goals, and values.

3. **Your #Reactions** ğŸ˜ƒ: You can choose how you respond to challenges, setbacks, and emotions.

4. **Your #Attitude** ğŸ§ : Your outlook on life is within your control, influencing how you perceive and approach situations.

5. **Your #Effort** â­: The level of effort and dedication you put into your endeavors is up to you.

**What You Can't #Control** ğŸ¤·â€â™€ï¸

1. **External #Events** ğŸŒ: You can't control natural disasters, economic changes, or global events.

2. **Other #People's Actions** ğŸ‘¥: You can't control how others behave, but you can control your reactions to their actions.

3. **Past #Events** â³: You can't change what has already happened, but you can control how you move forward.

4. **Uncertain #Future** ğŸ¯: The future is unpredictable; you can't control every #outcome, but you can plan and adapt.

Remember, focusing on what you can control can lead to greater personal #empowerment and resilience.

more #positive thoughts

#1. #Gratitude: Focus on what you're thankful for in your life.
#2. #Optimism: Embrace a positive outlook for the future.
#3. #SelfBelief: Believe in your abilities and potential.
#4. #Positivity: Surround yourself with positive energy and people.
#5. #Empowerment: Take control of your life and goals.
#6. #Resilience: Bounce back from challenges stronger than before.
#7. #Kindness: Spread kindness and positivity to others.
#8. #Mindfulness: Stay present and appreciate each moment.
#9. #Growth: Embrace personal and professional growth opportunities.
#10. #Happiness: Pursue activities and relationships that bring joy.

These positive thoughts can help improve your mindset and overall well-being

![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/effefed1-1935-4199-8870-17954bd97d71)

## caching systems
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/ac24c797-1df5-45ca-b233-ffa28859188d)

## JWT Explained
1. JSON Format: JWTs are represented as JSON objects, making them easy to read by both humans and machines. They consist of three parts separated by dots (`.`): the Header, the Payload, and the Signature.

- Header: The Header typically consists of two parts: the type of the token (JWT) and the signing algorithm being used (e.g., HMAC SHA256 or RSA). It's Base64Url encoded to form the first part of the JWT.

- Payload: The Payload contains the claims, which are statements about an entity (usually, the user) and additional data. Claims can be categorized into three types:

- Registered Claims: These are predefined claims with specific meanings, such as "iss" (issuer), "sub" (subject), "aud" (audience), "exp" (expiration time), and "iat" (issued at time).

- Public Claims: These are user-defined claims that can be freely used, but it's a good practice to avoid common names to prevent conflicts.

- Private Claims: These are custom claims used between parties that agree on their meaning.

- Signature: The Signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't tampered with during transmission. The Signature is created by taking the encoded Header, encoded Payload, a secret (or private key in the case of RSA), and the chosen algorithm, then running them through the algorithm to produce a hash. This hash is used to verify the integrity of the token.

2. Encoding: Each of the three JWT components (Header, Payload, and Signature) is Base64Url encoded, which is a URL-safe variant of Base64 encoding. This encoding ensures that the JWT remains compact and can be safely transmitted in URLs, query parameters, or HTTP headers.

3. Usage: JWTs are often used in authentication and authorization workflows. Here's how it typically works:

- Authentication: When a user logs in or authenticates, the server generates a JWT and signs it with a secret key. This JWT is then sent back to the client, which can store it locally (e.g., in a cookie or local storage) and include it in subsequent requests to prove its identity.

- Authorization: The server, when receiving a request with a JWT, can verify the token's signature using the secret key. If the signature is valid, the server can trust the claims within the token to make authorization decisions, such as determining if the user has the right permissions to access a resource.

4. Statelessness: The server doesn't need to store session data because all the necessary information is contained within the token itself. This can simplify the design of distributed systems.

5. Expiration: JWTs can have an expiration time (specified in the "exp" claim), which means they are only valid for a certain period
![image](https://github.com/jdbirla/JD-Common-Learning/assets/69948118/20024722-91aa-4810-bf85-3e461a52727b)

## 
